能源大模型平台技术路线及实现
==========

# 一、需求

## 1、知识检索集成

* 基于文件上传的知识检索：可以支持对PDF文件等进行上传，并生成相关的快速解读或文本生成。

* 基于系统知识库的知识检索：针对系统的技术库、资讯库等，可以调用内容进行文档总结与提料，也可以按照给定方向生成内容。

* 针对马钢需求，通过预案文本知识库，结合生产运行数据，动态生成相关应对方案。(**移至复合应用**)

## 2、智能问数和分析

* 实现系统内典型指标的数据问答，包括：
  * 直接查询某个确定时间的指标数据。
  * 实现指标数据的趋势、对比分析，并生成简单图表。
  * 支持指标别名及相对精准的匹配（如1#高炉，1高炉，高炉的区分），构建能源工厂建模知识图谱，识别指标关系。
  * 支持查询结构检查，并通过多轮会话来补充查询条件。如查询指标时，如描述不够清晰，让用户补充信息。
  * 支持通过MCP调用，检索与指标相关的关联数据（通过公式引用解析）。(**新增**)
* 实现对数据集的文本化描述，包括：
  * 支持数据文件或结构的智能分析，自动提取要点。
  * 支持对表格等进行指令式分析，生成相关结论。

## 3、智能诊断

* 支持对典型指标分析结果进行诊断。支持对EP分析、影响因素分析、成本分析等数据进行提取，生成分析结论。

* 创建典型工序能耗分析报告智能体，基于数据、基准值等组合接口调用与智能体自主思考，进行业务和数据整合，提取亮点和不足，并生成分析图表。

* 在能源报表中添加“智能解读”，可以针对报表文件或截图，按照设定提示词进行自动解读。

## 4、办公辅助

* 文本润色：封装大模型文本润色API，针对一些过去需要动态拼接和判定生成文本的地方，利用API进行快速处理。
* 代码执行：提供针对数据文件等进行数据分析并生成代码，生成代码并执行的能力。
* 第三方平台对接：考虑针对基于Dify的相关智能体工作流进行支持，提供交互入口和标准调用。
* 系统菜单/报表导航：可以实现菜单、报表的快速检索与导航。
* 系统待办检索：可以实现与自己相关的系统待办的检索与跟进（如查看审批工单）。

## 5、复合应用(**新增**)

* 对马钢需求中的异常工况（如高炉紧急休风等），通过监控生产运行数据进行识别并触发运行优化分配小模型，结合预案文本知识库，动态生成相关应对方案。

 

参考界面：

![b4122b7a7bc5125febbe290fcc54b30a](data:image/png;base64,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GMP/QsNseth0L4GhilV6UXCGSfwZ8nUOJ+mLEFg4FSIIlBjGAH5Y1iTkONttLsEx1jFuyAVfzDBrV7vKS/rcCQB57BjJJsbsXVDQnrvlqH49eROlklzlUgHAAlc5Ec6kt1/G+aS/VhazVKhSmgygwAJoVnOa04yCNa+ZzWumwojHXOe1zKUeMMjAntHA5z37uc99zkCgBz3oPlPgHQtggDxK02hHPxrSkZb0pCldaUu/AwOLHtem59LpMn+a06B2SaIXQGpTjxrVDEiAPBbdala/2tWxhvWsZV1rWt/a1rnG9a513Wte/9rXvg4Ao4MNbGMXG9nHVnaymb3sBLgkANBm//SwFxDtakN7AfKItrazvW1vdxvc3Bb3t8cdbnJbG93Yvva6081uaVd72vGG97ypXW95U/vZ8sAAo/O97wX0m9/Z9jfA/y3wgOv74AM3eMERznCFN7xSjD5yAhrUaFKX5h0MmDSrG00PS38c5CEXOcg1PnKSmzzbJed4yl2ycperHOYtjznLaf5ymd+85jO3ec5xvnOf6xzoPQ86zVEu8p8LHek8V/rRlz50pj996EWX+tSpXnWrL6Aejs761S299dJ43SVgn8uRCW2DP+fgz3y2QgjqQQ8KuN3tCwjBAigQAgrUfR93p0De7+72u/P97XoHvN/3rnfCD17whk9835QXH/i/K/7xjI/82yfwZ0JfvtCY13zmOW8FGHge9J8XfeitMAtCpx31qVf96lnfete/Hvaxl/3saY/60wsa934u9O5zz/va/x74wRd+6s2+5+Kz/vhmL77yM2ADcmQgHBkgh9mnL33qX9/62a8+87nffO93X/loCP/4my/+8pPfBubf8/Olv373t9/7w5f//H/f54AAADs=)

![914db468efe88818d6b4b0c6e9d46679](data:image/png;base64,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)

![666efd46284e3035f7003d35bdefe018](data:image/png;base64,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)

 

 # 二、难点

1. 做精准的指标匹配（包括别名），预计要做知识图谱或者微调；
2. 完成马钢（预案联动）、湛钢的相关需求
3. 多轮会话记忆保持
4. 图表和报告动态生成

# 三、技术路线图

你这个任务范围很大，但可以拆分成「地基 → 平台 → 模块」三个层次来做。我给你一份零基础开发者也能循序渐进的**技术路线图**，这样你知道该先做哪些基础准备，再逐步实现功能。

## 🔹 一、总体技术路线

1. **底层准备（数据+知识）**
   - 建立 **知识库（文档+指标+运行数据）**：
     - 文档：PDF、Word、表格，解析后切块并存入向量库（用于知识检索）。
     - 指标：整理系统里的指标表，建立“指标 → 别名 → 数据表字段”的映射（用于智能问数）。
     - 数据：准备时序数据库（如 PostgreSQL+Timescale 或 ClickHouse），存放生产运行数据。
2. **中间层（模型+RAG+NL2SQL）**
   - 模型调用：选择 LLM（GPT、DeepSeek、Qwen 等）。
   - RAG（检索增强）：结合向量检索库（pgvector、Milvus）+ 文本索引（Elasticsearch）。
   - NL2SQL 层：把自然语言问句转成 SQL → 查询数据库 → 返回结果。
   - Agent/编排：用 Dify 或 LangChain 组织“检索+数据分析+生成报告”的流程。
3. **上层应用（智能管控功能）**
   - **知识检索**：问文档、问系统知识库、动态应对方案。
   - **智能问数**：指标查询、趋势/对比分析、图表输出、模糊别名匹配、多轮补充。
   - **五智能诊断**：能耗分析、成本分析、报表解读。
   - **办公辅助**：润色、代码执行、菜单/待办检索、第三方平台对接。

> 实际操作中是以**智能问数**为切入点，并借助open_webui开源框架贯穿三个流程。

------

## 🔹 二、关键工作清单

✅ **熟悉框架**

- Ollama
- [Open_webui](https://github.com/open-webui)
- Openapi_servers
- FastAPI
- RAG(语义检索增强只是一种思想，实际业务都需要，因为大模型还没有不需要RAG的能力)
- 向量数据库chromaDB(无法精确查找，但是查询效率高，可以返回近似TopN，所以能用来做知识库，同时Open_webui自带chromaDB，所以想在webui上通过传入文件直接问LLM能源指标，不可能精确，就算你传入精确的Name，返回的也是不精确的)
- NL2SQL(现阶段转变为让LLM调用能源接口，可能用不到)
- dify或者langchain(流程编排)
- mcpo(如果需要不同模型统一协议，可能需要)
- piplines(如果工程化，可能需要)

✅ **智能问数与分析**

- open_webui定制模型(agent)，调用工具(或外部工具)完成天气查询demo，证明通过Tools增强大模型各种能力是可行。部署时与能源系统应该采用外部工具方式，因为符合职责分离，解耦且更灵活。
- 准备完成能够精确返回公式的外部工具，如果工具没有精确找到，多轮会话提示用户精确输入(或者给予用户TopN待选项)，直到从公式清单数据源中获取最精确的公式。(不知道是prompt还是流程编排能满足多轮会话轮询找到最终结果)
- 找公式工具完成后，在此基础上完成时间和调用能源接口的功能，完成智能问数的功能。
- 部署至测试服务器，压测，查看性能，解决并发问题。
- 接入小能助手，此时需要考虑指标数据如何存储，如何拿到，什么时候更新相关问题，然后修改问数工具(测试阶段采用能够快速解析的本地方案)。
- Open_webui原生可使用[Action Functions](https://docs.openwebui.com/features/plugin/functions/action)在对话框生成分析按钮并实现功能，如果在小能助手上需要定制开发。至于怎么分析，是调用大模型分析还是能源接口待定。

✅ **大模型对接**

- 选择模型（公司内部是否允许外部 API？若不允许可用开源模型）。
- 写好 Prompt 模板：问答、图表生成、诊断报告。

✅ **知识建模**

- 整理指标标准名、别名、公式关系。
- 把预案文档拆分存入向量库。

✅ **数据接入**

- 搭建时序数据库存指标数据。
- 接通业务系统的待办/菜单接口。

✅ **应用封装**

- 开发 Web 界面（上传文档、问答框、报表展示）。
- 封装 API（知识检索 API、问数 API、诊断 API）。

✅ **安全与治理**

- ACL 权限（谁能查哪些文档/指标）。
- 日志与审计（记录每次 AI 调用、SQL 执行）。

------

# 四、OPEN_WEBUI

## 1、项目简述

### open-webui

- 是一个自托管（self-hosted）、面向用户友好且功能丰富的 AI 平台 / 界面。[GitHub+1](https://github.com/open-webui/open-webui?utm_source=chatgpt.com)
- 支持各种 LLM 推理方式（llm runners），比如 Ollama、OpenAI API 或者兼容 OpenAI 的 API。[docs.openwebui.com+1](https://docs.openwebui.com/?utm_source=chatgpt.com)
- 提供界面、插件、工具／pipeline 支持，用户可以本地部署，用来聊天 / 探索模型 /做 RAG（Retrieval-Augmented Generation）等。[GitHub+1](https://github.com/open-webui/open-webui?utm_source=chatgpt.com)

> pip更新
>
> 安装 venv（如果没装）
>
> ```
> sudo apt install python3-venv -y
> ```
>
> 创建虚拟环境
>
> ```
> python3 -m venv ~/myenv
> ```
>
> 激活虚拟环境
>
> ```
> source ~/myenv/bin/activate
> ```
> 启动
>
> ```
> # 在同时运行clash条件下,算法服务器纳入openvpn，还需同时开启easyconnect，用于调用业务接口
> env | grep -i proxy
> export NO_PROXY=localhost,127.0.0.1,192.168.92.13,192.168.92.0/24,192.168.122.156,10.8.0.178
> export no_proxy=$NO_PROXY
> open-webui serve
> 
> # 走代理（模拟被 Clash 劫持的情况）
> curl -v -x http://127.0.0.1:7890 http://192.168.92.13:11434/api/version
> # 绕过代理
> curl -v --noproxy 192.168.92.13 http://192.168.92.13:11434/api/version
> 
> # 依赖
> pip freeze > current_versions.txt
> ```
>
> 更新
>
> ```bash
> pip install --upgrade open-webui
> ```

![image-20250928150531967](%E8%83%BD%E6%BA%90%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%B9%B3%E5%8F%B0%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF%E5%8F%8A%E5%AE%9E%E7%8E%B0.assets/image-20250928150531967.png)

> 0.6.33 - 2025-10-08 上一版本source丢失的问题修复了，后端还加了返回值。

![image-20251009155548565](%E8%83%BD%E6%BA%90%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%B9%B3%E5%8F%B0%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF%E5%8F%8A%E5%AE%9E%E7%8E%B0.assets/image-20251009155548565.png)

![image-20251009155630700](%E8%83%BD%E6%BA%90%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%B9%B3%E5%8F%B0%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF%E5%8F%8A%E5%AE%9E%E7%8E%B0.assets/image-20251009155630700.png)

### openapi-servers

- 这个仓库提供了一系列参考实现（reference implementations）或范例工具服务器（tool servers），这些服务器按照 **OpenAPI 规范** 实现。[GitHub](https://github.com/open-webui/openapi-servers)
- 这些工具服务器包括：Filesystem Access（文件系统访问），Git 存储库搜索，Knowledge Graph／Memory，天气（weather）接口，SQL Chat，外部 RAG 工具等。[GitHub](https://github.com/open-webui/openapi-servers)
- 它们的主要用途是：当你需要把某些工具或数据源以标准 API 的形式暴露出来，以便 LLM agent 或者 Open WebUI 这类前端或 agent 框架可以调用，就可以使用这些 openapi-servers。这样不用你自己从头写 API，也确保遵守标准、可安全访问、易于集成。[GitHub](https://github.com/open-webui/openapi-servers)

> FastAPI
>
> ```
> uvicorn main_v2:app --host 0.0.0.0 --port 9001 --reload
> ```

### MCP（Model Context Protocol）以及 mcpo（MCP-to-OpenAPI Proxy）

- **MCP** 是一个 “模型上下文协议”（Model Context Protocol），是 Anthropic 提出的开放标准，用来规范 AI 模型如何与外部工具、服务、数据源交互。它定义了工具服务器（MCP server）的接口，让模型(agent)可以调用这些工具 / 访问这些数据。[维基百科+2docs.openwebui.com+2](https://en.wikipedia.org/wiki/Model_Context_Protocol?utm_source=chatgpt.com)

- **mcpo** 是 open-webui 提供的一个 MCP-to-OpenAPI 的代理（proxy）。它的作用是把 MCP 服务器（通常通过标准输入 / 输出 stdio 或类似方式通信）包装 / 转换成一个标准 HTTP REST OpenAPI 接口。这样，使用 OpenAPI 的系统（比如 openapi-servers，或者 Open WebUI 本身或其他客户端）就可以调用这些工具，就像调用普通 API 一样。[GitHub+1](https://github.com/open-webui/mcpo?utm_source=chatgpt.com)

- 在openwebui中api工具和mcp有什么区别

  ###### ChatGPT 说：

  非常好的问题，这两者在 **Open WebUI**（或类似的“工具增强”环境中）确实容易混淆。
   我来给你一个 **清晰、深入但易懂的对比** 👇

  ------

  ## 🧩 一句话概览

  | 功能类型 | **API 工具（API Tool）**                               | **MCP 工具（Model Context Protocol Tool）**             |
  | -------- | ------------------------------------------------------ | ------------------------------------------------------- |
  | 主要用途 | 让模型调用**外部 HTTP API**                            | 让模型与**本地或远程服务（程序、Agent、数据库等）**交互 |
  | 实现方式 | 直接基于 HTTP 请求 (`GET/POST`)                        | 通过 **Model Context Protocol** 建立标准通信接口        |
  | 典型例子 | 天气 API、翻译 API、搜索 API                           | 文件读取、系统命令、数据库访问、LangChain agent等       |
  | 注册方式 | 在 WebUI 的 “Tools / API Tools” 里配置 URL + Schema    | 在 WebUI 的 “MCP” 区添加 MCP Server 或 `.mcp.json` 文件 |
  | 调用方式 | 模型执行函数调用（`TOOL:weather/get_current_weather`） | 模型通过 MCP 标准调用接口，如 `mcp:fs/read_file`        |
  | 可用范围 | 单一模型或单个会话                                     | 可被多个模型、多个 Agent 共用                           |
  | 性能     | 快速、轻量                                             | 更强大、可持续连接（WebSocket、流式通信）               |

  ------

  ## ⚙️ 深入理解两者区别

  ### 🧠 1. API 工具

  API 工具的设计理念是：

  > “让模型能像调用函数一样访问 HTTP 接口。”

  例如：

  ```
  {
    "name": "get_weather_forecast",
    "description": "获取指定城市天气",
    "url": "http://localhost:9002/forecast",
    "method": "GET",
    "parameters": {
      "latitude": "float",
      "longitude": "float"
    }
  }
  ```

  在对话中，模型可能会自动生成：

  ```
  TOOL:weather/get_weather_forecast
  Parameters: { "latitude": 30.6, "longitude": 114.3 }
  ```

  然后由 Open WebUI 发出实际 HTTP 请求，并把结果展示给模型。

  ✅ **优点：**

  - 快速集成，几乎不需要写代码。
  - 适合 REST API、OpenAPI 等服务。
  - 调用结果能直接在 WebUI 中展示。

  ❌ **缺点：**

  - 功能单一，只支持 HTTP。
  - 无法维持连接或进行复杂交互。
  - 不支持本地环境（例如读取文件、访问数据库）。

  ------

  ### 🧭 2. MCP 工具（Model Context Protocol）

  MCP 是 OpenAI 最近提出的**标准协议**，用于让模型与外部系统进行“智能通信”。

  > 它让模型不仅能调用“API”，还能与**文件系统、终端、数据库、外部智能体（agent）**进行多轮通信。

  比如：

  - 读取或写入文件：`mcp:fs/read_file`
  - 运行本地命令：`mcp:process/run`
  - 访问数据库：`mcp:sql/query`
  - 与自定义服务通信：`mcp:custom_service/do_task`

  注册方式：

  - 在 Open WebUI 里添加 MCP Server；
  - 或通过 `.mcp.json` 文件定义；
  - 或使用 mcpo、LangChain MCP Bridge。

  ✅ **优点：**

  - 功能更强（文件、数据库、系统命令、Python Agent）。
  - 支持双向通信和流式输出。
  - 可扩展、可多模型共享。

  ❌ **缺点：**

  - 需要运行一个 MCP server（Python、Node 等实现）。
  - 配置比普通 API 工具复杂。
  - 目前部分模型对 MCP 调用的支持还不完善。

  ------

  ## 🔍 举例说明区别

  ### 🌦 场景1：获取天气

  - 用 **API 工具**：直接配置 HTTP 请求到 `http://localhost:9002/forecast`
     ✅ 最简便，调用一次即可。
  - 用 **MCP 工具**：你得写一个 MCP server，比如 `weather.mcp.py`，模型通过 MCP 协议请求天气。
     ✅ 更通用，但搭建成本高。

  ### 💾 场景2：读取本地文件

  - API 工具 ❌ 不行（除非你先写个文件读取的 REST 服务）
  - MCP 工具 ✅ 可以直接调用 `mcp:fs/read_file`

  ------

  ## 🧮 总结对比表

  | 对比项     | API 工具                 | MCP 工具                                      |
  | ---------- | ------------------------ | --------------------------------------------- |
  | 调用目标   | HTTP API                 | 任意外部系统（API、文件、数据库、Agent等）    |
  | 通信协议   | HTTP                     | Model Context Protocol (WebSocket / JSON-RPC) |
  | 部署复杂度 | 简单（填写 URL 即可）    | 较复杂（需要运行 MCP server）                 |
  | 适合任务   | 简单、单次 API 查询      | 复杂、多轮、上下文交互                        |
  | 例子       | 天气、搜索、翻译、知识库 | 本地文件系统、数据库、自动化脚本              |

  ------

  ## 🧠 建议你这样用：

  - **要调用你自己的天气 API → 用 API 工具** ✅
     最直接、性能好、已被 WebUI 支持自动展示结果。
  - **要让模型访问本地文件、数据库、shell 等 → 用 MCP 工具** ✅
     特别是以后要构建 Agent 或本地知识库时。

------

## 2、它们之间的关系

可以把这些看成是构成一个生态系统中不同层级或模块的组件，拼在一起可以搭出一个比较强大的 agent 工具平台。大致关系如下：

```
[MCP 工具服务器 (MCP server)]
        ↑
  mcpo 代理 /桥接层
        ↑
[OpenAPI 工具服务器 / OpenAPI clients / Agent 前端（比如 Open WebUI）]
```

- MCP server 提供工具或者数据源（可能是你自己写的，也可以是已有的 MCP 实现）。
- mcpo 把它们暴露为 HTTP + OpenAPI 接口。
- openapi-servers 提供一些开箱即用的工具 /范例 API，可以直接部署，也可以拿来改造或扩展。
- Open WebUI 作为前端 UI /agent界面／平台，可以使用这些通过 OpenAPI 暴露的工具，或者使用 mcpo 暴露的 MCP 工具，来完成交互、工具调用、插件等功能。

**总结一下：**

- **[open-webui/open-webui](https://github.com/open-webui/open-webui?utm_source=chatgpt.com)**
   → 主体项目，提供一个通用的 Web UI，可以接入本地/远程大模型、插件、工具（包括 MCP 智能体）。你可以把它看作一个 “ChatGPT Web 前端 + 插件运行平台”。
- **[open-webui/openapi-servers](https://github.com/open-webui/openapi-servers?utm_source=chatgpt.com)**
   → 不是一个框架，而是一个 **示例仓库集合**，里面放了一堆「外部服务/工具」示例，这些可以作为 **OpenAPI/MCP 插件** 挂到 Open WebUI 上。
  - 比如，它提供了天气查询、计算器、搜索 API 等例子，展示怎么用 OpenAPI/MCP 的方式对接外部服务。
  - 这些示例的目的主要是帮助开发者理解：
    1. MCP 插件应该如何编写接口（OpenAPI 规范或 JSON RPC）。
    2. Open WebUI 如何去发现、调用这些接口。

------

- **open-webui** = 主体运行环境（UI + Agent 容器）。
- **openapi-servers** = 一组参考实现（插件示例，展示如何接外部工具）。

你要定制自己的 MCP 智能体时，可以这样理解：

1. **在 open-webui 里运行 UI**，作为你的对话平台。
2. **参考 openapi-servers 的例子**，写出一个自己的服务（RESTful 或 JSON-RPC），并提供一个 OpenAPI 或 MCP 描述文件。
3. 把这个服务注册到 open-webui → 这样，你的定制 MCP 智能体就能在 WebUI 中被调用。

------

## 3、如果你想定制自己的 MCP 智能体，如何使用这些项目

“定制 MCP 智能体”可以理解为：你想创建一个 agent，能够调用一些外部工具／数据源（这些工具／数据源你可能自己写或者已有），并且通过 UI／接口来与人交互。下面是一个可能的流程／建议：

------

### 3.1 步骤建议

1. **确定你的工具和数据源**

   首先列出你想智能体能用到的外部资源／能力（tools）：比如文件系统访问、读取某些数据库、访问某个 API、处理某些专用任务（比如翻译、汇总、监控系统状态、控制硬件等）。

2. **如果已有 MCP server 可用／或自己写 MCP server**

   - 如果你选用 MCP 模式（推荐，因为标准化），你可以寻找是否已有对应 MCP server 实现，或者自己写一个 MCP server 实现你这些工具。MCP server 的接口标准是公开的。
   - 如果没有，你可以用适合语言（Python, Node.js, etc.）实现一个 MCP server，它接受标准输入参数或 JSON 请求，暴露你的工具。

3. **用 mcpo 将你的 MCP server 暴露为 OpenAPI**

   - 安装 mcpo（通过 pip 或者其他方式）。[GitHub+1](https://github.com/open-webui/mcpo?utm_source=chatgpt.com)

   - 启动 mcpo，让它去运行你的 MCP server。示例命令大致是：

     ```
     mcpo --port <某端口> --api-key <可选> -- your_mcp_server_command --args…
     ```

     或者使用 uvx 等runtime加速启动。[GitHub+1](https://github.com/open-webui/mcpo?utm_source=chatgpt.com)

   - mcpo 会动态发现工具（MCP server 的工具），并为每个工具自动生成 HTTP/REST 接口＋OpenAPI 文档（如 `/docs`）。这样别人（或者 agent /前端）可以调用这些接口。[docs.openwebui.com+1](https://docs.openwebui.com/openapi-servers/mcp/?utm_source=chatgpt.com)

4. **整合到 Open WebUI**

   - 在 Open WebUI 的配置界面或者 “工具（Tools）”／插件（Plugins）／Admin settings 里，把你通过 mcpo 暴露的 OpenAPI 工具注册进来。这样 Open WebUI 中的 agent 可以看到这些工具／调用这些 API。[GitHub+2docs.openwebui.com+2](https://github.com/open-webui/open-webui?utm_source=chatgpt.com)
   - 如果工具需要权限或认证（很可能需要），mcpo 支持设置 api key 或其他鉴权方式。你要配置安全策略。[GitHub+1](https://github.com/open-webui/mcpo?utm_source=chatgpt.com)

5. **使用 openapi-servers 的范例或改造**

   - 如果你想快速试一个工具，而不想自己从头写，openapi-servers 中已有很多参考实现，比如文件系统工具、Git、天气、SQL chat 等。你可以直接部署这些，看它们是如何实现 OpenAPI 规范的。[GitHub](https://github.com/open-webui/openapi-servers)
   - 你也可以修改这些参考实现，把它们变成你自己的工具／服务；或者借鉴他们的模式（认证、安全、输入／输出规范等）来构造你的工具 server。

6. **前端 /智能体逻辑设计**

   - 在 Open WebUI 或者在你自定义 agent 环境中，你可能还需要设计什么 prompt +工具调用的策略。例如，当 user 提了一个问题，agent 判断是否需要外部工具／哪个工具合适 →call →组合返回。Open WebUI + mcpo +工具 API 的结合，就是让 agent 具备 “工具使用能力”。
   - 如果你有复杂的流程／workflow，可以考虑 pipelines 或者类似机制，将多个工具串联起来。

7. **测试与部署**

   - 本地测试：确保工具通过 mcpo 的 OpenAPI 接口能正确被调用，包括错误处理、安全性（不要让工具滥用、权限控制、输入验证等）。
   - 部署：当你要公开暴露（或云端部署）的时候，要加鉴权、限制访问、保证日志、安全、性能等。

------

### 3.2 示例：做一个简单的 MCP 智能体

假设你想做一个智能体，它可以：

- 访问一个数据库（比如 Postgres）来查数据
- 读取某些文件
- 调用一个翻译 API

流程可能如下：

1. 写一个 MCP server（或看是否已有 MCP server）实现这三个工具：数据库查询工具、文件读取工具、翻译工具。

2. 启动 mcpo，让它代理你的 MCP server：

   ```
   mcpo --port 9000 --api-key "mysuperkey" -- my_mcp_server_command --whatever_args
   ```

3. mcpo 会在 `http://localhost:9000/docs` 自动给出工具接口文档。

4. 在 Open WebUI 的 “工具／设置／添加工具” 中，添加这个 OpenAPI URL (`http://localhost:9000`) 和鉴权信息。

5. 在 Open WebUI 中的 agent 或者聊天过程中，当用户要查数据／翻译时，后台就可以调用这些工具，你的 agent 就能完成这些新能力。

------

### 3.3 注意事项／挑战

- **安全性**：工具暴露要谨慎，尤其是文件系统访问或数据库。要控制好权限、认证、输入验证。
- **一致性／接口定义**：MCP server 的 schema 要写好，以便 mcpo 能正确地自动生成 OpenAPI 接口，且前端使用者理解这些工具的输入／输出。
- **延迟与性能**：工具如果比较重（比如数据库查询耗时），或者 mcpo 在中间层增加延迟，需要考虑响应时间。
- **并发与稳定性**：部署到云／多人使用环境时，要注意并发安全、资源隔离、错误恢复。
- **用户体验**：在 UI 或者智能体交互中，要考虑什么时候调用工具、怎么告诉用户工具在做什么、错误如何回报等。

------

# 五、天气Demo

使用天气Demo只是熟悉webui使用流程和验证webui能够LLM调用个性化http服务。这里LLM使用[Tools](https://docs.openwebui.com/features/plugin/tools/)调用API有两种方式：

>🧠 **工具使用模式选择：默认模式 vs 原生模式**
>
>当您为模型启用工具功能后，Open WebUI 提供了两种不同的方式让大语言模型在对话中使用这些工具。
>
>您可以通过以下两种模式来选择模型的工具调用方式：
>
>🟡 **默认模式（基于提示词）**
>🟢 **原生模式（内置函数调用）**
>
>具体说明如下：
>
>------
>
>🟡 **默认模式（基于提示词的工具触发）**
>此为 Open WebUI 的默认设置。
>
>在此模式下，您的大语言模型无需原生支持函数调用。取而代之的是，我们通过智能工具选择提示词模板来引导模型选择并使用工具。
>
>✅ **优势**：可与几乎任何模型兼容
>✅ **优势**：是为基础模型或本地模型解锁工具功能的绝佳方式
>❗ **注意**：在工具链式调用方面，不如原生模式可靠或灵活
>
>------
>
>🟢 **原生模式（内置函数调用）**
>如果您的模型确实支持“原生”函数调用（例如 GPT-4o 或 GPT-3.5-turbo-1106），您可以使用这种强大的模式，让大语言模型在单条聊天消息的处理过程中实时决定何时以及如何调用多个工具。
>
>✅ **优势**：响应迅速、精准，并能在一个回复中链式调用多个工具
>✅ **优势**：提供最自然、最先进的体验
>❗ **注意**：要求模型必须实际支持原生函数调用功能

实验证明，本机的Qwen2.5-1.5b是不仅有Function Calls功能，而服务器上都可以，应该是模型是很大。

并且Tools在webui中分为工具和外部工具，工具可以看成为webui内嵌python code执行调用。而外部工具则是满足openapi接口协议的服务。

## 5.1 外部工具

使用openapi-servers中的weather demo。两个问题分别表示启动和关闭工具后的效果。

![image-20250925145413790](%E8%83%BD%E6%BA%90%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%B9%B3%E5%8F%B0%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF%E5%8F%8A%E5%AE%9E%E7%8E%B0.assets/image-20250925145413790.png)

![image-20250925145236451](%E8%83%BD%E6%BA%90%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%B9%B3%E5%8F%B0%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF%E5%8F%8A%E5%AE%9E%E7%8E%B0.assets/image-20250925145236451.png)

提示词：

```
你是一个天气助手。所有天气信息必须通过 WebUI 已添加的外部工具获取，不能自行编造数据。  

工具信息：
- 外部天气服务 URL: http://localhost:9002/forecast
- 输入参数: latitude（纬度，float）、longitude（经度，float）
- API 返回的 JSON 数据结构遵循 WeatherForecastOutput 模型：
   - current: 当前天气
       - temperature_2m: 温度 (°C)
       - wind_speed_10m: 风速 (m/s)
       - time: 时间
   - hourly: 每小时数据
       - temperature_2m, relative_humidity_2m, wind_speed_10m
- 解析 JSON 后，生成自然语言回答，包含：
   - 城市名
   - 当前温度
   - 体感温度（如果有）
   - 相对湿度
   - 风速
   - 天气描述（可以根据温度、湿度、云量等简单生成）
   - 数据时间

规则：
1. 当用户问“现在”“实时”“当前”的天气时，使用外部工具查询该城市的天气。  
2. 用户可能提供城市名或经纬度。如果提供城市名，先通过 geocoding 将城市转换为纬度和经度。  
3. 不要在模型内部生成天气数据，必须通过调用外部工具获取结果。  
4. 回复时直接展示天气信息（温度、体感温度、湿度、风速、天气描述等），保持自然对话风格。  
5. 如果用户没有提供城市或经纬度，要求用户先提供。  

示例：
用户：现在上海的天气怎么样？  
模型：上海当前天气：温度 26°C，体感温度 27°C，相对湿度 78%，风速 5 m/s，天气：多云， 时间：数据时间。

用户：武汉实时天气？  
模型：武汉当前天气：温度 30°C，体感温度 32°C，相对湿度 80%，风速 3 m/s，天气：晴朗， 时间：数据时间。
```

> 小模型不支持Native Function Calls，写prompt是个麻烦事，而且复杂的返回结果也解析不了。

## 5.2 工具

参照[文档](https://docs.openwebui.com/features/plugin/tools/)导入的Tools，代码为：

```python
"""
title: Keyless Weather
author: spyci
author_url: https://github.com/open-webui
funding_url: https://github.com/open-webui
version: 0.1.1
"""

import os
import requests
import urllib.parse
import datetime


def get_city_info(city: str):
    url = f"https://geocoding-api.open-meteo.com/v1/search?name={urllib.parse.quote(city)}&count=1&language=en&format=json"
    response = requests.get(url)

    if response.status_code == 200:
        try:
            data = response.json()["results"][0]
            return data["latitude"], data["longitude"], data["timezone"]
        except (KeyError, IndexError):
            print(f"City '{city}' not found")
            return None
    else:
        print(f"Failed to retrieve data for city '{city}': {response.status_code}")
        return None


wmo_weather_codes = {
    "0": "Clear sky",
    "1": "Mainly clear, partly cloudy, and overcast",
    "2": "Mainly clear, partly cloudy, and overcast",
    "3": "Mainly clear, partly cloudy, and overcast",
    "45": "Fog and depositing rime fog",
    "48": "Fog and depositing rime fog",
    "51": "Drizzle: Light, moderate, and dense intensity",
    "53": "Drizzle: Light, moderate, and dense intensity",
    "55": "Drizzle: Light, moderate, and dense intensity",
    "56": "Freezing Drizzle: Light and dense intensity",
    "57": "Freezing Drizzle: Light and dense intensity",
    "61": "Rain: Slight, moderate and heavy intensity",
    "63": "Rain: Slight, moderate and heavy intensity",
    "65": "Rain: Slight, moderate and heavy intensity",
    "66": "Freezing Rain: Light and heavy intensity",
    "67": "Freezing Rain: Light and heavy intensity",
    "71": "Snow fall: Slight, moderate, and heavy intensity",
    "73": "Snow fall: Slight, moderate, and heavy intensity",
    "75": "Snow fall: Slight, moderate, and heavy intensity",
    "77": "Snow grains",
    "80": "Rain showers: Slight, moderate, and violent",
    "81": "Rain showers: Slight, moderate, and violent",
    "82": "Rain showers: Slight, moderate, and violent",
    "85": "Snow showers slight and heavy",
    "86": "Snow showers slight and heavy",
    "95": "Thunderstorm: Slight or moderate",
    "96": "Thunderstorm with slight and heavy hail",
    "99": "Thunderstorm with slight and heavy hail",
}


def fetch_weather_data(base_url, params):
    try:
        response = requests.get(base_url, params=params)
        response.raise_for_status()
        data = response.json()
        if "error" in data:
            return f"Error fetching weather data: {data['message']}"
        return data
    except requests.RequestException as e:
        return f"Error fetching weather data: {str(e)}"


def format_date(date_str, date_format="%Y-%m-%dT%H:%M", output_format="%I:%M %p"):
    dt = datetime.datetime.strptime(date_str, date_format)
    return dt.strftime(output_format)


class Tools:
    def __init__(self):
        self.citation = True
        pass

    def get_future_weather_week(self, city: str) -> str:
        """
        Get the weather for the next week for a given city.
        :param city: The name of the city to get the weather for.
        :return: The current weather information or an error message.
        """
        if not city:
            return """The location has not been defined by the user, so weather cannot be determined."""

        city_info = get_city_info(city)
        if not city_info:
            return """Error fetching weather data"""

        lat, lng, tmzone = city_info
        print(f"Latitude: {lat}, Longitude: {lng}, Timezone: {tmzone}")

        base_url = "https://api.open-meteo.com/v1/forecast"
        params = {
            "latitude": lat,
            "longitude": lng,
            "daily": [
                "weather_code",
                "temperature_2m_max",
                "temperature_2m_min",
                "uv_index_max",
                "precipitation_probability_max",
                "wind_speed_10m_max",
            ],
            "current": "temperature_2m",
            "timezone": tmzone,
            "temperature_unit": "fahrenheit",
            "wind_speed_unit": "mph",
            "precipitation_unit": "inch",
            "forecast_days": 7,
        }

        data = fetch_weather_data(base_url, params)
        if isinstance(data, str):
            return data

        formatted_timestamp = format_date(data["current"]["time"])
        data["daily"]["time"][0] += " (Today)"

        mapped_data = {
            date: {
                "weather_description": wmo_weather_codes[
                    str(data["daily"]["weather_code"][i])
                ],
                "temperature_max_min": f'{data["daily"]["temperature_2m_max"][i]} {data["daily_units"]["temperature_2m_max"]} / {data["daily"]["temperature_2m_min"][i]} {data["daily_units"]["temperature_2m_min"]}',
                "uv_index_max": f'{data["daily"]["uv_index_max"][i]} {data["daily_units"]["uv_index_max"]}',
                "precipitation_probability_max": f'{data["daily"]["precipitation_probability_max"][i]} {data["daily_units"]["precipitation_probability_max"]}',
                "max_wind_speed": f'{data["daily"]["wind_speed_10m_max"][i]} {data["daily_units"]["wind_speed_10m_max"]}',
            }
            for i, date in enumerate(data["daily"]["time"])
        }

        return f"""
Give a weather description for the next week, include the time of the data ({formatted_timestamp} {data['timezone_abbreviation']} in {city}):
Show a standard table layout of each of these days: {mapped_data}
Include a one sentence summary of the week at the end."""

    def get_current_weather(self, city: str) -> str:
        """
        Get the current weather for a given city.
        :param city: The name of the city to get the weather for.
        :return: The current weather information or an error message.
        """
        if not city:
            return """The location has not been defined by the user, so weather cannot be determined."""

        city_info = get_city_info(city)
        if not city_info:
            return """Error fetching weather data"""

        lat, lng, tmzone = city_info
        print(f"Latitude: {lat}, Longitude: {lng}, Timezone: {tmzone}")

        base_url = "https://api.open-meteo.com/v1/forecast"
        params = {
            "latitude": lat,
            "longitude": lng,
            "current": [
                "temperature_2m",
                "relative_humidity_2m",
                "apparent_temperature",
                "wind_speed_10m",
                "weather_code",
            ],
            "timezone": tmzone,
            "temperature_unit": "fahrenheit",
            "wind_speed_unit": "mph",
            "precipitation_unit": "inch",
            "forecast_days": 1,
        }

        data = fetch_weather_data(base_url, params)
        if isinstance(data, str):
            return data

        formatted_timestamp = format_date(data["current"]["time"])
        data["current"]["weather_code"] = wmo_weather_codes[
            str(data["current"]["weather_code"])
        ]
        formatted_data = ", ".join(
            [
                f"{x} ({data['current_units'][x]}) = '{data['current'][x]}'"
                for x in data["current"].keys()
            ]
        ).replace("weather_code", "weather_description")

        return f"""
Give a weather description, include the time of the data ({formatted_timestamp} {data['timezone_abbreviation']} in {city}):
Include this data: [{formatted_data}]
Ensure you mention the real temperature and the "feels like"(apparent_temperature) temperature. Convert all numbers to integers.
Keep response as brief as possible."""
```

也分别展现启动和关闭的效果，其中汉字地名是无法识别的。

![image-20250925145802871](%E8%83%BD%E6%BA%90%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%B9%B3%E5%8F%B0%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF%E5%8F%8A%E5%AE%9E%E7%8E%B0.assets/image-20250925145802871.png)

也必须靠强提示词完成调用，不然就会产生幻觉，瞎编乱造。

![image-20250925150243397](%E8%83%BD%E6%BA%90%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%B9%B3%E5%8F%B0%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF%E5%8F%8A%E5%AE%9E%E7%8E%B0.assets/image-20250925150243397.png)

有问题的提示词如下：

```
你是一个天气助手，可以调用两个工具来回答用户的天气相关问题。

工具：
1. get_current_weather(city: str) → 查询某个城市的实时天气（包含体感温度、湿度、风速等信息）
2. get_future_weather_week(city: str) → 查询某个城市未来 7 天的天气预报（包含最高/最低温度、降雨概率、紫外线指数、风速等信息）

规则：
1. 当用户提问包含“现在”、“实时”、“当前”等关键词时，调用 get_current_weather。
2. 当用户提问包含“明天”、“未来”、“下周”、“一周”、“7天”等关键词时，调用 get_future_weather_week。
3. 如果用户没有指定城市，要求用户补充城市信息。
4. 回复时不要展示调用过程，只展示工具返回的最终结果，保持自然的对话风格。
5. 确保回答中包含城市名和日期，避免模糊回答。
```

#  六、智能问数

## 6.1 思路和本地demo

* 公式查找

  要想精确查找，就不能使用直接使用向量库查询，但是可以通过向量库思想近似值查找TopN然后返回给用户选择，直到选择或者用户输入能够精确匹配具体公式名称为止。

* 代码

  ```
  import pandas as pd
  from fastapi import FastAPI, Query
  from fastapi.middleware.cors import CORSMiddleware
  from fastapi.responses import JSONResponse
  from rapidfuzz import process, fuzz
  from uuid import uuid4
  import json
  
  app = FastAPI(title="Formula Query API - Unified Multi-step")
  
  app.add_middleware(
      CORSMiddleware,
      allow_origins=["*"],
      allow_credentials=True,
      allow_methods=["*"],
      allow_headers=["*"],
  )
  
  CSV_PATH = "FORMULAINFO_202503121558.csv"
  df = None
  formulanames = None
  sessions = {}  # 多轮会话缓存
  
  @app.on_event("startup")
  def load_csv():
      global df, formulanames
      try:
          try:
              df = pd.read_csv(CSV_PATH, dtype=str, quoting=3, engine="python", on_bad_lines="skip")
          except Exception:
              df = pd.read_csv(CSV_PATH, sep="\t", dtype=str, quoting=3, engine="python", on_bad_lines="skip")
          df.columns = [c.strip().replace('"','') for c in df.columns]
          required = ["FORMULAID", "FORMULANAME"]
          for col in required:
              if col not in df.columns:
                  raise RuntimeError(f"CSV缺少列: {col}, 实际列名: {list(df.columns)}")
          df = df[required]
          df.fillna("", inplace=True)
          formulanames = df["FORMULANAME"].tolist()
          print(f"✅ Loaded {len(df)} formulas")
      except Exception as e:
          raise RuntimeError(f"Failed to load CSV: {e}")
  
  def generate_candidates(name: str, topn: int = 5):
      results = process.extract(name, formulanames, scorer=fuzz.WRatio, limit=topn)
      candidates = []
      for match_name, score, idx in results:
          if idx >= len(df):
              continue
          row = df.iloc[idx]
          candidates.append({
              "FORMULAID": row["FORMULAID"],
              "FORMULANAME": row["FORMULANAME"],
              "score": score
          })
      return candidates
  
  @app.get("/formula_query")
  def formula_query(
      user_input: str = Query(..., description="用户输入，可以是关键词或选择编号"),
      session_id: str = Query(None, description="多轮会话 session_id"),
      topn: int = Query(5, description="候选条数")
  ):
      user_input = user_input.strip()
  
      # 用户选择编号
      if session_id and session_id in sessions and user_input.isdigit():
          candidates = sessions[session_id]["candidates"]
          choice = int(user_input)
          if 1 <= choice <= len(candidates):
              selected = candidates[choice-1]
              del sessions[session_id]
              return JSONResponse(content=json.loads(json.dumps({
                  "done": True,
                  "message": f"你选择的公式是 **{selected['FORMULAID']}**，名称是 {selected['FORMULANAME']}，相似度 {selected['score']}",
                  "selected": selected
              }, ensure_ascii=False)))
          else:
              return JSONResponse(content=json.loads(json.dumps({
                  "done": False,
                  "message": f"选择编号 {choice} 超出范围，请重新输入编号或新的关键词。"
              }, ensure_ascii=False)))
  
      # 精确匹配
      exact = df[df["FORMULANAME"].str.strip() == user_input]
      if not exact.empty:
          exact_matches = exact[["FORMULAID","FORMULANAME"]].to_dict(orient="records")
          return JSONResponse(content=json.loads(json.dumps({
              "done": True,
              "session_id": None,
              "message": f"我找到精确结果，公式是 **{exact_matches[0]['FORMULAID']}**，名称是 {exact_matches[0]['FORMULANAME']}",
              "exact_matches": exact_matches
          }, ensure_ascii=False)))
  
      # 模糊匹配生成候选
      candidates = generate_candidates(user_input, topn)
      if not candidates:
          return JSONResponse(content=json.loads(json.dumps({
              "done": False,
              "session_id": None,
              "message": "未找到匹配结果，请补充更多关键词。"
          }, ensure_ascii=False)))
  
      new_session_id = str(uuid4())
      sessions[new_session_id] = {"candidates": candidates, "last_query": user_input}
  
      msg_lines = ["我找到多个候选，请选择编号，或输入新的关键词："]
      for i, c in enumerate(candidates, start=1):
          msg_lines.append(f"{i}) {c['FORMULANAME']} (score {c['score']})")
  
      return JSONResponse(content=json.loads(json.dumps({
          "done": False,
          "session_id": new_session_id,
          "message": "\n".join(msg_lines),
          "candidates": candidates
      }, ensure_ascii=False)))
  ```

* 提示词

  ```
  你是公式查询助手。所有公式信息必须通过 WebUI 已添加的外部工具获取，不能自行编造数据。
  
  工具信息：
  - 统一查询 URL: http://localhost:9003/formula_query
    - user_input: 用户输入，可以是关键词或选择编号
    - session_id: 可选，多轮会话 ID
    - topn: 可选，候选条数
  
  规则：
  1. 用户任何的信息，都按照你的理解截取公式名称并传给API参数user_input，比如用户说：帮我查移动电话损失率，或者移动电话损失率，你都需要传入移动电话损失率
  2. 如果用户在候选列表后输入数字，把数字内容也传给API参数user_input，找到候选列表的session_id并传入API参数session_id，这表示用户在对上一个对话的候选列表进行选择
  2. 如果 API 返回 exact_matches 非空或者 done = TRUE：
     - 表示找到唯一精确公式
     - 直接输出：我找到精确结果，公式是 **FORMULAID**，名称是 FORMULANAME
     - 可将FORMULANAME左右两边“剔除，再将ASCCI码转移成中文
  3. 如果 exact_matches 为空，但 candidates 非空：
     - 表示没有找到完全一致的公式，但找到了相似候选列表
     - 逐条输出候选，格式：编号) FORMULANAME (score 分数)
     - 可将FORMULANAME左右两边“剔除，再将ASCCI码转移成中文
     - 提示用户“请选择编号，或输入新的关键词”
     - **不要总结为‘多个版本’或‘同类公式’，必须原样输出候选列表的所有内容**
     - **不要自己决定选择哪个候选**
  4. 如果 exact_matches 和 candidates 都为空：
     - 输出“未找到匹配结果，请补充更多关键词”
  5. 如果无法确定结果，请直接返回message内容
  6. 回复使用自然中文，不显示 JSON
  7. 示例只是参考，要完全按照API返回作答或调用外部工具
  
  **禁止**
  绝对不要自己加工、合并或改写结果
  
  示例：
  
  用户：查湛江钢铁回用水损失率实绩累计值
  模型：调用 /formula_query?user_input=湛江钢铁回用水损失率实绩累计值
  API 返回 {
    "done": true,
    "session_id": null,
    "message": "我找到精确结果，公式是 **NYZHZBHYSH.IXRL.SUMVALUE**，名称是 湛江钢铁回用水损失率实绩累计值",
    "exact_matches": [
      {
        "FORMULAID": "NYZHZBHYSH.IXRL.SUMVALUE",
        "FORMULANAME": "湛江钢铁回用水损失率实绩累计值"
      }
    ]
  }
  模型：我找到精确结果，公式是 **NYZHZBHYSH.IXRL.SUMVALUE**，名称是 湛江钢铁回用水损失率实绩累计值
  
  用户：查湛江钢铁回用水损失率
  模型：调用 /formula_query?user_input=湛江钢铁回用水损失率
  API 返回 {
    "done": false,
    "session_id": "f29dc381-f271-429e-8114-76ea512ee220",
    "message": "我找到多个候选，请选择编号，或输入新的关键词：\n1) 湛江钢铁回用水损失率实绩报出值 (score 90.0)\n2) 湛江钢铁回用水损失率实绩累计值 (score 90.0)\n3) 湛江钢铁回用水损失率计划累计值 (score 90.0)\n4) 湛江钢铁回用水损失率计划报出值 (score 90.0)\n5) 湛江钢铁回用水损耗量实绩报出值 (score 80.0)",
    "candidates": [
      {
        "FORMULAID": "NYZHZBHYSH.IXRL",
        "FORMULANAME": "湛江钢铁回用水损失率实绩报出值",
        "score": 90
      },
      {
        "FORMULAID": "NYZHZBHYSH.IXRL.SUMVALUE",
        "FORMULANAME": "湛江钢铁回用水损失率实绩累计值",
        "score": 90
      },
      {
        "FORMULAID": "NYZHZBHYSH.IXPL.SUMVALUE",
        "FORMULANAME": "湛江钢铁回用水损失率计划累计值",
        "score": 90
      },
      {
        "FORMULAID": "NYZHZBHYSH.IXPL",
        "FORMULANAME": "湛江钢铁回用水损失率计划报出值",
        "score": 90
      },
      {
        "FORMULAID": "ZG0000Z2055.EIRL",
        "FORMULANAME": "湛江钢铁回用水损耗量实绩报出值",
        "score": 80
      }
    ]
  }
  模型：我没有找到完全一致的公式，但找到了以下相似结果，请选择编号，或输入新的关键词：
  1) 湛江钢铁回用水损失率实绩报出值 (score 90)
  2) 湛江钢铁回用水损失率实绩累计值 (score 90)
  3) 湛江钢铁回用水损失率计划累计值 (score 90)
  4) 湛江钢铁回用水损失率计划报出值 (score 90)
  5) 湛江钢铁回用水损耗量实绩报出值 (score 80)
  
  用户：4
  模型：调用 /formula_query?user_input=4&session_id=<session_id>
  API 返回 {
    "done": true,
    "message": "你选择的公式是 **NYZHZBHYSH.IXPL**，名称是 湛江钢铁回用水损失率计划报出值，相似度 90.0",
    "selected": {
      "FORMULAID": "NYZHZBHYSH.IXPL",
      "FORMULANAME": "湛江钢铁回用水损失率计划报出值",
      "score": 90
    }
  }
  模型：你选择的公式是 **NYZHZBHYSH.IXPL**，名称是 湛江钢铁回用水损失率计划报出值
  ```

  实际效果：

  ![image-20250926123626167](%E8%83%BD%E6%BA%90%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%B9%B3%E5%8F%B0%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF%E5%8F%8A%E5%AE%9E%E7%8E%B0.assets/image-20250926123626167.png)

  ![image-20250926123721430](%E8%83%BD%E6%BA%90%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%B9%B3%E5%8F%B0%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF%E5%8F%8A%E5%AE%9E%E7%8E%B0.assets/image-20250926123721430.png)

> 在验证接口没有任何问题的情况下，当前效果其实是调试prompt接近一天的效果。经过反复测试还是发现几点问题：
>
> * Prompt效果受LLM影响很大，也就是说不同的LLM理解Prompt的能力是不一样的，本地使用Qwen2.5:1.5b。
> * 这个版本的demo，除了ascci转义没有实现，已经可以基本理解用户问答中的流程问题。
> * 只有一点问题，就是他并没有按照prompt定义的传入session_id，而是通过上下文，确定了选择5所以指向的完整公式名称。路线错了但是结果是正确的，就看LLM怎么理解了。
> * 这样来看session_id并不是必要的，筛选功能交给LLM或者前端，后端逻辑更加简单。**智能问数需要改良，然后再部署到服务器，用较大模型再试试效果**

## 6.2 LLM对Prompt的理解能力

### 问题1

> 不同的LLM对prompt的理解或者执行能力有区别，token少的LLM理解能力就弱一些？

你问的是一个很关键但容易被误解的点：**LLM 的理解能力与模型本身的架构、参数量和训练方式有关，而不仅仅是“token 数量”**。我们可以拆开来看：

------

1️⃣ Prompt 理解能力与 LLM 的关系

1. **模型大小（参数量）**
   - 大模型（如 GPT-4、LLaMA 3 大型版本）通常能捕捉更复杂的语义关系，对 prompt 的理解更准确。
   - 小模型（如 GPT-3.5 小版本或参数量更小的开源模型）对复杂 prompt 的理解会相对弱，容易漏掉细节或误解多步骤指令。
2. **训练数据与质量**
   - 如果一个模型在训练中接触过更多样化、结构化或多步骤任务，它对 prompt 的理解会更强。
   - 即便模型大，如果训练数据偏单一，也可能对某些 prompt 理解不好。
3. **上下文窗口大小（Context Window）**
   - 你提到的 “token 少” 可能是指模型能处理的 **上下文长度有限**。
   - 如果 prompt 很长或需要记忆前文细节，token 限制短的模型可能无法看到完整内容，从而表现出“理解能力弱”。
   - 但如果 prompt 很短、信息集中，token 少的模型也能做得不错。
4. **推理能力与多步骤任务**
   - 大模型通常有更好的链式推理能力，能在 prompt 中推导、总结或执行多步骤指令。
   - 小模型在多步骤任务中容易出现“遗漏步骤”、“逻辑跳跃”或“胡编乱造”的情况。

------

2️⃣ 结论

- **Token 数少 ≠ 理解能力弱**，但 token 限制确实会影响长 prompt 的处理效果。
- 真正影响理解能力的是 **模型参数量、训练数据质量、推理能力和上下文窗口大小**。
- 实践中，你会发现同一条 prompt：
  - 大模型可以理解复杂指令并生成高质量结果
  - 小模型可能只抓到部分关键信息，或者逻辑不够完整

### 问题2

> 想openwebui工具中添加一个外部fastapi接口作为tools，为什么有些大模型不需要提示词就会自动调用，这个是不是和openapi.json有详细的文档说明有关？有些小模型不加提示词就不会主动去调用他tools，这也是否和Navite Function Calls有关，某些大模型原生的函数调用的能力是怎么获取？完全靠训练吗？

你这个问题非常核心，涉及 LLM 与工具（tools / API）交互机制的差异，尤其是 **OpenWebUI** 里的工具系统、模型能力和 OpenAPI 的关系。我们可以拆开来说：

------

1️⃣ 为什么有些大模型会自动调用工具

1. **原生函数调用能力（Native Function Calls）**
   - GPT-4、GPT-4-turbo 系列（OpenAI 提供的最新大模型）在训练时就加入了**函数调用能力**：
     - 模型可以识别对外部工具调用的“意图”
     - 自动生成符合工具参数的 JSON 调用
     - 这种能力**不依赖额外提示词**，因为模型内部学习到了“看见问题 → 判断需要调用哪个工具 → 构造调用参数”这种模式。
   - 这是通过 **训练数据 + RLHF（人类反馈强化训练） + 专门函数调用数据**实现的。
2. **OpenAPI / tools 描述**
   - 对于自动调用，模型需要知道：
     - 工具的名字、功能
     - 输入参数类型、格式
     - 返回结果类型
   - OpenAPI 文档提供了这些结构化信息，模型可以根据 JSON Schema 或函数签名生成调用请求。
   - 对于 GPT 系列，这类信息可以直接通过模型的“函数调用接口”传给模型，它就知道怎么用，无需额外 prompt。

------

2️⃣ 为什么小模型不自动调用工具

1. **缺少训练阶段的函数调用能力**

   - 小模型（如 LLaMA、MPT 轻量版）没有原生训练去理解函数调用或 API 调用。

   - 即使你在 OpenWebUI 中注册了 tools，也**不会自己发起调用**，除非你在 prompt 里明确指示：

     ```
     调用 toolX，参数 a=1, b=2
     ```

2. **提示词（Prompt）驱动**

   - 对小模型，你通常要用 **显式指令**告诉它：
     - “请使用 tools 里的天气接口查询 X 城市的天气”
   - 模型才能生成对应的调用 JSON 或文本指令去触发工具。

3. **OpenAPI 描述的作用有限**

   - 小模型没有原生函数理解能力，它只是把 OpenAPI 描述当作**普通文本**。
   - 只有像 GPT-4-turbo 这种原生支持 function call 的大模型，才会把 OpenAPI schema 当作可执行指令。

------

3️⃣ Native Function Calls 的获取方式

1. **训练 + 指令微调**
   - 模型在训练中看到大量“问题 → 工具调用 → 得到结果 → 生成答案”的模式
   - 通过 RLHF 或 supervised fine-tuning 强化了这种能力
2. **接口协议 + Schema**
   - OpenAPI / JSON Schema 提供了函数名、参数名、类型、描述
   - 模型在推理时可以直接使用 schema 生成调用请求
3. **不是靠硬编码**
   - 大模型并不“知道”某个工具的实现，它是通过模式学习：看到问题、理解需要外部数据、使用函数签名生成调用请求

------

✅ 总结

| 特性             | 大模型（如 GPT-4-turbo）           | 小模型（如轻量 LLaMA）     |
| ---------------- | ---------------------------------- | -------------------------- |
| 原生函数调用能力 | 有，能自动调用 tools               | 无，需要明确 prompt        |
| 是否依赖 OpenAPI | 是，帮助模型理解参数类型和调用方式 | 仅作文本参考，不会自动调用 |
| 是否需要提示词   | 不一定，需要时可优化               | 必须明确提示词             |
| 原理             | 训练 + schema + RLHF               | 只能按提示词执行           |

## 6.3 公式查询优化

* 去掉传入编号和session_id，让前端或LLM自己去匹配精确的文本名称。
* 加入api描述，让支持Native Function Calls不用prompt就能使用。
* 调整demo中的prompt，精简流程，精准完成既定功能。

FastAPI代码现在如下：

```
import pandas as pd
from fastapi import FastAPI, Query
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
from rapidfuzz import process, fuzz
from uuid import uuid4

app = FastAPI(title="Formula Query API - Unified Multi-step")

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

CSV_PATH = "FORMULAINFO_202503121558.csv"
df = None
formulanames = None

@app.on_event("startup")
def load_csv():
    global df, formulanames
    try:
        try:
            df = pd.read_csv(CSV_PATH, dtype=str, quoting=3, engine="python", on_bad_lines="skip")
        except Exception:
            df = pd.read_csv(CSV_PATH, sep="\t", dtype=str, quoting=3, engine="python", on_bad_lines="skip")
        # 去掉列名两端空格和引号
        df.columns = [c.strip().replace('"','') for c in df.columns]
        required = ["FORMULAID", "FORMULANAME"]
        for col in required:
            if col not in df.columns:
                raise RuntimeError(f"CSV缺少列: {col}, 实际列名: {list(df.columns)}")
        df = df[required]
        # 去掉空值，多余空格和开头结尾双引号
        df["FORMULANAME"] = df["FORMULANAME"].fillna("").str.strip().str.strip('"')
        df["FORMULAID"] = df["FORMULAID"].fillna("").str.strip()
        formulanames = df["FORMULANAME"].tolist()
        print(f"✅ Loaded {len(df)} formulas")
    except Exception as e:
        raise RuntimeError(f"Failed to load CSV: {e}")

def generate_candidates(name: str, topn: int = 5):
    results = process.extract(name, formulanames, scorer=fuzz.WRatio, limit=topn)
    candidates = []
    for idx, (match_name, score, _) in enumerate(results, start=1):
        if _ >= len(df):
            continue
        row = df.iloc[_]
        candidates.append({
            "number": idx,  # 前端用编号选择
            "FORMULAID": row["FORMULAID"],
            "FORMULANAME": row["FORMULANAME"],  # 已经清理过引号
            "score": score
        })
    return candidates

@app.get("/formula_query")
def formula_query(
    user_input: str = Query(..., description="User input: keyword or exact formula name"),
    topn: int = Query(5, description="Number of candidates to return for fuzzy match")
):
    user_input = user_input.strip().strip('"')  # 去掉用户输入可能的双引号

    # 精确匹配
    exact = df[df["FORMULANAME"] == user_input]
    if not exact.empty:
        exact_matches = exact[["FORMULAID","FORMULANAME"]].to_dict(orient="records")
        return JSONResponse(content={
            "done": True,
            "message": f"Exact match found: formula **{exact_matches[0]['FORMULAID']}**, name {exact_matches[0]['FORMULANAME']}",
            "exact_matches": exact_matches
        })

    # 模糊匹配
    candidates = generate_candidates(user_input, topn)
    if not candidates:
        return JSONResponse(content={
            "done": False,
            "message": "No matches found, please provide more keywords.",
            "candidates": []
        })

    msg_lines = ["Multiple candidates found, choose by number:"]
    for c in candidates:
        msg_lines.append(f"{c['number']}) {c['FORMULANAME']} (score {c['score']})")

    return JSONResponse(content={
        "done": False,
        "message": "\n".join(msg_lines),
        "candidates": candidates
    })

@app.get("/openapi_description")
def openapi_description():
    schema = {
        "name": "Formula Query API",
        "description": (
            "This API allows querying formulas from a preloaded CSV database. "
            "Users can input a keyword or exact formula name. "
            "The response contains candidates with numbers, formula IDs, names, and similarity scores, "
            "so the frontend can handle selection directly."
        ),
        "endpoints": {
            "/formula_query": {
                "method": "GET",
                "parameters": {
                    "user_input": "string, required, keyword or exact name",
                    "topn": "integer, optional, number of candidates to return for fuzzy match"
                },
                "returns": {
                    "done": "boolean, whether a final selection is made",
                    "message": "string, human-readable message listing candidates with numbers",
                    "candidates": "array of candidate formulas, each with number, FORMULAID, FORMULANAME, score",
                    "exact_matches": "array of exact matches if found"
                }
            }
        }
    }
    return JSONResponse(content=schema)
```

Prompt:

```
你是公式查询助手。所有公式信息必须通过 WebUI 已添加的外部工具获取，不能自行编造数据。

工具信息：
- 统一查询 URL: http://localhost:9003/formula_query
  - user_input: 用户输入，可以是关键词或选择编号对应的 FORMULANAME
  - topn: 可选，候选条数

操作规则：

1. 用户输入非数字内容时：
   - 从用户语句中提取公式关键词或完整名称作为 user_input 调用 API。

2. 用户输入纯数字时：
   - 情况 A：上下文最近一次 API 返回的 candidates 数组存在  
     - 查找数字对应的 number，获取对应的 FORMULANAME  
     - 使用该 FORMULANAME 调用 API  
     - 禁止直接使用数字调用 API  
   - 情况 B：没有候选列表（第一次输入数字或上下文丢失）  
     - 将数字本身当作关键词传给 API  
     - 在输出中提示用户：数字被当作关键词处理，请输入更具体的公式名称以获得精确匹配

3. API 返回处理：
   - 如果 `exact_matches` 非空或 `done = true`：
     - 输出：我找到精确结果，公式是 **FORMULAID**，名称是 FORMULANAME  
     - FORMULANAME 必须用中文显示（保持原始中文，不使用 ASCII 转义）
   - 如果 `exact_matches` 为空，且 `candidates` 非空：
     - 输出：我没有找到完全一致的公式，但找到了以下相似结果，请选择编号，或输入新的关键词：  
       按编号顺序逐条列出每个候选：  
       编号) FORMULANAME (score 分数)  
     - FORMULANAME 必须用中文显示（原始中文）  
     - **禁止自己决定哪个候选是精确匹配**
   - 如果 `exact_matches` 为空，且 `candidates` 为空：
     - 输出：“未找到匹配结果，请补充更多关键词”

4. 始终返回自然中文，不显示 JSON  
5. 中文必须保持原始 Unicode，不要 ASCII 转义  
6. 如果无法确定结果，直接返回 API 的 message 内容

示例流程：

用户：查湛江钢铁回用水损失率
模型：调用 /formula_query?user_input=湛江钢铁回用水损失率
API 返回 {
  "done": false,
  "message": "Multiple candidates found, choose by number:\n1) 湛江钢铁回用水损失率实绩报出值 (score 90.0)\n2) 湛江钢铁回用水损失率实绩累计值 (score 90.0)",
  "candidates": [
    {"number":1,"FORMULAID":"NYZHZBHYSH.IXRL","FORMULANAME":"湛江钢铁回用水损失率实绩报出值","score":90},
    {"number":2,"FORMULAID":"NYZHZBHYSH.IXRL.SUMVALUE","FORMULANAME":"湛江钢铁回用水损失率实绩累计值","score":90}
  ]
}
模型：我没有找到完全一致的公式，但找到了以下相似结果，请选择编号，或输入新的关键词：
1) 湛江钢铁回用水损失率实绩报出值 (score 90)
2) 湛江钢铁回用水损失率实绩累计值 (score 90)

用户：2
模型：用户输入 2，从最近候选列表中找到 number=2 的 FORMULANAME，即“湛江钢铁回用水损失率实绩累计值”，调用 /formula_query?user_input=湛江钢铁回用水损失率实绩累计值
API 返回 {
  "done": true,
  "message": "Exact match found: formula **NYZHZBHYSH.IXRL.SUMVALUE**, name 湛江钢铁回用水损失率实绩累计值",
  "exact_matches":[{"FORMULAID":"NYZHZBHYSH.IXRL.SUMVALUE","FORMULANAME":"湛江钢铁回用水损失率实绩累计值"}]
}
模型：你选择的公式是 **NYZHZBHYSH.IXRL.SUMVALUE**，名称是 湛江钢铁回用水损失率实绩累计值

用户：第一次输入数字 4，没有候选列表
模型：将数字 4 当作关键词调用 API，并提示用户：数字被当作关键词处理，请输入更具体的公式名称以获得精确匹配

```

> 这prompt在Qwen2.5:1.5b下实际效果还没有api改版前的prompt效果好，就相当奇怪。准备去理解能力强一点的LLM下去试。

## 6.4 **公式查询Prompt流程编排**

![image-20250926144507774](%E8%83%BD%E6%BA%90%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%B9%B3%E5%8F%B0%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF%E5%8F%8A%E5%AE%9E%E7%8E%B0.assets/image-20250926144507774.png)

![image-20250926144405537](%E8%83%BD%E6%BA%90%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%B9%B3%E5%8F%B0%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF%E5%8F%8A%E5%AE%9E%E7%8E%B0.assets/image-20250926144405537.png)

![image-20250926144323381](%E8%83%BD%E6%BA%90%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%B9%B3%E5%8F%B0%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF%E5%8F%8A%E5%AE%9E%E7%8E%B0.assets/image-20250926144323381.png)

![image-20250926144237184](%E8%83%BD%E6%BA%90%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%B9%B3%E5%8F%B0%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF%E5%8F%8A%E5%AE%9E%E7%8E%B0.assets/image-20250926144237184.png)

![image-20250926144212471](%E8%83%BD%E6%BA%90%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%B9%B3%E5%8F%B0%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF%E5%8F%8A%E5%AE%9E%E7%8E%B0.assets/image-20250926144212471.png)

![image-20250926144130187](%E8%83%BD%E6%BA%90%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%B9%B3%E5%8F%B0%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF%E5%8F%8A%E5%AE%9E%E7%8E%B0.assets/image-20250926144130187.png)

## 6.5 公式查询服务器测试

![image-20250926164815647](%E8%83%BD%E6%BA%90%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%B9%B3%E5%8F%B0%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF%E5%8F%8A%E5%AE%9E%E7%8E%B0.assets/image-20250926164815647.png)

![image-20250926164827366](%E8%83%BD%E6%BA%90%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%B9%B3%E5%8F%B0%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF%E5%8F%8A%E5%AE%9E%E7%8E%B0.assets/image-20250926164827366.png)

![image-20250926164833957](%E8%83%BD%E6%BA%90%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%B9%B3%E5%8F%B0%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF%E5%8F%8A%E5%AE%9E%E7%8E%B0.assets/image-20250926164833957.png)

![image-20250926164839843](%E8%83%BD%E6%BA%90%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%B9%B3%E5%8F%B0%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF%E5%8F%8A%E5%AE%9E%E7%8E%B0.assets/image-20250926164839843.png)

![image-20250926164845732](%E8%83%BD%E6%BA%90%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%B9%B3%E5%8F%B0%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF%E5%8F%8A%E5%AE%9E%E7%8E%B0.assets/image-20250926164845732.png)

![image-20250926164851363](%E8%83%BD%E6%BA%90%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%B9%B3%E5%8F%B0%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF%E5%8F%8A%E5%AE%9E%E7%8E%B0.assets/image-20250926164851363.png)

![image-20250926164859736](%E8%83%BD%E6%BA%90%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%B9%B3%E5%8F%B0%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF%E5%8F%8A%E5%AE%9E%E7%8E%B0.assets/image-20250926164859736.png)

> 就算使用具有Native Function Calls的LLM，仅仅引用工具也无法让大模型知道怎么操作，所以还是需要使用Prompt。
>
> ![image-20250926165048586](%E8%83%BD%E6%BA%90%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%B9%B3%E5%8F%B0%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF%E5%8F%8A%E5%AE%9E%E7%8E%B0.assets/image-20250926165048586.png)

## 6.6 公式匹配遗留问题

* 看看有没什么方法进行权重的干预，让实绩之类的放到前面

* score精确，更符合人类感知的优先级排序，可能需要embedding。

* 你遇到的现象：输入 `"工业水清循环系统1#高炉公式"` 时，返回的多个候选项 **得分（score）都为 90.0**，看起来几乎没区分度。
   这其实是 **RapidFuzz 的 `WRatio` 算法本身特性 + 中文文本匹配机制** 共同导致的。

  🧩 原因分析

  ### 1️⃣ `fuzz.WRatio` 的原理

  `WRatio`（Weighted Ratio） 是一种综合比对算法，它：

  - 会自动尝试多种匹配策略（包括 `ratio`, `partial_ratio`, `token_sort_ratio` 等）；
  - 并给每种结果加权；
  - 最终取最优结果。

  但这个算法是 **为英文单词、空格分隔的文本设计的**。
   在中文场景下，因为：

  - 中文是连续的字，没有空格；
  - RapidFuzz 的默认 tokenization 不会分词；
  - 所以“工业水清循环系统1#制氧清钙合格率最终值”和“工业水清循环系统1#高炉公式”
     在算法看来，长字符串前缀完全一致，只是末尾不同；
  - 这种情况下，WRatio 会给出一个较高但相似的分数（例如 90.0）。

  换句话说：

  > 这些字符串前面几十个字都一模一样，算法认为“相似度很高”，所以都打 90 分。

  ------

  ### 2️⃣ RapidFuzz 得分离散度低的原因

  当匹配字符串长度很长，且差异只在末尾（比如最后几个字不同）时：

  - RapidFuzz 的得分主要受“编辑距离 / 总长度”影响；
  - 前缀长、差异少 → 得分集中在 85~95；
  - 所以你看到的情况是多个候选都 `90.0`。

* 💡 改进方案

  ### ✅ 方法一：改用 `token_set_ratio` 或 `partial_ratio`

  对于中文长串更有效。
   我们可以改写 `generate_candidates` ：

  ```
  def generate_candidates(name: str, topn: int = 5):
      # 改用 token_set_ratio，更适合中文连续文本
      results = process.extract(name, formulanames, scorer=fuzz.token_set_ratio, limit=topn)
      candidates = []
      for idx, (match_name, score, match_index) in enumerate(results, start=1):
          row = df.iloc[match_index]
          candidates.append({
              "number": idx,
              "FORMULAID": row["FORMULAID"],
              "FORMULANAME": row["FORMULANAME"],
              "score": round(score, 2)
          })
      return candidates
  ```

  - `token_set_ratio` 会忽略字序差异，只看共同字集合的比例，更适合中文。
  - 同时我们去掉 `_` 变量错误（你原本写的 `_` 实际是 index，变量名被覆盖了）。

  ------

  ### ✅ 方法二：组合策略提高区分度

  你可以结合多种 scorer，自动取最高得分：

  ```
  def generate_candidates(name: str, topn: int = 5):
      scorers = [fuzz.WRatio, fuzz.partial_ratio, fuzz.token_set_ratio]
      scored = []
      for s in scorers:
          results = process.extract(name, formulanames, scorer=s, limit=topn)
          scored.extend(results)
      # 去重并按分数排序
      unique = {}
      for match_name, score, idx in scored:
          if match_name not in unique or score > unique[match_name][0]:
              unique[match_name] = (score, idx)
      sorted_results = sorted(unique.items(), key=lambda x: x[1][0], reverse=True)[:topn]
      candidates = []
      for i, (name, (score, idx)) in enumerate(sorted_results, start=1):
          row = df.iloc[idx]
          candidates.append({
              "number": i,
              "FORMULAID": row["FORMULAID"],
              "FORMULANAME": row["FORMULANAME"],
              "score": round(score, 2)
          })
      return candidates
  ```

  👉 这样做能让不同 scorer 的结果互补，显著改善“全部 90.0”的问题。

  ------

  ### ✅ 方法三：增强匹配语义

  如果希望真正做到中文语义层级（比如“高炉公式”和“制氧系统”区分），
   你可以加一层 **jieba 分词** 或 **transformer 向量相似度**：

  ```
  pip install jieba sentence-transformers
  ```

  示例逻辑（快速版）：

  ```
  import jieba
  def preprocess_name(name):
      return " ".join(jieba.cut(name))
  
  df["tokens"] = df["FORMULANAME"].apply(preprocess_name)
  formulanames = df["tokens"].tolist()
  
  # 然后使用 fuzz.token_set_ratio 计算
  results = process.extract(preprocess_name(user_input), formulanames, scorer=fuzz.token_set_ratio)
  ```

  这样中文匹配精度能提升非常明显。

## 6.7 公式匹配优化

优化内容:

✅ **改进点：**

1. 启动时 **优先尝试从 `formula_embeddings.pkl` 缓存加载 embeddings**

2. 缓存的 formula 数量与 CSV 比对，不一致时重新计算

3. 保留 fuzzy / semantic / hybrid 检索功能，jieba + rapidfuzz 模糊检索，可选 sentence-transformers 语义检索，混合检索 (hybrid)

4. 文本加权保持可配置

5. 设备选择支持 CUDA / MPS / CPU / ENV

   `export EMBEDDING_DEVICE=cuda  # 或 mps / cpu`

6. 安装 & 启动指南（推荐）

   在虚拟环境中执行：

   ```
   pip install fastapi uvicorn pandas rapidfuzz jieba
   # 如果你想用语义搜索，请额外安装：
   pip install sentence-transformers  # 可能同时安装 transformers/torch 等依赖
   ```

   启动服务：

   ```
   uvicorn main:app --host 0.0.0.0 --port 9000 --reload
   ```

   示例请求：

   - 只用改进后的分词模糊匹配（默认）：
      `GET /formula_query?user_input=工业水清循环系统1#高炉公式&topn=5`
   - 使用语义搜索（需要安装 sentence-transformers）：
      `GET /formula_query?user_input=高炉 工业 水&method=semantic&topn=5`
   - 使用混合策略：
      `GET /formula_query?user_input=高炉 工业 水&method=hybrid&topn=5`

代码如下：

```
# main.py
import re
import logging
import os
import pickle
from typing import List, Optional
import pandas as pd
import numpy as np
import jieba
import torch
import time

from fastapi import FastAPI, Query
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
from rapidfuzz import process, fuzz

try:
    from sentence_transformers import SentenceTransformer
    HAVE_ST = True
except Exception:
    HAVE_ST = False

# ================= 日志配置 =================
logging.basicConfig(level=logging.INFO, format="%(asctime)s | %(levelname)s | %(message)s")
logger = logging.getLogger("formula-api")

# ================= FastAPI 初始化 =================
app = FastAPI(title="Formula Query API - Jieba + Semantic (weighted hybrid)")
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"], allow_credentials=True, allow_methods=["*"], allow_headers=["*"]
)

# ================= 全局配置 =================
CSV_PATH = os.environ.get("FORMULA_CSV", "FORMULAINFO_202503121558.csv")
EMBEDDING_MODEL_NAME = "paraphrase-multilingual-MiniLM-L12-v2"
EMBEDDING_CACHE_PATH = "formula_embeddings.pkl"
ENV_EMBEDDING_DEVICE = os.environ.get("EMBEDDING_DEVICE", "").lower()

# 🔹多关键词加权表（支持叠加）
TEXT_SCORE_WEIGHT_MAP = {
    "实绩": 0.08,  # 实绩优先
    "报出": 0.01,  # 报出次优
    "计划": -0.01,  # 计划稍弱
    "累计": -0.02,  # 累计略减分
}
ENABLE_TEXT_SCORE_WEIGHT = True

# ================= 全局变量 =================
df: Optional[pd.DataFrame] = None
_formulanames_raw: List[str] = []
_formulanames_clean: List[str] = []
_formulanames_tokens: List[str] = []
_embeddings: Optional[np.ndarray] = None
_embedding_model = None

# ===========================================================
# 工具函数
# ===========================================================
def normalize_text(s: str) -> str:
    """标准化文本：去符号、空格"""
    if s is None:
        return ""
    s = str(s).strip().strip('"').strip("'")
    s = s.replace("#", " ")
    s = re.sub(r"[^\w\u4e00-\u9fff]+", " ", s)
    s = re.sub(r"\s+", " ", s).strip()
    return s


def tokens_by_jieba(s: str) -> str:
    """用 jieba 分词"""
    if not s:
        return ""
    segs = jieba.cut(s, cut_all=False)
    return " ".join([t for t in segs if t.strip()])


def l2_normalize_matrix(mat: np.ndarray) -> np.ndarray:
    """L2 归一化矩阵"""
    norms = np.linalg.norm(mat, axis=1, keepdims=True)
    norms[norms == 0] = 1.0
    return mat / norms


def select_embedding_device() -> str:
    """检测可用设备：优先 CUDA GPU"""
    device = "cpu"
    if ENV_EMBEDDING_DEVICE in ["cuda", "mps", "cpu"]:
        device = ENV_EMBEDDING_DEVICE
        logger.info(f"Using embedding device from environment: {device}")
    else:
        if torch.cuda.is_available():
            device = "cuda"
        elif hasattr(torch.backends, "mps") and torch.backends.mps.is_available():
            device = "mps"
        logger.info(f"Auto-selected embedding device: {device}")
    return device


# ===========================================================
# 启动加载 CSV 与 Embeddings
# ===========================================================
@app.on_event("startup")
def load_csv_and_prepare():
    """启动时加载 CSV + 向量缓存"""
    global df, _formulanames_raw, _formulanames_clean, _formulanames_tokens
    global HAVE_ST, _embedding_model, _embeddings

    start_time = time.time()
    logger.info("🔄 Initializing formula data...")

    # ---- 加载 CSV ----
    try:
        try:
            df = pd.read_csv(CSV_PATH, dtype=str, quoting=3, engine="python", on_bad_lines="skip")
        except Exception:
            df = pd.read_csv(CSV_PATH, sep="\t", dtype=str, quoting=3, engine="python", on_bad_lines="skip")

        df.columns = [c.strip().replace('"', '') for c in df.columns]
        if not {"FORMULAID", "FORMULANAME"}.issubset(df.columns):
            raise RuntimeError(f"CSV 缺少必要列: {list(df.columns)}")

        df = df[["FORMULAID", "FORMULANAME"]].fillna("")
        _formulanames_raw = df["FORMULANAME"].astype(str).tolist()
        _formulanames_clean = [normalize_text(s) for s in _formulanames_raw]
        _formulanames_tokens = [tokens_by_jieba(s) for s in _formulanames_clean]

        logger.info(f"✅ Loaded {len(df)} formulas. Tokenization ready.")
    except Exception as e:
        logger.exception("❌ Failed to load CSV")
        raise RuntimeError(f"Failed to load CSV: {e}")

    # ---- 加载或生成 Embeddings ----
    if HAVE_ST:
        device = select_embedding_device()
        try:
            _embedding_model = SentenceTransformer(EMBEDDING_MODEL_NAME, device=device)
            if os.path.exists(EMBEDDING_CACHE_PATH):
                with open(EMBEDDING_CACHE_PATH, "rb") as f:
                    cached_data = pickle.load(f)
                if cached_data.get("formula_count") == len(_formulanames_raw):
                    _embeddings = cached_data["embeddings"]
                    logger.info(f"✅ Loaded embeddings from cache ({_embeddings.shape}) in {time.time()-start_time:.2f}s")
                    return
                else:
                    logger.warning("⚠️ Embedding cache formula count mismatch, recalculating embeddings...")

            # 重新计算
            emb_list = _embedding_model.encode(
                _formulanames_raw,
                batch_size=64,
                show_progress_bar=True,
                convert_to_numpy=True
            )
            _embeddings = l2_normalize_matrix(np.asarray(emb_list, dtype=np.float32))
            with open(EMBEDDING_CACHE_PATH, "wb") as f:
                pickle.dump({"formula_count": len(_formulanames_raw), "embeddings": _embeddings}, f)

            logger.info(f"✅ Computed and cached embeddings ({_embeddings.shape}) in {time.time()-start_time:.2f}s")

        except Exception as e:
            logger.exception("❌ Failed to load or compute embeddings. Semantic mode disabled.")
            HAVE_ST = False
            _embedding_model = None
            _embeddings = None
    else:
        logger.warning("⚠️ sentence-transformers not installed — semantic mode DISABLED.")


# ===========================================================
# 加权函数
# ===========================================================
def apply_text_weights(formula_name: str, base_score: float) -> float:
    """对包含特定关键词的名称加权，可叠加"""
    if not ENABLE_TEXT_SCORE_WEIGHT or base_score <= 0:
        return base_score
    weighted_score = base_score
    for key, w in TEXT_SCORE_WEIGHT_MAP.items():
        if key in formula_name:
            weighted_score *= (1 + w)
    return weighted_score


# ===========================================================
# 检索函数
# ===========================================================
def fuzzy_search(user_input: str, topn: int = 5):
    """模糊检索"""
    key_clean = normalize_text(user_input)
    key_tokens = tokens_by_jieba(key_clean)
    if not key_tokens:
        return []

    results = process.extract(key_tokens, _formulanames_tokens, scorer=fuzz.token_set_ratio, limit=topn * 3)
    candidates = []
    for rank, (match_text, score, match_index) in enumerate(results, start=1):
        row = df.iloc[match_index]
        clean_name = str(row["FORMULANAME"]).strip().strip('"').strip("'")  # ✅ 去除多余引号
        final_score = apply_text_weights(clean_name, float(score))
        candidates.append({
            "number": rank,
            "FORMULAID": row["FORMULAID"],
            "FORMULANAME": row["FORMULANAME"],
            "score": round(final_score, 4),
            "match_kind": "fuzzy_token_set"
        })
    return sorted(candidates, key=lambda x: x["score"], reverse=True)[:topn]


def semantic_search(user_input: str, topn: int = 5):
    """语义检索"""
    if not HAVE_ST or _embeddings is None or _embedding_model is None:
        raise RuntimeError("Semantic mode not available.")
    vec = _embedding_model.encode([user_input], convert_to_numpy=True).astype(np.float32)
    vec = vec / (np.linalg.norm(vec, axis=1, keepdims=True) + 1e-12)
    sims = np.dot(_embeddings, vec[0])
    top_idx = np.argsort(-sims)[:topn * 3]
    candidates = []
    for rank, idx in enumerate(top_idx, start=1):
        row = df.iloc[int(idx)]
        clean_name = str(row["FORMULANAME"]).strip().strip('"').strip("'")  # ✅ 去除多余引号
        base_score = float(sims[idx]) * 100.0
        final_score = apply_text_weights(clean_name, base_score)
        candidates.append({
            "number": rank,
            "FORMULAID": row["FORMULAID"],
            "FORMULANAME": row["FORMULANAME"],
            "score": round(final_score, 4),
            "match_kind": "semantic_cosine"
        })
    return sorted(candidates, key=lambda x: x["score"], reverse=True)[:topn]


def hybrid_search(user_input: str, topn: int = 5, fuzzy_weight: float = 0.4, semantic_weight: float = 0.6):
    """混合检索"""
    fuzzy_candidates = fuzzy_search(user_input, topn=topn * 3)
    if not HAVE_ST or _embeddings is None:
        return fuzzy_candidates[:topn]

    vec = _embedding_model.encode([user_input], convert_to_numpy=True).astype(np.float32)
    vec = vec / (np.linalg.norm(vec, axis=1, keepdims=True) + 1e-12)
    sims = np.dot(_embeddings, vec[0]) * 100.0

    merged = []
    for c in fuzzy_candidates:
        fid = c["FORMULAID"]
        matched_rows = df.index[df["FORMULAID"] == fid].tolist()
        if not matched_rows:
            continue
        idx = int(matched_rows[0])
        semantic_score = float(sims[idx])
        fuzzy_score = float(c["score"])

        # 🔹 动态调整权重（当模糊度高时，语义占比提升）
        if fuzzy_score > 95:
            fuzzy_weight, semantic_weight = 0.4, 0.6

        clean_name = str(df.iloc[idx]["FORMULANAME"]).strip().strip('"').strip("'")  # ✅ 去除多余引号
        final_score = fuzzy_weight * fuzzy_score + semantic_weight * semantic_score
        final_score = apply_text_weights(clean_name, final_score)
        merged.append((final_score, fuzzy_score, semantic_score, idx))

    merged.sort(key=lambda x: x[0], reverse=True)
    candidates = []
    for rank, (final_score, fuzzy_score, semantic_score, idx) in enumerate(merged[:topn], start=1):
        row = df.iloc[idx]
        clean_name = str(row["FORMULANAME"]).strip().strip('"').strip("'")  # ✅ 去除多余引号
        candidates.append({
            "number": rank,
            "FORMULAID": row["FORMULAID"],
            "FORMULANAME": clean_name,
            "score": round(float(final_score), 4),
            "fuzzy_score": round(float(fuzzy_score), 4),
            "semantic_score": round(float(semantic_score), 4),
            "match_kind": "hybrid"
        })
    return candidates


# ===========================================================
# API 接口
# ===========================================================
@app.get("/formula_query")
def formula_query(
    user_input: str = Query(..., description="User input: keyword or exact formula name"),
    topn: int = Query(5, ge=1, le=50, description="Number of candidates to return"),
    method: str = Query("hybrid", description="Search method: fuzzy | semantic | hybrid")
):
    """统一查询接口"""
    user_input = user_input.strip().strip('"').strip("'")
    if not user_input:
        return JSONResponse(content={"done": False, "message": "Empty input."})

    # ---------- 精确匹配 ----------
    exact = df[df["FORMULANAME"] == user_input]
    if exact.empty:
        clean_input = normalize_text(user_input)
        matches_idx = [i for i, v in enumerate(_formulanames_clean) if v == clean_input]
        if matches_idx:
            exact = pd.DataFrame([df.iloc[matches_idx[0]]])
    if not exact.empty:
        exact_matches = exact[["FORMULAID", "FORMULANAME"]].to_dict(orient="records")
        for item in exact_matches:
            item["FORMULANAME"] = str(item["FORMULANAME"]).strip().strip('"').strip("'")  # ✅ 去除多余引号
        return JSONResponse(content={
            "done": True,
            "message": f"Exact match found: {exact_matches[0]['FORMULANAME']}",
            "exact_matches": exact_matches
        })

    # ---------- 模糊 / 语义 / 混合 ----------
    try:
        method = method.lower()
        if method == "fuzzy":
            candidates = fuzzy_search(user_input, topn=topn)
        elif method == "semantic":
            candidates = semantic_search(user_input, topn=topn)
        elif method == "hybrid":
            candidates = hybrid_search(user_input, topn=topn)
        else:
            return JSONResponse(content={"done": False, "message": f"Unknown method: {method}"})
    except Exception as e:
        logger.exception("❌ Search error")
        return JSONResponse(content={"done": False, "message": f"Search error: {e}", "candidates": []})

    # ---------- 输出 ----------
    if not candidates:
        return JSONResponse(content={"done": False, "message": "No matches found.", "candidates": []})

    msg_lines = ["Multiple candidates found, choose by number:"]
    for c in candidates:
        if c.get("match_kind") == "hybrid":
            msg_lines.append(
                f"{c['number']}) {c['FORMULANAME']} (final {c['score']}, fuzzy {c['fuzzy_score']}, semantic {c['semantic_score']})"
            )
        else:
            msg_lines.append(f"{c['number']}) {c['FORMULANAME']} (score {c['score']})")

    return JSONResponse(content={
        "done": False,
        "message": "\n".join(msg_lines),
        "candidates": candidates
    })
```

实际效果：

![image-20251009184423326](%E8%83%BD%E6%BA%90%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%B9%B3%E5%8F%B0%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF%E5%8F%8A%E5%AE%9E%E7%8E%B0.assets/image-20251009184423326.png)

![image-20251009184502935](%E8%83%BD%E6%BA%90%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%B9%B3%E5%8F%B0%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF%E5%8F%8A%E5%AE%9E%E7%8E%B0.assets/image-20251009184502935.png)

![image-20251010161215674](%E8%83%BD%E6%BA%90%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%B9%B3%E5%8F%B0%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF%E5%8F%8A%E5%AE%9E%E7%8E%B0.assets/image-20251010161215674.png)

![image-20251010161236810](%E8%83%BD%E6%BA%90%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%B9%B3%E5%8F%B0%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF%E5%8F%8A%E5%AE%9E%E7%8E%B0.assets/image-20251010161236810.png)

## 6.8 流程编排

### 1、多轮对话的任务分解

> 我通过openwebui调用fastapi的Tools来调用其它平台接口，我需要用户在对话框输入指标名称和精确时间，用户可能是一次输入指标和时间信息，可能都不精确，也可能开始只输入某项内容，我该如何实现通过一次对话或者多次对话获取精确指标名称和时间信息，来实现我最终调用其它平台接口的目的。这里是否涉及到prompt编排，如果prompt不能做到精确编码，有没有其它手段来实现我这三步流程，1.匹配精确名称得到公式。2.匹配精确日期信息，3.调用其它平台接口获得最终结果并在对话里展示给用户

你这个需求其实就是一个**多轮对话的任务分解**问题，本质上是“槽位填充（slot filling） + 工具调用（function calling）”。

你的三步流程可以拆解为：

1. **指标名匹配 → 公式编码**
2. **时间信息解析 → 精确日期**
3. **调用外部平台接口 → 返回结果给用户**

这可以有几种实现路径，我给你分层分析一下：

------

#### 🔹 1. 单纯用 Prompt 编排

在 OpenWebUI 里，你可以写一个“系统提示词”，明确告诉模型：

- 当用户输入时，如果指标名/时间不完整，就继续追问；
- 如果两者都明确，就调用相应的 Tools；
- 指标模糊时调用 fuzzy match → 返回候选，让用户选择。

👉 这种方式的优点是简单，不需要额外逻辑；缺点是**不稳定**，不同模型对 prompt 遵循度差别很大，特别是小模型容易漏掉步骤。

------

#### 🔹 2. 借助工具/框架的对话状态管理（推荐）

你需要引入一个 **状态机 / 对话管理层** 来保证流程可控，而不仅仅依赖 LLM。
 可以用的方案：

- **手工写逻辑**：
   在 FastAPI 层维护一个对话 session，定义 `slots = {"indicator": None, "date": None}`，每次用户输入就用模型帮忙解析内容，填充到 slot 里。直到两个 slot 都填满，再调用外部接口。
- **Rasa / LangChain / Haystack Agent**：
   它们都支持 **Slot Filling** 或 **Memory + Tool calling**。模型只负责提取用户输入中的实体（指标名、日期），最终的执行逻辑交给框架。
- **OpenWebUI Pipelines**：
   Pipelines 其实就是你想要的编排逻辑，可以写三个 step：
  1. fuzzy match 指标 → 得到公式
  2. 时间解析 → 格式化日期
  3. 调用工具 → 获取结果

------

#### 🔹 3. 技术要点

- **指标名解析**：
   用 `rapidfuzz` 这种模糊匹配库，让模型只负责抽取候选关键词，再由代码来做精确匹配。
- **时间解析**：
   可以用 `dateparser`、`parsedatetime` 等库，支持中文“昨天”、“上周一”、“2025年9月” → 转换成 ISO 日期。
- **调用外部接口**：
   在 Tools 里只保留真正的“最终调用”，前面的步骤（模糊匹配/时间解析）都可以在你的 FastAPI 层提前完成。

------

#### 🔹 4. 总结

你的问题确实涉及 **prompt 编排**，但如果完全靠 prompt，可靠性不高。
 最稳妥的方案是：

1. **多轮对话解析 → Slot Filling**
    （指标名 slot + 日期 slot）
2. **外部工具/代码完成精确匹配与转换**
3. **填满后统一调用平台 API 并返回结果**

这样用户可以：

- 一次性输入（“查2030酸轧纯水使用量，2024年7月”） → 直接调用；
- 分步输入（“查2030酸轧纯水使用量” → “时间是上个月”） → 等 slot 填满再调用。

### 2、不选择piplines进行编排

```json
{
  "name": "指标查询Pipeline",
  "description": "实现用户输入指标和时间 → 公式匹配 → 时间解析 → 外部平台API调用 → 返回结果",
  "steps": [
    {
      "id": "parse_input",
      "type": "llm",
      "name": "解析用户输入",
      "prompt": "你是一个解析助手。用户输入可能包含指标名称和时间，请从输入中提取出两个字段：indicator（指标名称，如果没有写null），date（时间，如果没有写null）。输出JSON格式。示例输出：{\"indicator\": \"2030酸轧纯水使用量\", \"date\": \"2024年7月\"}"
    },
    {
      "id": "match_formula",
      "type": "tool",
      "name": "指标匹配工具",
      "tool": "formula_query_api",
      "input_mapping": {
        "indicator": "steps.parse_input.output.indicator"
      },
      "output_mapping": {
        "formula": "formula"
      }
    },
    {
      "id": "parse_date",
      "type": "tool",
      "name": "时间解析工具",
      "tool": "date_parse_api",
      "input_mapping": {
        "date": "steps.parse_input.output.date"
      },
      "output_mapping": {
        "date": "parsed_date"
      }
    },
    {
      "id": "call_platform",
      "type": "tool",
      "name": "调用外部平台API",
      "tool": "platform_api",
      "input_mapping": {
        "formula": "steps.match_formula.output.formula",
        "date": "steps.parse_date.output.date"
      },
      "output_mapping": {
        "result": "value"
      }
    },
    {
      "id": "final_answer",
      "type": "llm",
      "name": "生成回复",
      "prompt": "根据以下信息生成用户友好的回答：\\n指标: {{steps.parse_input.output.indicator}}\\n公式编码: {{steps.match_formula.output.formula}}\\n时间: {{steps.parse_date.output.date}}\\n结果: {{steps.call_platform.output.result}}"
    }
  ]
}
```

🔹 配套说明

1. **工具需要提前在 OpenWebUI Tools 中配置**

   - `formula_query_api` → 你现有的公式匹配 API
   - `date_parse_api` → 用 FastAPI 写个 `/parse_date`，内部用 `dateparser`
   - `platform_api` → 外部能源平台接口

2. **多轮对话追问机制**

   - 如果 Step1 解析出 `indicator=null` 或 `date=null`，可以在 LLM Prompt 中写上：

     > “如果字段为 null，请追问用户补充完整”

   - 这样 pipeline 会继续对话直到 slot 填满。

3. **迭代实现方式**

   - ✅ 第一步：先跑通 `parse_input → match_formula`
   - ✅ 第二步：再接 `parse_date`
   - ✅ 第三步：最后接 `platform_api`

🔹 Pipelines 在 OpenWebUI 中是什么 & 原理

* Pipelines 是 OpenWebUI 提供的一个 **模块化工作流 / 插件系统**，用来把复杂逻辑／多步流程从主界面剥离出去运行。 

- 相比于 Functions（OpenWebUI 自己内置的函数调用能力），Pipelines 通常运行在一个独立服务/容器上，这样可以减轻主 WebUI 的负载。
- 在 WebUI 界面里，启用了 Pipelines 后，某些自定义 pipeline 会以“外部模型 / External 模型”的形式出现在模型选择菜单里面（或其他地方）作为一种“模型”或“流程”入口。

```
docker run -d -p 9099:9099 \
  --add-host=host.docker.internal:host-gateway \
  -v pipelines:/app/pipelines \
  --name pipelines \
  --restart always \
  ghcr.io/open-webui/pipelines:main
```

* 在 OpenWebUI 中添加 Pipelines 连接

  在 WebUI 的 **Admin Panel → Settings → Connections** 中，新增一个连接，把 API URL 指向 Pipelines 容器（例如 `http://localhost:9099` 或 `http://host.docker.internal:9099`），API Key 通常默认 `0p3n-w3bu!`。

* 导入 / 部署你的 pipeline 脚本

  将你的 pipeline 脚本（例如 JSON 配置 / Python 脚本）放入 Pipelines 服务可识别的目录，或者通过 WebUI 的 Admin → Pipelines UI 上传/输入代码。 

*  在 Admin 面板启用 / 选择 pipeline 

   在 OpenWebUI 的 Admin → “Pipelines” 选项卡里，会列出可用的 pipeline 模块（有 “Valves / 配置”界面）可供启用 / 调整。

* 在 Chat / 新对话中选择 pipeline 模型 

  在发起新对话 / 模型选择菜单中，你应该能看到你的 pipeline 所对应的模型，或外部流程入口。

### 3、不依赖openwebui提取指标

> 直接给出结论：不同的工具，甚至是相同的工具不同的版本对Prompt的内部处理是不一样的。导致预测的结果无法预测。

* 下图展示的是：Prompt相同，Ollama相同，LLM相同，仅仅openwebui的版本不同，服务器的旧版在指标提取就不行。

![image-20251016153743914](%E8%83%BD%E6%BA%90%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%B9%B3%E5%8F%B0%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF%E5%8F%8A%E5%AE%9E%E7%8E%B0.assets/image-20251016153743914.png)

* 相同的提示词相同的模型，使用openwebui，问:查询今年的2030酸轧纯水使用量 ，结果：{"indicator":"2030酸轧纯水使用量","date":"今年"}，但是在llm_parser.py中(langchain)测试却是{'indicator': '酸轧纯水使用量', 'date': '2030年'}，openwebui是对的，这是为何？

我分析了你描述的现象，这其实和 **调用方式、异步执行、以及模型内部默认行为** 有很大关系。具体原因主要有几个：

------

#### 1️⃣ 模型版本 / 包差异

- 在 `openwebui` 中，模型是通过 Ollama 的原生服务调用，它的解析上下文、tokenization 以及默认文本处理方式都由 Ollama 直接控制。
- 在 `llm_parser` 测试中，你可能用的是 **langchain 封装的 `ChatOllama`**：
  - 旧版 `langchain` / `langchain-community` / `langchain-ollama` 的封装可能会修改 prompt、截断输入、或者对换行符处理不同。
  - 尤其是 `\n` 和空格处理不同，可能导致模型把 `"2030酸轧纯水使用量"` 拆成 `"2030年"` + `"酸轧纯水使用量"`。

------

#### 2️⃣ Prompt 的换行与格式

- `openwebui` 直接把你写的 prompt 发给模型。

- 在 `llm_parser` 中，你的 prompt 包含 **Python 的多行 f-string**：

  ```
  prompt = f"""
  用户输入："{user_input}"
  """
  ```

  Python 字符串会保留首尾换行和空格，可能导致模型把 `"2030酸轧纯水使用量"` 理解成 `"2030年"` + `"酸轧纯水使用量"`。

> 模型对“年、数字+指标名”非常敏感，任何额外换行或空格都会影响解析。

------

#### 3️⃣ 异步调用 vs 同步调用

- `openwebui` 调用是同步的浏览器/前端请求，模型收到完整 prompt。
- `llm_parser` 里 `await llm.agenerate([[HumanMessage(content=prompt)]])` 有时可能被截断，或者 token 数限制导致 prompt 被截掉前后字符。
- 如果 prompt 超过 token 限制，模型可能优先提取日期（2030年）而把指标名截断。

------

#### 4️⃣ 解决办法

可以尝试：

1. **去掉多余换行和缩进**：

   ```
   prompt = (
       "你是一个解析助手，负责从用户的自然语言中提取查询指标名称（indicator）和时间信息（date）。"
       "请严格按照以下规则输出：..."
       f"用户输入：\"{user_input}\""
       "输出："
   )
   ```

   这样 prompt 是一整行，没有前导空格或多余换行。

2. **在 `langchain` 调用中加 `stop` 或 `max_tokens`**：

   ```
   llm = ChatOllama(model="qwen2.5:1.5b", stop=["\n"], max_tokens=200)
   ```

3. **打印 prompt 以检查格式**：

   ```
   print(repr(prompt))
   ```

   确认 `"2030酸轧纯水使用量"` 前后没有空格或换行。

4. **尝试与 openwebui 一样的调用方式**：

   - 在 openwebui 上右侧可看到 **完整 request payload**。
   - 在 llm_parser 中完全复刻 prompt 和调用参数，包括 `temperature=0`、`top_p=1.0` 等。

------

💡 **总结**
 你看到的差异并不是模型本身问题，而是 **prompt 细节 + 调用方式 + token/截断行为** 导致模型解析不同。`2030酸轧纯水使用量` 被拆成 `2030年` + `酸轧纯水使用量` 就是典型的 prompt 换行或 token 截断导致的现象。

### 4、提取指标和时间格式和类型

1、优先使用算法服务器gemma3:27b模型的能力，本地qwen2.5:1.5b是无法理解规则如此复杂的prompt，就会导致预测结果太不稳定，基本每次都会有变化。

2、加入了兜底的功能，实测作用不大。

测试用例：

```
"450酸轧纯水使用量",
"查询今年的2030酸轧纯水使用量",
"今天的酸轧纯水使用量",
"9月份热轧蒸汽消耗",
"酸轧纯水使用量",
"昨天",
"2025年第41周纯水损失率",
"今年10月14日酸轧纯水使用量",
"本周",
"上周的吨钢用水量",
"昨天早班的热轧蒸汽消耗",
"明天凌晨2点的轧制水耗",
"去年12月份的吨钢用水量",
"2025年第4季度纯水损失率",
"2025年10月上旬热轧蒸汽消耗",
"今天的高炉工序能耗是多少",
"高炉今天的工序能耗是多少",
"本月累计的高炉工序能耗是多少",
"1号高炉昨天的工序能耗是多少",
"去年今天的高炉工序能耗是多少",
"2021年10月23日的1高炉工序能耗是多少",
"2023年10月22日的2高炉工序能耗是多少",
"时间：2021-10-23，1高炉工序能耗是多少",
"高炉工序能耗是多少",
"本月1、2号高炉工序能耗是多少",
"高炉工序能耗本月计划是多少",
"本月高炉工序能耗的计划值是多少",
"本月的高炉电耗是多少",
"本月的高炉电使用量是多少",
"高炉的煤气耗是多少",
"10号高炉今天的工序能耗是多少",
"今年累计的冷轧蒸汽消耗是多少",
"前天晚班的吨钢用水量"
```

代码为：

```
import os
for key in ["HTTP_PROXY", "HTTPS_PROXY", "ALL_PROXY", "http_proxy", "https_proxy", "all_proxy"]:
    os.environ.pop(key, None)

import asyncio
import re
import json
import httpx
from datetime import datetime, timedelta

# ===================== ChatOllama 兼容导入 =====================
try:
    from langchain_ollama import ChatOllama
    print("✅ Using ChatOllama from langchain-ollama")
except ImportError:
    try:
        from langchain_community.chat_models import ChatOllama
        print("✅ Using ChatOllama from langchain_community")
    except ImportError:
        from langchain.chat_models import ChatOllama
        print("⚠️ Using ChatOllama from old langchain (may be deprecated)")

from langchain.schema import HumanMessage

# ===================== 模型优先级定义 =====================
REMOTE_OLLAMA_URL = "http://192.168.92.13:11434"  # ← 修改为你的远程 Ollama 地址
REMOTE_MODEL = "gemma3:27b"
LOCAL_MODEL = "qwen2.5:1.5b"


async def is_remote_ollama_available(base_url: str, timeout: float = 3.0) -> bool:
    """
    检查远程 Ollama 服务是否可访问。
    """
    try:
        async with httpx.AsyncClient(timeout=timeout) as client:
            resp = await client.get(f"{base_url}/api/tags")
            if resp.status_code == 200:
                #print(f"🌐 Remote Ollama available at {base_url}")
                return True
    except Exception as e:
        print(f"⚠️ Remote Ollama not reachable: {e}")
    return False


async def get_llm() -> ChatOllama:
    """
    优先使用远程 gemma3:27b，如果远程不可用则回退到本地 qwen2.5:1.5b。
    """
    if await is_remote_ollama_available(REMOTE_OLLAMA_URL):
        #print(f"✅ Using remote model: {REMOTE_MODEL}")
        return ChatOllama(model=REMOTE_MODEL, base_url=REMOTE_OLLAMA_URL)
    else:
        print(f"🔄 Falling back to local model: {LOCAL_MODEL}")
        return ChatOllama(model=LOCAL_MODEL)

"""
在无示例情况下，如果大模型精度差强人意，可以将示例插入prompt的[注意]和[用户输入："{user_input}"]之间，但是无法避免LLM直接拿来编
示例：
输入："查询今年的3030连退纯水使用量"
输出：{{"indicator":"3030连退纯水使用量","timeString":"{now.year}","timeType":"YEAR"}}

输入："今天的连退纯水使用量"
输出：{{"indicator":"连退纯水使用量","timeString":"{now.strftime('%Y-%m-%d')}","timeType":"DAY"}}

输入："今天"
输出：{{"indicator":null,"timeString":"{now.strftime('%Y-%m-%d')}","timeType":"DAY"}}

输入："冷轧蒸汽消耗"
输出：{{"indicator":"冷轧蒸汽消耗","timeString":null,"timeType":null}}

输入："8月份冷轧蒸汽消耗"
输出：{{"indicator":"冷轧蒸汽消耗","timeString":"{now.year}-08","timeType":"MONTH"}}

输入："2024年第31周纯水损失率"
输出：{{"indicator":"纯水损失率","timeString":"2024-W31","timeType":"WEEK"}}

输入："2017年第1季度纯水损失率"
输出：{{"indicator":"纯水损失率","timeString":"2017 Q1","timeType":"QUARTER"}}

输入："2019年8月下旬冷轧蒸汽消耗"
输出：{{"indicator":"冷轧蒸汽消耗","timeString":"2019-08 下旬","timeType":"TENDAYS"}}

输入："前天晚班的冷轧蒸汽消耗"
输出：{{"indicator":"冷轧蒸汽消耗","timeString":"{(now - timedelta(days=2)).strftime('%Y-%m-%d')} 晚班","timeType":"SHIFT"}}

输入："下周的吨钢用水量"
输出：{{"indicator":"吨钢用水量","timeString":"{(now + timedelta(weeks=1)).isocalendar()[0]}-W{(now + timedelta(weeks=1)).isocalendar()[1]}","timeType":"WEEK"}}

输入："今年10月14日酸轧纯水使用量"
输出：{{"indicator":"酸轧纯水使用量","timeString":"2025-10-14","timeType":"DAY"}}
"""

# ===================== 主解析函数 =====================
async def parse_user_input(user_input: str, now: datetime = None):
    if now is None:
        now = datetime.now()
    now_str = now.strftime("%Y-%m-%d %H:%M")

    prompt = f"""
你是一个智能解析助手，用于从用户输入中提取“指标名称”和“时间信息”。
当前系统时间为：{now_str}。

请严格输出 JSON：
{{
  "indicator": "...",
  "timeString": "...",
  "timeType": "..."
}}

要求：
1. indicator 必须保留原文，包括数字和文字，不要丢失任何信息。
   - 如果数字紧跟在指标词中（如“2030酸轧纯水使用量”、“3030连退纯水使用量”），则视为指标一部分，而非时间。
   - 只有当数字后面带有“年”“月份”“月”“周”“季度”“日”等时间修饰词时，才视为时间。
   - 不要因为指标中包含数字就将其误判为时间。
   - 指标中可能包含描述性质的后缀词（如“累计”、“计划”、“目标”、“完成值”、“用量”、“指标”、“成本”、“效率”、“总量”、“单耗”、“强度”等），
     这些词均属于指标的一部分，必须保留在 indicator 中，不得截断。

2. timeString 必须根据 timeType 精确格式化：
   - HOUR → "YYYY-MM-DD HH"
   - SHIFT → "YYYY-MM-DD 早班/白班/夜班"
     - “早班”、“白班”、“夜班”、“中班”、“晚班” 都属于 SHIFT 类型。
     - 班次优先级高于 HOUR。即如果句中出现“早班/白班/夜班”，无论是否同时出现“几点”，都按 SHIFT 解析。
     - 日期计算规则与 DAY 相同：  
       “昨天早班” → (now - timedelta(days=1)).strftime("%Y-%m-%d") + " 早班"
       “今天白班” → now.strftime("%Y-%m-%d") + " 白班"
       “明天夜班” → (now + timedelta(days=1)).strftime("%Y-%m-%d") + " 夜班"
   - DAY → "YYYY-MM-DD"
   - WEEK → "YYYY-W##"
     - 使用 ISO 标准周号（周一为一周开始）。
     - “本周” 表示当前日期所在周号： now.isocalendar().week
     - “上周” 表示前一周： (now - timedelta(weeks=1)).isocalendar().week
     - “下周” 表示后一周： (now + timedelta(weeks=1)).isocalendar().week
     - 年份应对应该周的 ISO 年份： now.isocalendar().year
   - MONTH → "YYYY-MM"
     - 如果输入中只出现月份（如“8月份”、“9月”），则补上当前年份，例如："2025-08"
     - 如果出现“去年8月份”，则使用去年年份："2024-08"
     - 如果出现“明年3月份”，则使用明年年份："2026-03"
     - 如果出现“上个月”，则使用使用今年年份："2025-09"（假如这个月是2025年10月份）
     - 如果输入中出现“月”后跟“日”，例如“10月14日”，则优先判断为 DAY：
       输出格式：{{"timeString":"YYYY-MM-DD","timeType":"DAY"}}
   - QUARTER → "YYYY Q#"
   - TENDAYS → "YYYY-MM 上旬/中旬/下旬"
   - YEAR → "YYYY"
   - 若无法推算则为 null

3. timeType 取值必须为以下之一：
   ["HOUR","SHIFT","DAY","WEEK","MONTH","QUARTER","TENDAYS","YEAR"]
   若无法判断则为 null。

4. 只解析输入中真正的指标和时间，不要添加无关字符。
   - 如果出现“今天”、“昨天”、“明天”、“上周”、“本周”、“下周”、“上月”、“本月”、“今年”、“去年”等相对时间，
     请基于当前时间 {now_str} 推算出精确日期。
   - 指标中的时间词不要删除或修改指标内部数字。

5. 输出格式必须严格为 JSON，不要添加多余文字、解释或注释。

注意：
- “indicator” 必须只包含指标名称，不包含时间相关词（如“今年”、“9月份”、“昨天”、“上周”、“第3季度”等）。
- 指标中若包含性质修饰（如“累计”、“计划”、“目标”、“用量”、“成本”、“效率”等），必须保留。
  例如：
  - “本月累计的高炉工序能耗是多少” → indicator="高炉工序能耗累计"
  - “高炉工序能耗本月计划是多少” → indicator="高炉工序能耗计划"
  - “去年12月吨钢蒸汽成本” → indicator="吨钢蒸汽成本"
  - “明年目标纯水损失率” → indicator="目标纯水损失率"
- 班次词（早班、白班、夜班、中班、晚班）属于时间，不属于指标。
- SHIFT 类型优先于 HOUR：不要将“早班”错误地转化为具体小时。

用户输入："{user_input}"
"""

    llm = await get_llm()

    try:
        resp = await llm.agenerate([[HumanMessage(content=prompt)]])
        content = resp.generations[0][0].message.content.strip()
    except Exception as e:
        print("❌ LLM 调用失败:", e)
        return {"indicator": None, "timeString": None, "timeType": None}

    try:
        result = json.loads(content)
    except json.JSONDecodeError:
        result = {
            "indicator": re.search(r'"indicator"\s*:\s*"([^"]*)"', content).group(1) if re.search(r'"indicator"\s*:\s*"([^"]*)"', content) else None,
            "timeString": re.search(r'"timeString"\s*:\s*"([^"]*)"', content).group(1) if re.search(r'"timeString"\s*:\s*"([^"]*)"', content) else None,
            "timeType": re.search(r'"timeType"\s*:\s*"([^"]*)"', content).group(1) if re.search(r'"timeType"\s*:\s*"([^"]*)"', content) else None
        }

    indicator = result.get("indicator")
    timeString = result.get("timeString")
    timeType = result.get("timeType")

    # ✅ 兜底 WEEK 精确修正
    # ✅ 精准 WEEK 修正（仅处理语义性“上周、本周、下周”）
    if timeType == "WEEK":
        # 仅当出现相对时间词时修正
        if any(word in user_input for word in ["上周", "本周", "下周"]):
            if "上周" in user_input:
                ref = now - timedelta(weeks=1)
            elif "下周" in user_input:
                ref = now + timedelta(weeks=1)
            else:
                ref = now
            iso_year, iso_week, _ = ref.isocalendar()
            timeString = f"{iso_year}-W{iso_week:02d}"


    # ✅ 格式修正逻辑保留
    if timeString and timeType:
        if timeType == "WEEK":
            m = re.match(r'(\d{4})\D*(\d{1,2})', timeString)
            if m:
                timeString = f"{m.group(1)}-W{int(m.group(2)):02d}"
        elif timeType == "QUARTER":
            m = re.match(r'(\d{4})\D*(\d)', timeString)
            if m:
                timeString = f"{m.group(1)} Q{m.group(2)}"
        elif timeType == "TENDAYS":
            m = re.match(r'(\d{4}-\d{2}).*?(上旬|中旬|下旬)', timeString)
            if m:
                timeString = f"{m.group(1)} {m.group(2)}"
        elif timeType == "SHIFT":
            m = re.match(r'(\d{4}-\d{2}-\d{2}).*?(早班|白班|夜班)', timeString)
            if m:
                timeString = f"{m.group(1)} {m.group(2)}"
        elif timeType == "HOUR":
            m = re.match(r'(\d{4}-\d{2}-\d{2})\D*(\d{1,2})', timeString)
            if m:
                timeString = f"{m.group(1)} {int(m.group(2)):02d}"
        elif timeType in ["MONTH", "DAY", "YEAR"]:
            m = re.match(r'(\d{4}-\d{2}-\d{2}|\d{4}-\d{2}|\d{4})', timeString)
            if m:
                timeString = m.group(1)

    if indicator:
        indicator = re.sub(r'^(今天|昨天|明天|本周|上周|下周|上月|本月|今年|去年)\s*的?', '', indicator)
        indicator = re.sub(r'\s*(今天|昨天|明天|本周|上周|下周|上月|本月|今年|去年)$', '', indicator)
        indicator = indicator.strip() or None

    return {"indicator": indicator, "timeString": timeString, "timeType": timeType}


# ===================== 测试 =====================
if __name__ == "__main__":
    import nest_asyncio
    nest_asyncio.apply()
    loop = asyncio.get_event_loop()
    now = datetime(2025, 10, 16, 14, 0)

    test_inputs = [
        "450酸轧纯水使用量",
        "查询今年的2030酸轧纯水使用量",
        "今天的酸轧纯水使用量",
        "9月份热轧蒸汽消耗",
        "酸轧纯水使用量",
        "昨天",
        "2025年第41周纯水损失率",
        "今年10月14日酸轧纯水使用量",
        "本周",
        "上周的吨钢用水量",
        "昨天早班的热轧蒸汽消耗",
        "明天凌晨2点的轧制水耗",
        "去年12月份的吨钢用水量",
        "2025年第4季度纯水损失率",
        "2025年10月上旬热轧蒸汽消耗",
        "今天的高炉工序能耗是多少",
        "高炉今天的工序能耗是多少",
        "本月累计的高炉工序能耗是多少",
        "1号高炉昨天的工序能耗是多少",
        "去年今天的高炉工序能耗是多少",
        "2021年10月23日的1高炉工序能耗是多少",
        "2023年10月22日的2高炉工序能耗是多少",
        "时间：2021-10-23，1高炉工序能耗是多少",
        "高炉工序能耗是多少",
        "本月1、2号高炉工序能耗是多少",
        "高炉工序能耗本月计划是多少",
        "本月高炉工序能耗的计划值是多少",
        "本月的高炉电耗是多少",
        "本月的高炉电使用量是多少",
        "高炉的煤气耗是多少",
        "10号高炉今天的工序能耗是多少",
        "今年累计的冷轧蒸汽消耗是多少",
        "前天晚班的吨钢用水量"
    ]

    for ti in test_inputs:
        result = loop.run_until_complete(parse_user_input(ti))
        print(f"{ti} => {result}")
```

当前版本[2025年10月16日16点04分]测试结果如下：

```
✅450酸轧纯水使用量 => {'indicator': '450酸轧纯水使用量', 'timeString': None, 'timeType': None}
✅查询今年的2030酸轧纯水使用量 => {'indicator': '2030酸轧纯水使用量', 'timeString': '2025', 'timeType': 'YEAR'}
✅今天的酸轧纯水使用量 => {'indicator': '酸轧纯水使用量', 'timeString': '2025-10-16', 'timeType': 'DAY'}
✅9月份热轧蒸汽消耗 => {'indicator': '热轧蒸汽消耗', 'timeString': '2025-09', 'timeType': 'MONTH'}
✅酸轧纯水使用量 => {'indicator': '酸轧纯水使用量', 'timeString': None, 'timeType': None}
✅昨天 => {'indicator': None, 'timeString': '2025-10-15', 'timeType': 'DAY'}
✅2025年第41周纯水损失率 => {'indicator': '纯水损失率', 'timeString': '2025-W41', 'timeType': 'WEEK'}
✅今年10月14日酸轧纯水使用量 => {'indicator': '酸轧纯水使用量', 'timeString': '2025-10-14', 'timeType': 'DAY'}
✅本周 => {'indicator': None, 'timeString': '2025-W42', 'timeType': 'WEEK'}
✅上周的吨钢用水量 => {'indicator': '吨钢用水量', 'timeString': '2025-W41', 'timeType': 'WEEK'}
✅昨天早班的热轧蒸汽消耗 => {'indicator': '热轧蒸汽消耗', 'timeString': '2025-10-15 早班', 'timeType': 'SHIFT'}
✅明天凌晨2点的轧制水耗 => {'indicator': '轧制水耗', 'timeString': '2025-10-17 02', 'timeType': 'HOUR'}
✅去年12月份的吨钢用水量 => {'indicator': '吨钢用水量', 'timeString': '2024-12', 'timeType': 'MONTH'}
✅2025年第4季度纯水损失率 => {'indicator': '纯水损失率', 'timeString': '2025 Q4', 'timeType': 'QUARTER'}
✅2025年10月上旬热轧蒸汽消耗 => {'indicator': '热轧蒸汽消耗', 'timeString': '2025-10 上旬', 'timeType': 'TENDAYS'}
✅今天的高炉工序能耗是多少 => {'indicator': '高炉工序能耗', 'timeString': '2025-10-16', 'timeType': 'DAY'}
✅高炉今天的工序能耗是多少 => {'indicator': '高炉工序能耗', 'timeString': '2025-10-16', 'timeType': 'DAY'}
✅本月累计的高炉工序能耗是多少 => {'indicator': '高炉工序能耗累计', 'timeString': '2025-10', 'timeType': 'MONTH'}
✅1号高炉昨天的工序能耗是多少 => {'indicator': '1号高炉工序能耗', 'timeString': '2025-10-15', 'timeType': 'DAY'}
✅去年今天的高炉工序能耗是多少 => {'indicator': '高炉工序能耗', 'timeString': '2024-10-16', 'timeType': 'DAY'}
✅2021年10月23日的1高炉工序能耗是多少 => {'indicator': '1高炉工序能耗', 'timeString': '2021-10-23', 'timeType': 'DAY'}
✅2023年10月22日的2高炉工序能耗是多少 => {'indicator': '2高炉工序能耗', 'timeString': '2023-10-22', 'timeType': 'DAY'}
✅时间：2021-10-23，1高炉工序能耗是多少 => {'indicator': '1高炉工序能耗', 'timeString': '2021-10-23', 'timeType': 'DAY'}
✅高炉工序能耗是多少 => {'indicator': '高炉工序能耗', 'timeString': None, 'timeType': None}
本月1、2号高炉工序能耗是多少 => {'indicator': '高炉工序能耗', 'timeString': '2025-10', 'timeType': 'MONTH'}
✅高炉工序能耗本月计划是多少 => {'indicator': '高炉工序能耗计划', 'timeString': '2025-10', 'timeType': 'MONTH'}
✅本月高炉工序能耗的计划值是多少 => {'indicator': '高炉工序能耗计划值', 'timeString': '2025-10', 'timeType': 'MONTH'}
✅本月的高炉电耗是多少 => {'indicator': '高炉电耗', 'timeString': '2025-10', 'timeType': 'MONTH'}
✅本月的高炉电使用量是多少 => {'indicator': '高炉电使用量', 'timeString': '2025-10', 'timeType': 'MONTH'}
✅高炉的煤气耗是多少 => {'indicator': '高炉的煤气耗', 'timeString': None, 'timeType': None}
✅10号高炉今天的工序能耗是多少 => {'indicator': '10号高炉工序能耗', 'timeString': '2025-10-16', 'timeType': 'DAY'}
✅今年累计的冷轧蒸汽消耗是多少 => {'indicator': '冷轧蒸汽消耗累计', 'timeString': '2025', 'timeType': 'YEAR'}
✅前天晚班的吨钢用水量 => {'indicator': '吨钢用水量', 'timeString': '2025-10-14 晚班', 'timeType': 'SHIFT'}
```

**结论：**

除了涉及到询问多个指标的操作，其它用例都能正常表达，在多次测试的结果上表现也很稳定。

**满足下一步开发（精确匹配公式和能源接口调用）的条件**。

### 5、流程编排

#### 🔹 1. 能源接口调用

代码如下：

```
import aiohttp
import asyncio
import time
import hashlib
from config import (
    TENANT_NAME, APP_KEY, APP_SECRET, USER_NAME,
    LOGIN_URL, QUERY_URL, TOKEN_EXPIRE_DURATION
)

_cached_token = None
_token_timestamp = 0


def md5_upper(source: str) -> str:
    """MD5 加密并转大写"""
    return hashlib.md5(source.encode("utf-8")).hexdigest().upper()


async def _get_token():
    """
    获取或刷新 token（缓存 TOKEN_EXPIRE_DURATION）
    """
    global _cached_token, _token_timestamp
    now = time.time()

    # 若缓存未过期则直接返回
    if _cached_token and (now - _token_timestamp) < TOKEN_EXPIRE_DURATION.total_seconds():
        return _cached_token

    # 生成加密签名
    ts = int(now * 1000)
    enc_source = f"{TENANT_NAME}:{APP_KEY}:{USER_NAME}:{ts}:{APP_SECRET}"
    enc = md5_upper(enc_source)

    body = {
        "appId": APP_KEY,
        "userName": USER_NAME,
        "tenancyName": TENANT_NAME,
        "timestamp": ts,
        "enc": enc
    }

    async with aiohttp.ClientSession() as session:
        async with session.post(LOGIN_URL, json=body) as resp:
            resp.raise_for_status()
            data = await resp.json()
            print("🟢 登录返回：", data)

            # token 位于 data.data.token
            token = (
                data.get("data", {}).get("token") or  # ✅ 正确路径
                data.get("token") or
                data.get("data")
            )

            if not token:
                raise ValueError(f"登录接口未返回有效 token: {data}")

            _cached_token = token
            _token_timestamp = now
            return token


async def query_platform(formula: str, timeString: str, timeType: str):
    """
    查询指定公式在特定时间的结果
    """
    token = await _get_token()
    headers = {
        "Authorization": f"Bearer {token}",
        "Content-Type": "application/json"
    }
    print(headers)
    payload = {
        "expressionList": {formula: formula},
        "clock": timeString,
        "timegranId": timeType
    }
    print(payload)
    async with aiohttp.ClientSession() as session:
        async with session.post(QUERY_URL, json=payload, headers=headers) as resp:
            resp.raise_for_status()
            data = await resp.json()
            print(data)
            if "data" not in data:
                raise ValueError(f"接口返回格式错误: {data}")

            return data["data"]

# === 测试入口 ===
if __name__ == "__main__":
    async def main():
        result = await query_platform("GXNHLT1100.IXRL", "2022-10-02", "DAY")
        print("查询结果：", result)

    asyncio.run(main())
```

> 现阶段只实现时间点的调用，还需要完成时间区间的调用，区间调用是

#### 🔹 2. 用户对话slots管理类

代码如下：

```
from typing import Dict, Optional, TypedDict
import time
import asyncio

SESSION_EXPIRE_SECONDS = 30 * 60  # 30分钟过期

class SlotState(TypedDict, total=False):
    indicator: Optional[str]
    formula: Optional[str]
    formula_candidates: Optional[list]
    awaiting_confirmation: bool
    timeString: Optional[str]
    timeType: Optional[str]

class SessionState(TypedDict, total=False):
    slots: SlotState
    last_active: float

conversation_state: Dict[str, SessionState] = {}
_state_lock = asyncio.Lock()

def now() -> float:
    return time.time()

async def get_state(user_id: str) -> SessionState:
    async with _state_lock:
        state = conversation_state.get(user_id)
        if not state:
            state = {
                "slots": {
                    "indicator": None,
                    "formula": None,
                    "formula_candidates": None,
                    "awaiting_confirmation": False,
                    "timeString": None,
                    "timeType": None
                },
                "last_active": now()
            }
            conversation_state[user_id] = state
        else:
            state["last_active"] = now()
        return state

async def update_state(user_id: str, new_data: dict) -> SessionState:
    async with _state_lock:
        state = conversation_state.get(user_id)
        if not state:
            state = {
                "slots": {
                    "indicator": None,
                    "formula": None,
                    "formula_candidates": None,
                    "awaiting_confirmation": False,
                    "timeString": None,
                    "timeType": None
                },
                "last_active": now()
            }
            conversation_state[user_id] = state

        for k, v in new_data.items():
            if v is not None:
                state[k] = v
        state["last_active"] = now()
        conversation_state[user_id] = state
        return state

async def cleanup_once():
    async with _state_lock:
        current = now()
        expired = [
            uid for uid, s in conversation_state.items()
            if current - s.get("last_active", 0) > SESSION_EXPIRE_SECONDS
        ]
        for uid in expired:
            del conversation_state[uid]
        return expired

async def cleanup_expired_sessions():
    while True:
        expired = await cleanup_once()
        if expired:
            print(f"[agent_state] 清理过期会话: {expired}")
        await asyncio.sleep(60)
```

#### 🔹 3. 主流程

代码如下：

```
# main.py
import os
for key in ["HTTP_PROXY", "HTTPS_PROXY", "ALL_PROXY", "http_proxy", "https_proxy", "all_proxy"]:
    os.environ.pop(key, None)

import asyncio
import time
import logging
from fastapi import FastAPI, Query, Request
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse

from agent_state import get_state, update_state, cleanup_expired_sessions
from llm_parser import parse_user_input
from tools import formula_api, platform_api

TOP_N = 5  # 显示候选数量

# ----------------------
# 初始化日志
# ----------------------
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s | %(levelname)s | %(message)s"
)
logger = logging.getLogger(__name__)

# ----------------------
# FastAPI 应用
# ----------------------
app = FastAPI(title="轻量智能体服务")
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"], allow_credentials=True, allow_methods=["*"], allow_headers=["*"]
)

# ----------------------
# 启动事件
# ----------------------
@app.on_event("startup")
async def startup_event():
    """
    在服务启动时执行：
      - 初始化公式数据（同步加载）；
      - 启动清理任务；
    """
    try:
        start = time.time()
        # 只初始化一次，不会重复加载
        formula_api.initialize()
        logger.info(f"✅ formula_api 初始化完成，用时 {time.time() - start:.2f}s")
    except Exception as e:
        logger.exception("❌ 初始化 formula_api 失败: %s", e)

    asyncio.create_task(cleanup_expired_sessions())
    logger.info("🧹 已启动 session 定期清理任务。")


# ----------------------
# GET/POST 接口
# ----------------------
@app.get("/chat")
async def chat_get(
    user_id: str = Query(..., description="用户唯一标识，例如 test1"),
    message: str = Query(..., description="用户输入内容，例如 '查询2030酸轧纯水使用量'")
):
    return await handle_chat(user_id, message)

@app.post("/chat")
async def chat_post(request: Request):
    data = await request.json()
    return await handle_chat(data.get("user_id"), data.get("message", "").strip())


# ----------------------
# 核心处理逻辑
# ----------------------
async def handle_chat(user_id: str, user_input: str):
    """
    处理与用户的对话逻辑，包括：
      1. 状态管理；
      2. 解析输入；
      3. 匹配公式；
      4. 调用平台查询；
    """
    total_start = time.time()
    logger.info(f"🟢 [handle_chat] 开始处理 user={user_id}, input={user_input!r}")

    try:
        if not user_input:
            return {"message": "请输入指标名称或时间。", "state": await get_state(user_id)}

        # Step0: 获取状态
        state = await get_state(user_id)
        state.setdefault("slots", {
            "indicator": None,
            "formula": None,
            "formula_candidates": None,
            "awaiting_confirmation": False,
            "timeString": None,
            "timeType": None
        })
        slots = state["slots"]
        logger.info(f"✅ 当前 slots: {slots}")

        # Step1️⃣ 若当前存在候选公式且输入为数字 => 直接选择并执行查询（跳过 LLM）
        if slots.get("formula_candidates") and user_input.isdigit():
            idx = int(user_input.strip()) - 1
            candidates = slots["formula_candidates"]

            if 0 <= idx < len(candidates):
                chosen = candidates[idx]
                slots["formula"] = chosen["FORMULAID"]
                slots["indicator"] = chosen["FORMULANAME"]
                slots["formula_candidates"] = None
                slots["awaiting_confirmation"] = False
                await update_state(user_id, state)
                logger.info(f"✅ 用户选择公式编号 {idx+1}: {chosen['FORMULANAME']}")

                # 若没有时间信息，则提示补全时间
                if not (slots.get("timeString") and slots.get("timeType")):
                    return {"message": f"好的，要查【{slots['indicator']}】，请告诉我时间。", "state": state}

                # ✅ 直接调用平台查询，不再经过 llm_parser
                t1 = time.time()
                result = await platform_api.query_platform(
                    formula=slots["formula"],
                    timeString=slots["timeString"],
                    timeType=slots["timeType"]
                )
                logger.info(f"✅ platform_api.query_platform 用时 {time.time() - t1:.2f}s, result={result}")

                reply_lines = [
                    f"✅ 指标: {slots['indicator']}",
                    f"公式编码: {slots['formula']}",
                    f"时间: {slots['timeString']} ({slots['timeType']})",
                    f"结果: {result.get(slots['formula'])} {result.get('unit', '')}"
                ]

                # 清空状态
                state["slots"] = {
                    "indicator": None,
                    "formula": None,
                    "formula_candidates": None,
                    "awaiting_confirmation": False,
                    "timeString": None,
                    "timeType": None
                }
                await update_state(user_id, state)
                logger.info(f"✅ handle_chat 全流程完成，用时 {time.time() - total_start:.2f}s")
                return JSONResponse(content={"message": "\n".join(reply_lines), "state": state})

            else:
                return {"message": f"请输入编号 1-{len(candidates)} 选择公式。", "state": state}

        # Step2️⃣ 若存在候选但输入不是数字 => 清空候选重新解析
        if slots.get("formula_candidates"):
            logger.info("🧩 非数字输入，清空候选列表并重新解析输入。")
            slots["formula_candidates"] = None
            slots["formula"] = None
            await update_state(user_id, state)

        # Step3️⃣ 正常调用 llm_parser 解析
        parsed = await parse_user_input(user_input)
        logger.info(f"🔍 LLM 解析结果: {parsed}")

        # 合并 slots（仅补全缺失信息，不覆盖已有）
        for key in ["indicator", "timeString", "timeType"]:
            if parsed.get(key):
                slots[key] = parsed[key]
        await update_state(user_id, state)

        # Step4️⃣ 若 indicator 缺失
        if not slots.get("indicator"):
            return {"message": "请告诉我您要查询的指标名称。", "state": state}

        # Step5️⃣ 调用 formula_api 匹配公式
        if not slots.get("formula") and slots.get("indicator"):
            t0 = time.time()
            formula_resp = await asyncio.to_thread(formula_api.formula_query_dict, slots["indicator"])
            logger.info(f"✅ formula_api.formula_query_dict 用时 {time.time() - t0:.2f}s")

            if formula_resp.get("done"):
                slots["formula"] = formula_resp["exact_matches"][0]["FORMULAID"]
                slots["indicator"] = formula_resp["exact_matches"][0]["FORMULANAME"]
                await update_state(user_id, state)
                logger.info(f"✅ 精确匹配公式: {slots['indicator']}")
            else:
                candidates = formula_resp.get("candidates", [])
                if candidates:
                    # 🆕 新增逻辑：如果第一个候选评分大于100，直接选择
                    if candidates[0].get('score', 0) > 100:
                        chosen = candidates[0]
                        slots["formula"] = chosen["FORMULAID"]
                        slots["indicator"] = chosen["FORMULANAME"]
                        slots["formula_candidates"] = None
                        await update_state(user_id, state)
                        logger.info(f"✅ 自动选择高分候选公式: {chosen['FORMULANAME']} (score: {chosen.get('score', 0)})")
                        
                        # 🆕 检查时间信息是否完整
                        if not (slots.get("timeString") and slots.get("timeType")):
                            return {"message": f"好的，要查【{slots['indicator']}】，请告诉我时间。", "state": state}
                        
                        # 🆕 直接调用平台查询
                        t1 = time.time()
                        result = await platform_api.query_platform(
                            formula=slots["formula"],
                            timeString=slots["timeString"],
                            timeType=slots["timeType"]
                        )
                        logger.info(f"✅ platform_api.query_platform 用时 {time.time() - t1:.2f}s, result={result}")
                        
                        reply_lines = [
                            f"✅ 指标: {slots['indicator']}",
                            f"公式编码: {slots['formula']}",
                            f"时间: {slots['timeString']} ({slots['timeType']})",
                            f"结果: {result.get(slots['formula'])} {result.get('unit', '')}"
                        ]
                        
                        # 🆕 清空状态
                        state["slots"] = {
                            "indicator": None,
                            "formula": None,
                            "formula_candidates": None,
                            "awaiting_confirmation": False,
                            "timeString": None,
                            "timeType": None
                        }
                        await update_state(user_id, state)
                        logger.info(f"✅ handle_chat 全流程完成，用时 {time.time() - total_start:.2f}s")
                        return JSONResponse(content={"message": "\n".join(reply_lines), "state": state})
                    
                    # 原有逻辑：显示候选列表供用户选择
                    slots["formula_candidates"] = candidates[:TOP_N]
                    await update_state(user_id, state)
                    msg_lines = ["请从以下候选公式选择编号："]
                    for c in candidates[:TOP_N]:
                        msg_lines.append(f"{c['number']}) {c['FORMULANAME']} (score {c.get('score', 0):.2f})")
                    return {"message": "\n".join(msg_lines), "state": state}
                else:
                    return {"message": "未找到匹配公式，请重新输入指标名称。", "state": state}

        # Step6️⃣ 检查时间信息
        if not (slots.get("timeString") and slots.get("timeType")):
            return {"message": f"好的，要查【{slots['indicator']}】，请告诉我时间。", "state": state}

        # Step7️⃣ 调用平台接口
        t1 = time.time()
        result = await platform_api.query_platform(
            formula=slots["formula"],
            timeString=slots["timeString"],
            timeType=slots["timeType"]
        )
        logger.info(f"✅ platform_api.query_platform 用时 {time.time() - t1:.2f}s, result={result}")

        reply_lines = [
            f"✅ 指标: {slots['indicator']}",
            f"公式编码: {slots['formula']}",
            f"时间: {slots['timeString']} ({slots['timeType']})",
            f"结果: {result.get(slots['formula'])} {result.get('unit', '')}"
        ]

        # Step8️⃣ 清空 slots
        state["slots"] = {
            "indicator": None,
            "formula": None,
            "formula_candidates": None,
            "awaiting_confirmation": False,
            "timeString": None,
            "timeType": None
        }
        await update_state(user_id, state)
        logger.info(f"✅ handle_chat 全流程完成，用时 {time.time() - total_start:.2f}s")

        return JSONResponse(content={"message": "\n".join(reply_lines), "state": state})

    except Exception as e:
        logger.exception("❌ handle_chat 异常: %s", e)
        return JSONResponse(content={"error": str(e), "state": await get_state(user_id)}, status_code=500)
```

#### 🔹 4. 效果展示

![image-20251022154408761](%E8%83%BD%E6%BA%90%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%B9%B3%E5%8F%B0%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF%E5%8F%8A%E5%AE%9E%E7%8E%B0.assets/image-20251022154408761.png)

![image-20251022154426579](%E8%83%BD%E6%BA%90%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%B9%B3%E5%8F%B0%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF%E5%8F%8A%E5%AE%9E%E7%8E%B0.assets/image-20251022154426579.png)

#### 🔹 5. 遗留问题

* 现在实现时间点的形式，需要实现时间区间的识别和接口调用，比如：高炉1月到3月的能耗。
* 相同指标多时间，或者相同时间多指标的识别，属于批量识别，为智能分析做准备。

## 6.9 区间问数

只需要扩展 `query_platform` 函数以支持「**时间点查询**」与「**时间区间查询**」两种模式即可。
 下面是我帮你完整改写后的版本，包括：

- ✅ 支持区间接口调用（`CalcRangeValuesAsync`）
- ✅ 保留原有单点接口调用（`QueryItemValuesAsync`）
- ✅ 自动根据参数 timeString是否包含`～` 判断使用哪个接口
- ✅ 保留 token 缓存与自动刷新逻辑
- ✅ 更优雅的配置和调试输出

**判断是否为区间查询**的唯一标准是 `timeString` 是否包含 `"～"`（或 `"~"`），而 **`timeType` 不能因此被改动**，必须保留原来的值（例如 DAY、MONTH、SHIFT 等）。

platform_api.py代码如下所示：

```
import aiohttp
import asyncio
import time
import hashlib
from config import (
    TENANT_NAME, APP_KEY, APP_SECRET, USER_NAME,
    LOGIN_URL, QUERY_URL, RANGE_QUERY_URL, TOKEN_EXPIRE_DURATION
)

_cached_token = None
_token_timestamp = 0


def md5_upper(source: str) -> str:
    """MD5 加密并转大写"""
    return hashlib.md5(source.encode("utf-8")).hexdigest().upper()


async def _get_token():
    """
    获取或刷新 token（缓存 TOKEN_EXPIRE_DURATION 时间）
    """
    global _cached_token, _token_timestamp
    now = time.time()

    # 若缓存未过期则直接返回
    if _cached_token and (now - _token_timestamp) < TOKEN_EXPIRE_DURATION.total_seconds():
        return _cached_token

    # 生成加密签名
    ts = int(now * 1000)
    enc_source = f"{TENANT_NAME}:{APP_KEY}:{USER_NAME}:{ts}:{APP_SECRET}"
    enc = md5_upper(enc_source)

    body = {
        "appId": APP_KEY,
        "userName": USER_NAME,
        "tenancyName": TENANT_NAME,
        "timestamp": ts,
        "enc": enc
    }

    async with aiohttp.ClientSession() as session:
        async with session.post(LOGIN_URL, json=body) as resp:
            resp.raise_for_status()
            data = await resp.json()
            print("🟢 登录返回：", data)

            # token 位于 data.data.token
            token = (
                data.get("data", {}).get("token") or  # ✅ 正确路径
                data.get("token") or
                data.get("data")
            )

            if not token:
                raise ValueError(f"登录接口未返回有效 token: {data}")

            _cached_token = token
            _token_timestamp = now
            return token


def is_range_query(time_string: str) -> bool:
    """判断是否为区间时间格式（包含 ～ 或 ~）"""
    if not time_string:
        return False
    return any(sym in time_string for sym in ["～", "~"])


async def query_platform(formula: str, timeString: str, timeType: str):
    """
    智能判断查询类型：
    - 若 timeString 含 “～” 或 “~” => 调区间接口 RANGE_QUERY_URL
    - 否则 => 调单点接口 QUERY_URL
    - timeType 始终原样透传
    """

    token = await _get_token()
    headers = {
        "Authorization": f"Bearer {token}",
        "Content-Type": "application/json"
    }

    if is_range_query(timeString):
        # 区间查询: 例如 "2024-09-01~2024-09-07"
        start_date, end_date = [x.strip() for x in timeString.replace("～", "~").split("~", 1)]

        payload = {
            "startClock": start_date,
            "endClock": end_date,
            "formulas": {formula: formula},
            "timeGranId": timeType  # ✅ 传入原始 timeType，不强制改成 DAY
        }
        url = RANGE_QUERY_URL
    else:
        # 单点查询
        payload = {
            "expressionList": {formula: formula},
            "clock": timeString,
            "timegranId": timeType
        }
        url = QUERY_URL

    print(f"🟡 调用接口: {url}")
    print(f"🧩 请求参数: {payload}")

    async with aiohttp.ClientSession() as session:
        async with session.post(url, json=payload, headers=headers) as resp:
            resp.raise_for_status()
            data = await resp.json()
            print("🟢 返回数据:", data)

            if "data" not in data:
                raise ValueError(f"接口返回格式错误: {data}")

            return data["data"]


# === 测试入口 ===
if __name__ == "__main__":
    async def main():
        # 单点查询示例
        result1 = await query_platform("GXNHLT1100.IXRL", "2022-10-02", "DAY")
        print("📍 单点查询结果：", result1)

        # 区间查询示例
        result2 = await query_platform("GXNHLT1100.IXRL", "2022-09-01~2022-09-07", "DAY")
        print("📅 区间查询结果：", result2)

        # 区间查询示例2
        result3 = await query_platform("GXNHLT1100.IXRL", "2022-09~2022-10", "MONTH")
        print("📅 区间查询结果：", result3)

    asyncio.run(main())
```

测试结果如下：

```
(myenv) fusionshen@fusionshen-ThinkPad-T14-Gen-1:~/Desktop/LLM/ask_agent$ python -m tools.platform_api
🟢 登录返回： {'error': None, 'data': {'token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1aWQiOiIxNDMiLCJ0ZW5hbnRpZCI6IjEwNSIsInVuYW1lIjoi566h55CG5ZGYIiwidG5hbWUiOiLlrp3pkqLmuZvmsZ_pkqLpk4HmnInpmZDlhazlj7giLCJ0c2lkZSI6IjEiLCJncm91cGlkIjoiMCIsInNsaWRpbmciOiIwIiwicnNpbmNlIjoiMTc2MTY5NjExMCIsIm5iZiI6MTc2MTU1MTgxMCwiZXhwIjoxNzYxNjY3NjEwLCJpc3MiOiJzaGJhb25lbmciLCJhdWQiOiJzaGJhb25lbmcifQ.TTfEul05oY4kqKwAShjBwMVr3oNvyTKUx51Rx770FQ4', 'expiresAt': '2025-10-29 00:05:50', 'tenantId': 105, 'tenancyName': 'zjis', 'userId': 143, 'userName': 'admin'}, 'status': 200, 'msg': '操作成功', 'duration': -1}
🟡 调用接口: http://www.shbaoenergy.com:8081/emscore/api/services/nYMC/calcData/QueryItemValuesAsync
🧩 请求参数: {'expressionList': {'GXNHLT1100.IXRL': 'GXNHLT1100.IXRL'}, 'clock': '2022-10-02', 'timegranId': 'DAY'}
🟢 返回数据: {'error': None, 'data': {'GXNHLT1100.IXRL': '374.41'}, 'status': 200, 'msg': '操作成功', 'duration': -1}
📍 单点查询结果： {'GXNHLT1100.IXRL': '374.41'}
🟡 调用接口: http://www.shbaoenergy.com:8081/emscore/api/services/nYMC/calcData/CalcRangeValuesAsync
🧩 请求参数: {'startClock': '2022-09-01', 'endClock': '2022-09-07', 'formulas': {'GXNHLT1100.IXRL': 'GXNHLT1100.IXRL'}, 'timeGranId': 'DAY'}
🟢 返回数据: {'error': None, 'data': [{'itemId': 'GXNHLT1100.IXRL', 'itemValue': '378.5', 'clock': '2022-09-01', 'timeGranId': 'DAY'}, {'itemId': 'GXNHLT1100.IXRL', 'itemValue': '380.28', 'clock': '2022-09-02', 'timeGranId': 'DAY'}, {'itemId': 'GXNHLT1100.IXRL', 'itemValue': '376.39', 'clock': '2022-09-03', 'timeGranId': 'DAY'}, {'itemId': 'GXNHLT1100.IXRL', 'itemValue': '376.09', 'clock': '2022-09-04', 'timeGranId': 'DAY'}, {'itemId': 'GXNHLT1100.IXRL', 'itemValue': '377.16', 'clock': '2022-09-05', 'timeGranId': 'DAY'}, {'itemId': 'GXNHLT1100.IXRL', 'itemValue': '380.35', 'clock': '2022-09-06', 'timeGranId': 'DAY'}, {'itemId': 'GXNHLT1100.IXRL', 'itemValue': '373.93', 'clock': '2022-09-07', 'timeGranId': 'DAY'}], 'status': 200, 'msg': '操作成功', 'duration': -1}
📅 区间查询结果： [{'itemId': 'GXNHLT1100.IXRL', 'itemValue': '378.5', 'clock': '2022-09-01', 'timeGranId': 'DAY'}, {'itemId': 'GXNHLT1100.IXRL', 'itemValue': '380.28', 'clock': '2022-09-02', 'timeGranId': 'DAY'}, {'itemId': 'GXNHLT1100.IXRL', 'itemValue': '376.39', 'clock': '2022-09-03', 'timeGranId': 'DAY'}, {'itemId': 'GXNHLT1100.IXRL', 'itemValue': '376.09', 'clock': '2022-09-04', 'timeGranId': 'DAY'}, {'itemId': 'GXNHLT1100.IXRL', 'itemValue': '377.16', 'clock': '2022-09-05', 'timeGranId': 'DAY'}, {'itemId': 'GXNHLT1100.IXRL', 'itemValue': '380.35', 'clock': '2022-09-06', 'timeGranId': 'DAY'}, {'itemId': 'GXNHLT1100.IXRL', 'itemValue': '373.93', 'clock': '2022-09-07', 'timeGranId': 'DAY'}]
🟡 调用接口: http://www.shbaoenergy.com:8081/emscore/api/services/nYMC/calcData/CalcRangeValuesAsync
🧩 请求参数: {'startClock': '2022-09', 'endClock': '2022-10', 'formulas': {'GXNHLT1100.IXRL': 'GXNHLT1100.IXRL'}, 'timeGranId': 'MONTH'}
🟢 返回数据: {'error': None, 'data': [{'itemId': 'GXNHLT1100.IXRL', 'itemValue': '0', 'clock': '2022-09', 'timeGranId': 'MONTH'}, {'itemId': 'GXNHLT1100.IXRL', 'itemValue': '1', 'clock': '2022-10', 'timeGranId': 'MONTH'}], 'status': 200, 'msg': '操作成功', 'duration': -1}
📅 区间查询结果： [{'itemId': 'GXNHLT1100.IXRL', 'itemValue': '0', 'clock': '2022-09', 'timeGranId': 'MONTH'}, {'itemId': 'GXNHLT1100.IXRL', 'itemValue': '1', 'clock': '2022-10', 'timeGranId': 'MONTH'}]
```

llm_parser.py代码如下：

```
import os
for key in ["HTTP_PROXY", "HTTPS_PROXY", "ALL_PROXY", "http_proxy", "https_proxy", "all_proxy"]:
    os.environ.pop(key, None)

import asyncio
import re
import json
import httpx
from datetime import datetime, timedelta

# ===================== ChatOllama 兼容导入 =====================
try:
    from langchain_ollama import ChatOllama
    print("✅ Using ChatOllama from langchain-ollama")
except ImportError:
    try:
        from langchain_community.chat_models import ChatOllama
        print("✅ Using ChatOllama from langchain_community")
    except ImportError:
        from langchain.chat_models import ChatOllama
        print("⚠️ Using ChatOllama from old langchain (may be deprecated)")

from langchain.schema import HumanMessage

# ===================== 模型优先级定义 =====================
REMOTE_OLLAMA_URL = "http://192.168.92.13:11434"  # ← 修改为你的远程 Ollama 地址
REMOTE_MODEL = "gemma3:27b"
LOCAL_MODEL = "qwen2.5:1.5b"


async def is_remote_ollama_available(base_url: str, timeout: float = 3.0) -> bool:
    """
    检查远程 Ollama 服务是否可访问。
    """
    try:
        async with httpx.AsyncClient(timeout=timeout) as client:
            resp = await client.get(f"{base_url}/api/tags")
            if resp.status_code == 200:
                #print(f"🌐 Remote Ollama available at {base_url}")
                return True
    except Exception as e:
        print(f"⚠️ Remote Ollama not reachable: {e}")
    return False


async def get_llm() -> ChatOllama:
    """
    优先使用远程 gemma3:27b，如果远程不可用则回退到本地 qwen2.5:1.5b。
    """
    if await is_remote_ollama_available(REMOTE_OLLAMA_URL):
        #print(f"✅ Using remote model: {REMOTE_MODEL}")
        return ChatOllama(model=REMOTE_MODEL, base_url=REMOTE_OLLAMA_URL)
    else:
        print(f"🔄 Falling back to local model: {LOCAL_MODEL}")
        return ChatOllama(model=LOCAL_MODEL)

"""
在无示例情况下，如果大模型精度差强人意，可以将示例插入prompt的[注意]和[用户输入："{user_input}"]之间，但是无法避免LLM直接拿来编
示例：
输入："查询今年的3030连退纯水使用量"
输出：{{"indicator":"3030连退纯水使用量","timeString":"{now.year}","timeType":"YEAR"}}

输入："今天的连退纯水使用量"
输出：{{"indicator":"连退纯水使用量","timeString":"{now.strftime('%Y-%m-%d')}","timeType":"DAY"}}

输入："今天"
输出：{{"indicator":null,"timeString":"{now.strftime('%Y-%m-%d')}","timeType":"DAY"}}

输入："冷轧蒸汽消耗"
输出：{{"indicator":"冷轧蒸汽消耗","timeString":null,"timeType":null}}

输入："8月份冷轧蒸汽消耗"
输出：{{"indicator":"冷轧蒸汽消耗","timeString":"{now.year}-08","timeType":"MONTH"}}

输入："2024年第31周纯水损失率"
输出：{{"indicator":"纯水损失率","timeString":"2024-W31","timeType":"WEEK"}}

输入："2017年第1季度纯水损失率"
输出：{{"indicator":"纯水损失率","timeString":"2017 Q1","timeType":"QUARTER"}}

输入："2019年8月下旬冷轧蒸汽消耗"
输出：{{"indicator":"冷轧蒸汽消耗","timeString":"2019-08 下旬","timeType":"TENDAYS"}}

输入："前天晚班的冷轧蒸汽消耗"
输出：{{"indicator":"冷轧蒸汽消耗","timeString":"{(now - timedelta(days=2)).strftime('%Y-%m-%d')} 晚班","timeType":"SHIFT"}}

输入："下周的吨钢用水量"
输出：{{"indicator":"吨钢用水量","timeString":"{(now + timedelta(weeks=1)).isocalendar()[0]} W{(now + timedelta(weeks=1)).isocalendar()[1]}","timeType":"WEEK"}}

输入："今年10月14日酸轧纯水使用量"
输出：{{"indicator":"酸轧纯水使用量","timeString":"2025-10-14","timeType":"DAY"}}
"""

# ===================== 主解析函数 =====================
async def parse_user_input(user_input: str, now: datetime = None):
    if now is None:
        now = datetime.now()
    now_str = now.strftime("%Y-%m-%d %H:%M")

    prompt = f"""
你是一个智能解析助手，用于从用户输入中提取“指标名称”和“时间信息”。
当前系统时间为：{now_str}。

请严格输出 JSON：
{{
  "indicator": "...",
  "timeString": "...",
  "timeType": "..."
}}

要求：
1. indicator 必须保留原文，包括数字和文字，不要丢失任何信息。
   - 如果数字紧跟在指标词中（如“2030酸轧纯水使用量”、“3030连退纯水使用量”），则视为指标一部分，而非时间。
   - 只有当数字后面带有“年”“月份”“月”“周”“季度”“日”等时间修饰词时，才视为时间。
   - 不要因为指标中包含数字就将其误判为时间。
   - 如果能够明确用户输入就是指明时间点或者时间区间，indicator 就设为null(如“第四周”、“今年三月份”、“2022年5月20日”, “今年一月到五月”, "上半年")。
   - 指标中可能包含描述性质的后缀词（如“累计”、“计划”、“目标”、“完成值”、“用量”、“指标”、“成本”、“效率”、“总量”、“单耗”、“强度”等），
     这些词均属于指标的一部分，必须保留在 indicator 中，不得截断。

2. timeString 必须根据 timeType 精确格式化：
   - HOUR → "YYYY-MM-DD HH"
   - SHIFT → "YYYY-MM-DD 早班/白班/夜班"
     - “早班”、“白班”、“夜班”、“中班”、“晚班” 都属于 SHIFT 类型。
     - 班次优先级高于 HOUR。即如果句中出现“早班/白班/夜班”，无论是否同时出现“几点”，都按 SHIFT 解析。
     - 日期计算规则与 DAY 相同：  
       “昨天早班” → (now - timedelta(days=1)).strftime("%Y-%m-%d") + " 早班"
       “今天白班” → now.strftime("%Y-%m-%d") + " 白班"
       “明天夜班” → (now + timedelta(days=1)).strftime("%Y-%m-%d") + " 夜班"
   - DAY → "YYYY-MM-DD"
     - “去年今天”、“前年昨天” 都属于 DAY 类型，并基于当前时间 {now_str} 推算。
   - WEEK → "YYYY W##"
     - 使用 ISO 标准周号（周一为一周开始）。
     - “本周” 表示当前日期所在周号： now.isocalendar().week
     - “上周” 表示前一周： (now - timedelta(weeks=1)).isocalendar().week
     - “下周” 表示后一周： (now + timedelta(weeks=1)).isocalendar().week
     - 年份应对应该周的 ISO 年份： now.isocalendar().year
   - MONTH → "YYYY-MM"
     - 如果输入中只出现月份（如“8月份”、“9月”），则补上当前年份，例如："2025-08"
     - 如果出现“去年8月份”，则使用去年年份："2024-08"
     - 如果出现“明年3月份”，则使用明年年份："2026-03"
     - 如果出现“上个月”，则使用使用今年年份："2025-09"（假如这个月是2025年10月份）
     - 如果输入中出现“月”后跟“日”，例如“10月14日”，则优先判断为 DAY：
       输出格式：{{"timeString":"YYYY-MM-DD","timeType":"DAY"}}
   - QUARTER → "YYYY Q#"
   - TENDAYS → "YYYY-MM 上旬/中旬/下旬"
   - YEAR → "YYYY"
   若无法推算则为 null。

3. timeType 必须是以下之一：
   ["HOUR","SHIFT","DAY","WEEK","MONTH","QUARTER","TENDAYS","YEAR"]
   若无法判断则为 null。

4. 支持相对时间（今天、昨天、上周、上月、今年、去年等），并基于当前时间 {now_str} 推算。

5. 你还需要支持区间时间表达，例如：
   - "10月1日到10月7日的吨钢蒸汽消耗"
   - "2024-09-01~2024-09-07纯水损失率"
   - "从上周到本周的高炉能耗"
   - "今年1月到3月吨钢用水量"
   在这种情况下：
   - indicator 不变；
   - timeString 统一输出为 "开始时间~结束时间"；
   - timeType 保持最合适的时间粒度（如 DAY、WEEK、MONTH、YEAR）。

此外，还要支持“模糊区间表达”，即未明确出现‘到’、‘至’、‘~’但语义上表示区间的时间短语。
包括但不限于：
- “一月到三月”、“1月至3月”、“1-3月” → 当年区间 "2025-01~2025-03"
- “去年一月到三月” → 去年区间 "2024-01~2024-03"
- “上半年” → 当年上半年 "2025-01~2025-06"
- “下半年” → 当年下半年 "2025-07~2025-12"
这些模糊区间：
1. 也必须以“开始~结束”输出；
2. timeType 通常为 MONTH；
3. 若出现“去年/明年”，则调整年份。

请严格输出 JSON, 添加多余文字、解释或注释。

注意：
- “indicator” 必须只包含指标名称，不包含时间相关词（如“今年”、“9月份”、“昨天”、“上周”、“第3季度”等）。
- 指标中若包含性质修饰（如“累计”、“计划”、“目标”、“用量”、“成本”、“效率”等），必须保留。
  例如：
  - “本月累计的高炉工序能耗是多少” → indicator="高炉工序能耗累计"
  - “高炉工序能耗本月计划是多少” → indicator="高炉工序能耗计划"
  - “去年12月吨钢蒸汽成本” → indicator="吨钢蒸汽成本"
  - “明年目标纯水损失率” → indicator="目标纯水损失率"
  - “2022年2月3日” → indicator=null
- 班次词（早班、白班、夜班、中班、晚班）属于时间，不属于指标。
- SHIFT 类型优先于 HOUR：不要将“早班”错误地转化为具体小时。
- 若原文不包含时间或者无法推算出时间，不要私自赋予时间，保持null即可。
- 只有明确确认描述的是时间区间才使用区间方式，否则一律使用时间点方式
  例如：
  - “今年累计的” → indicator=null、timeString="2025"、timeType="YEAR"
  - “上周的” → indicator=null、timeString="2025 W42"、timeType="WEEK"
- 区间是同时识别两个时间，中间用“~”拼接作为timeString，timeType严格执行前面提到的规则
  例如：
  - “一月到三月的吨钢蒸汽消耗” → indicator="吨钢蒸汽消耗"、timeString="2025-01~2025-03"、timeType="MONTH"
  - “上半年高炉计划” → indicator="高炉计划"、timeString="2025-01~2025-06"、timeType="MONTH"
  - "2023年上半年" → indicator=null、timeString="2023-01~2023-06"、timeType="MONTH"


用户输入："{user_input}"
"""

    llm = await get_llm()

    try:
        resp = await llm.agenerate([[HumanMessage(content=prompt)]])
        content = resp.generations[0][0].message.content.strip()
    except Exception as e:
        print("❌ LLM 调用失败:", e)
        return {"indicator": None, "timeString": None, "timeType": None}

    try:
        result = json.loads(content)
    except json.JSONDecodeError:
        result = {
            "indicator": re.search(r'"indicator"\s*:\s*"([^"]*)"', content).group(1) if re.search(r'"indicator"\s*:\s*"([^"]*)"', content) else None,
            "timeString": re.search(r'"timeString"\s*:\s*"([^"]*)"', content).group(1) if re.search(r'"timeString"\s*:\s*"([^"]*)"', content) else None,
            "timeType": re.search(r'"timeType"\s*:\s*"([^"]*)"', content).group(1) if re.search(r'"timeType"\s*:\s*"([^"]*)"', content) else None
        }

    indicator = result.get("indicator")
    timeString = result.get("timeString")
    timeType = result.get("timeType")

    
    if indicator:
        indicator = re.sub(r'^(今天|昨天|明天|本周|上周|下周|上月|本月|今年|去年)\s*的?', '', indicator)
        indicator = re.sub(r'\s*(今天|昨天|明天|本周|上周|下周|上月|本月|今年|去年)$', '', indicator)
        indicator = indicator.strip() or None

    return {"indicator": indicator, "timeString": timeString, "timeType": timeType}


# ===================== 测试 =====================
if __name__ == "__main__":
    import nest_asyncio
    nest_asyncio.apply()
    loop = asyncio.get_event_loop()
    now = datetime(2025, 10, 16, 14, 0)

    test_inputs = [
        "2023上半年",
        "2023年上半年",
        "一月到三月的吨钢蒸汽消耗",
        "去年一月到8月吨钢用水量",
        "去年一、二月吨钢用水量",
        "上半年计划",
        "下半年纯水消耗",
        "2024年9月1日到9月7日高炉能耗",
        "今天的连退纯水使用量",
        "2022年10月2日",
        "450酸轧纯水使用量",
        "查询今年的2030酸轧纯水使用量",
        "今天的酸轧纯水使用量",
        "9月份热轧蒸汽消耗",
        "酸轧纯水使用量",
        "昨天",
        "2025年第41周纯水损失率",
        "今年10月14日酸轧纯水使用量",
        "本周",
        "上周的吨钢用水量",
        "昨天早班的热轧蒸汽消耗",
        "明天凌晨2点的轧制水耗",
        "去年12月份的吨钢用水量",
        "2025年第4季度纯水损失率",
        "2025年10月上旬热轧蒸汽消耗",
        "今天的高炉工序能耗是多少",
        "高炉今天的工序能耗是多少",
        "本月累计的高炉工序能耗是多少",
        "1号高炉昨天的工序能耗是多少",
        "去年今天的高炉工序能耗是多少",
        "2021年10月23日的1高炉工序能耗是多少",
        "2023年10月22日的2高炉工序能耗是多少",
        "时间：2021-10-23，1高炉工序能耗是多少",
        "高炉工序能耗是多少",
        "本月1、2号高炉工序能耗是多少",
        "高炉工序能耗本月计划是多少",
        "本月高炉工序能耗的计划值是多少",
        "本月的高炉电耗是多少",
        "本月的高炉电使用量是多少",
        "高炉的煤气耗是多少",
        "10号高炉今天的工序能耗是多少",
        "今年累计的冷轧蒸汽消耗是多少",
        "前天晚班的吨钢用水量"
    ]

    for ti in test_inputs:
        result = loop.run_until_complete(parse_user_input(ti))
        print(f"{ti} => {result}")

```

测试结果如下：

```
(myenv) fusionshen@fusionshen-ThinkPad-T14-Gen-1:~/Desktop/LLM/ask_agent$ python llm_parser.py 
✅ Using ChatOllama from langchain-ollama
2023上半年 => {'indicator': None, 'timeString': '2023-01~2023-06', 'timeType': 'MONTH'}
2023年上半年 => {'indicator': None, 'timeString': '2023-01~2023-06', 'timeType': 'MONTH'}
一月到三月的吨钢蒸汽消耗 => {'indicator': '吨钢蒸汽消耗', 'timeString': '2025-01~2025-03', 'timeType': 'MONTH'}
去年一月到8月吨钢用水量 => {'indicator': '吨钢用水量', 'timeString': '2024-01~2024-08', 'timeType': 'MONTH'}
去年一、二月吨钢用水量 => {'indicator': '吨钢用水量', 'timeString': '2024-01~2024-02', 'timeType': 'MONTH'}
上半年计划 => {'indicator': '计划', 'timeString': '2025-01~2025-06', 'timeType': 'MONTH'}
下半年纯水消耗 => {'indicator': '纯水消耗', 'timeString': '2025-07~2025-12', 'timeType': 'MONTH'}
2024年9月1日到9月7日高炉能耗 => {'indicator': '高炉能耗', 'timeString': '2024-09-01~2024-09-07', 'timeType': 'DAY'}
今天的连退纯水使用量 => {'indicator': '连退纯水使用量', 'timeString': '2025-10-27', 'timeType': 'DAY'}
2022年10月2日 => {'indicator': None, 'timeString': '2022-10-02', 'timeType': 'DAY'}
450酸轧纯水使用量 => {'indicator': '450酸轧纯水使用量', 'timeString': None, 'timeType': None}
查询今年的2030酸轧纯水使用量 => {'indicator': '2030酸轧纯水使用量', 'timeString': '2025', 'timeType': 'YEAR'}
今天的酸轧纯水使用量 => {'indicator': '酸轧纯水使用量', 'timeString': '2025-10-27', 'timeType': 'DAY'}
9月份热轧蒸汽消耗 => {'indicator': '热轧蒸汽消耗', 'timeString': '2025-09', 'timeType': 'MONTH'}
酸轧纯水使用量 => {'indicator': '酸轧纯水使用量', 'timeString': None, 'timeType': None}
昨天 => {'indicator': None, 'timeString': '2025-10-26', 'timeType': 'DAY'}
2025年第41周纯水损失率 => {'indicator': '纯水损失率', 'timeString': '2025 W41', 'timeType': 'WEEK'}
今年10月14日酸轧纯水使用量 => {'indicator': '酸轧纯水使用量', 'timeString': '2025-10-14', 'timeType': 'DAY'}
本周 => {'indicator': None, 'timeString': '2025 W43', 'timeType': 'WEEK'}
上周的吨钢用水量 => {'indicator': '吨钢用水量', 'timeString': '2025 W42', 'timeType': 'WEEK'}
昨天早班的热轧蒸汽消耗 => {'indicator': '热轧蒸汽消耗', 'timeString': '2025-10-26 早班', 'timeType': 'SHIFT'}
明天凌晨2点的轧制水耗 => {'indicator': '轧制水耗', 'timeString': '2025-10-28 02', 'timeType': 'HOUR'}
去年12月份的吨钢用水量 => {'indicator': '吨钢用水量', 'timeString': '2024-12', 'timeType': 'MONTH'}
2025年第4季度纯水损失率 => {'indicator': '纯水损失率', 'timeString': '2025 Q4', 'timeType': 'QUARTER'}
2025年10月上旬热轧蒸汽消耗 => {'indicator': '热轧蒸汽消耗', 'timeString': '2025-10 上旬', 'timeType': 'TENDAYS'}
今天的高炉工序能耗是多少 => {'indicator': '高炉工序能耗', 'timeString': '2025-10-27', 'timeType': 'DAY'}
高炉今天的工序能耗是多少 => {'indicator': '高炉工序能耗', 'timeString': '2025-10-27', 'timeType': 'DAY'}
本月累计的高炉工序能耗是多少 => {'indicator': '高炉工序能耗累计', 'timeString': '2025-10', 'timeType': 'MONTH'}
1号高炉昨天的工序能耗是多少 => {'indicator': '1号高炉工序能耗', 'timeString': '2025-10-26', 'timeType': 'DAY'}
去年今天的高炉工序能耗是多少 => {'indicator': '高炉工序能耗', 'timeString': '2024-10-27', 'timeType': 'DAY'}
2021年10月23日的1高炉工序能耗是多少 => {'indicator': '1高炉工序能耗', 'timeString': '2021-10-23', 'timeType': 'DAY'}
2023年10月22日的2高炉工序能耗是多少 => {'indicator': '2高炉工序能耗', 'timeString': '2023-10-22', 'timeType': 'DAY'}
时间：2021-10-23，1高炉工序能耗是多少 => {'indicator': '1高炉工序能耗', 'timeString': '2021-10-23', 'timeType': 'DAY'}
高炉工序能耗是多少 => {'indicator': '高炉工序能耗', 'timeString': None, 'timeType': None}
本月1、2号高炉工序能耗是多少 => {'indicator': '高炉工序能耗', 'timeString': '2025-10-01~2025-10-02', 'timeType': 'DAY'}
高炉工序能耗本月计划是多少 => {'indicator': '高炉工序能耗计划', 'timeString': '2025-10', 'timeType': 'MONTH'}
本月高炉工序能耗的计划值是多少 => {'indicator': '高炉工序能耗计划值', 'timeString': '2025-10', 'timeType': 'MONTH'}
本月的高炉电耗是多少 => {'indicator': '高炉电耗', 'timeString': '2025-10', 'timeType': 'MONTH'}
本月的高炉电使用量是多少 => {'indicator': '高炉电使用量', 'timeString': '2025-10', 'timeType': 'MONTH'}
高炉的煤气耗是多少 => {'indicator': '高炉的煤气耗', 'timeString': None, 'timeType': None}
10号高炉今天的工序能耗是多少 => {'indicator': '10号高炉工序能耗', 'timeString': '2025-10-27', 'timeType': 'DAY'}
今年累计的冷轧蒸汽消耗是多少 => {'indicator': '冷轧蒸汽消耗累计', 'timeString': '2025', 'timeType': 'YEAR'}
前天晚班的吨钢用水量 => {'indicator': '吨钢用水量', 'timeString': '2025-10-25 夜班', 'timeType': 'SHIFT'}
```

修改main.py对于dict数据的接收，最终测试如下：

![image-20251027181406415](%E8%83%BD%E6%BA%90%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%B9%B3%E5%8F%B0%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF%E5%8F%8A%E5%AE%9E%E7%8E%B0.assets/image-20251027181406415.png)

## 6.10 上下文图谱和意图解析

1. **V1 保持不动**
   - `llm_energy_indicator_parser`（原 `llm_parser`）只做单指标单时间解析，功能不变。
   - `main.py`、`agent_state`、`formula_api`、`platform_api` 都不修改。
   - 这是能源问数的核心执行逻辑。
2. **V2 在 V1 之上做上下文增强**
   - 使用 `ContextGraph` 做多轮/历史指标追踪。
   - 只在用户完成一次完整的指标查询（即最终确定了 `indicator` + `timeString` + `timeType` + `formula`）时，把这条记录加入图谱。
   - 在中间轮次（询问用户补全信息）过程中，不加入图谱，只是保持 slots 状态。
3. **`agent_state` slots 与 ContextGraph 的关系**
   - slots 保持用户会话的当前状态（partial 或 complete）。
   - ContextGraph 记录**完整确认过的指标+时间+公式**历史。
   - V2 可以参照 slots 判断当前是否有未完成的指标查询。
4. **llm_energy_intent_parser 的调用逻辑**
   - 当 LLM 判断用户是在问能源指标时：
     1. 从 slots 获取已有信息（indicator/time）。
     2. 返回下一步问题（补全时间/选择公式等），或直接调用 V1 的逻辑。
     3. 只有最终得到完整信息，才调用 `ContextGraph.add_indicator/add_time`。

------

基于上述思路，我建议分步骤实现：

------

### **步骤 1：初始化 ContextManager**

```
from core.context_graph import ContextManager

context_mgr = ContextManager()
```

- 每个 `user_id` 对应一个 ContextGraph 和历史 query。
- 可以在 V2 中单独管理，不影响 V1。

------

### **步骤 2：在 V2 调用前读取 slots**

```
state = await get_state(user_id)
slots = state.get("slots", {})
```

- 这样 V2 能获取当前指标/时间/公式状态，判断用户是否已经部分输入。

------

### **步骤 3：处理用户输入**

```
# 假设 LLM 解析得到 parsed
parsed = await llm_energy_indicator_parser.parse_user_input(user_input)

# 合并 slots（只补全缺失）
for key in ["indicator", "timeString", "timeType"]:
    if parsed.get(key) and not slots.get(key):
        slots[key] = parsed[key]

await update_state(user_id, state)
```

- 注意：**中间轮次 slots 可能不完整，不加入 ContextGraph**。

------

### **步骤 4：判断是否完整**

```
def is_complete(slots):
    return all([slots.get("indicator"), slots.get("timeString"), slots.get("timeType"), slots.get("formula")])
```

- 只有当 `is_complete(slots)` 为 True 时，才写入 ContextGraph。

------

### **步骤 5：更新 ContextGraph**

```
if is_complete(slots):
    await context_mgr.append_query(user_id, {
        "user_input": user_input,
        "indicator": slots["indicator"],
        "timeString": slots["timeString"],
        "timeType": slots["timeType"],
        "formula": slots["formula"]
    })
```

- 保证只有完成的查询被记录。
- 中间的补充轮次不会污染图谱。

------

### **步骤 6：下一步动作生成**

- 根据 slots 和 ContextGraph 决定下一步：

1. 如果 indicator 缺失 → 提问指标
2. 如果 formula 缺失 → 提问选择公式
3. 如果 time 缺失 → 提问时间
4. 如果都完整 → 调用 V1 `platform_api.query_platform` 并返回结果

------

### **步骤 7：清理或超时**

```
await context_mgr.cleanup_expired()
```

- 可定时清理 30 分钟以上无活动会话。

------

### **总结**

- V1 功能完全不动
- slots 是**用户会话当前状态**
- ContextGraph 是**已确认指标的历史图谱**
- V2 逻辑只在中间轮次“读取 slots + 生成下一步提问”，最终一次完整确认后才加入图谱
- 这样既保证 V1 单指标查询逻辑不受影响，又能支持 V2 的多轮上下文增强

## 6.11 不同时间追问

```
(myenv) fusionshen@fusionshen-ThinkPad-T14-Gen-1:~/Desktop/LLM/ask_agent$ uvicorn main_v2:app --host 0.0.0.0 --port 9001
✅ Using ChatOllama from langchain-ollama
/home/fusionshen/myenv/lib/python3.12/site-packages/jieba/_compat.py:18: UserWarning: pkg_resources is deprecated as an API. See https://setuptools.pypa.io/en/latest/pkg_resources.html. The pkg_resources package is slated for removal as early as 2025-11-30. Refrain from using this package or pin to Setuptools<81.
  import pkg_resources
✅ sentence-transformers 版本: 5.1.1
INFO:     Started server process [928741]
INFO:     Waiting for application startup.
2025-11-04 18:16:48,090 | INFO | 🔄 正在初始化公式数据（full load）...
Building prefix dict from the default dictionary ...
2025-11-04 18:16:51,452 | DEBUG | Building prefix dict from the default dictionary ...
Loading model from cache /tmp/jieba.cache
2025-11-04 18:16:51,452 | DEBUG | Loading model from cache /tmp/jieba.cache
Loading model cost 0.608 seconds.
2025-11-04 18:16:52,061 | DEBUG | Loading model cost 0.608 seconds.
Prefix dict has been built successfully.
2025-11-04 18:16:52,061 | DEBUG | Prefix dict has been built successfully.
2025-11-04 18:17:05,197 | INFO | ✅ Loaded 270817 formulas. Tokenization ready.
HAVE_ST : True
2025-11-04 18:17:05,197 | INFO | Auto-selected embedding device: cpu
OFFLINE_MODEL_PATH:/home/fusionshen/Desktop/LLM/ask_agent/models/sbert_offline_models/86741b4e3f5cb7765a600d3a3d55a0f6a6cb443d
2025-11-04 18:17:05,197 | INFO | 🧩 尝试加载本地模型: /home/fusionshen/Desktop/LLM/ask_agent/models/sbert_offline_models/86741b4e3f5cb7765a600d3a3d55a0f6a6cb443d
2025-11-04 18:17:05,198 | INFO | Load pretrained SentenceTransformer: /home/fusionshen/Desktop/LLM/ask_agent/models/sbert_offline_models/86741b4e3f5cb7765a600d3a3d55a0f6a6cb443d
2025-11-04 18:17:06,102 | INFO | ✅ 已成功加载离线模型。
2025-11-04 18:17:06,722 | INFO | ✅ Loaded embeddings from cache ((270817, 384))
2025-11-04 18:17:06,722 | INFO | ✅ 初始化完成，用时 18.63s
2025-11-04 18:17:06,723 | INFO | ✅ formula_api 初始化完成，用时 18.63s
2025-11-04 18:17:06,723 | INFO | 🧹 已启动 session 定期清理任务。
INFO:     Application startup complete.
INFO:     Uvicorn running on http://0.0.0.0:9001 (Press CTRL+C to quit)
2025-11-04 18:17:24,178 | INFO | 🟢 [route_intent] user='shenlan' input='今天的高炉工序能耗是多少'
2025-11-04 18:17:24,178 | INFO | 🔍 [parse_intent] 用户输入: 今天的高炉工序能耗是多少, 上次指标: None
2025-11-04 18:17:24,330 | INFO | HTTP Request: GET http://192.168.92.13:11434/api/tags "HTTP/1.1 200 OK"
2025-11-04 18:17:24,996 | INFO | HTTP Request: POST http://192.168.92.13:11434/api/chat "HTTP/1.1 200 OK"
2025-11-04 18:17:25,211 | INFO | 📥 轻量意图分类结果: ENERGY_QUERY
2025-11-04 18:17:25,211 | INFO | 🔎 轻量意图分类结果: ENERGY_QUERY (raw: {'intent': 'ENERGY_QUERY'})
2025-11-04 18:17:25,211 | INFO | ⚙️ 检测到 ENERGY_QUERY，进入能源问数流程
2025-11-04 18:17:25,211 | INFO | 🧩 初始化 EnergyIntentParser for user=shenlan
2025-11-04 18:17:25,211 | INFO | ✨ 为用户创建新的 EnergyIntentParser（包含 ContextGraph）
2025-11-04 18:17:25,211 | INFO | 🧠 [parse_intent] user=shenlan | input=今天的高炉工序能耗是多少
2025-11-04 18:17:25,211 | INFO | 📤 发送意图识别 prompt 至 LLM
2025-11-04 18:17:25,271 | INFO | HTTP Request: GET http://192.168.92.13:11434/api/tags "HTTP/1.1 200 OK"
2025-11-04 18:17:25,570 | INFO | HTTP Request: POST http://192.168.92.13:11434/api/chat "HTTP/1.1 200 OK"
2025-11-04 18:17:25,805 | INFO | 📥 LLM 返回意图识别结果: {'intent': 'new_query'}
2025-11-04 18:17:25,867 | INFO | HTTP Request: GET http://192.168.92.13:11434/api/tags "HTTP/1.1 200 OK"
2025-11-04 18:17:26,901 | INFO | HTTP Request: POST http://192.168.92.13:11434/api/chat "HTTP/1.1 200 OK"
2025-11-04 18:17:28,179 | INFO | 📊 指标解析结果: {'indicator': '高炉工序能耗', 'timeString': '2025-11-04', 'timeType': 'DAY'}
2025-11-04 18:17:28,179 | INFO | 🎯 最终意图确定: new_query
2025-11-04 18:17:28,179 | INFO | 🧾 已追加解析历史记录（共 1 条），注意：这不是“查询成功历史”
2025-11-04 18:17:28,180 | INFO | ✅ parse_intent 完成，返回结果: intent=new_query, indicator=高炉工序能耗, time=2025-11-04
2025-11-04 18:17:28,180 | INFO | 🧾 EnergyIntentParser.parse_intent 返回: intent=new_query
2025-11-04 18:17:28,180 | INFO | 🟢 [process_message] user='shenlan' input='今天的高炉工序能耗是多少'
2025-11-04 18:17:28,180 | INFO | 当前 slots (before parsing): {'indicator': None, 'formula': None, 'formula_candidates': None, 'awaiting_confirmation': False, 'timeString': None, 'timeType': None, 'last_input': '今天的高炉工序能耗是多少', 'intent': 'new_query'}
2025-11-04 18:17:28,216 | INFO | HTTP Request: GET http://192.168.92.13:11434/api/tags "HTTP/1.1 200 OK"
2025-11-04 18:17:29,151 | INFO | HTTP Request: POST http://192.168.92.13:11434/api/chat "HTTP/1.1 200 OK"
2025-11-04 18:17:30,449 | INFO | 🔍 LLM 解析结果: {'indicator': '高炉工序能耗', 'timeString': '2025-11-04', 'timeType': 'DAY'}
2025-11-04 18:17:30,449 | INFO | 🧩 初始化 EnergyIntentParser for user=shenlan
2025-11-04 18:17:30,449 | INFO | 🎯 slots['intent'] 已设置为: new_query
2025-11-04 18:17:30,449 | INFO | 当前 slots (after parsing): {'indicator': '高炉工序能耗', 'formula': None, 'formula_candidates': None, 'awaiting_confirmation': False, 'timeString': '2025-11-04', 'timeType': 'DAY', 'last_input': '今天的高炉工序能耗是多少', 'intent': 'new_query'}
2025-11-04 18:17:30,449 | INFO | 🔎 调用 formula_api.formula_query_dict 查询公式, indicator=高炉工序能耗
Batches: 100%|████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████| 1/1 [00:00<00:00, 21.24it/s]
2025-11-04 18:17:31,284 | INFO | formula_api 返回摘要: done=False, exact_matches=False, candidates_len=5
2025-11-04 18:17:31,284 | INFO | 🔢 找到 5 个候选公式（按 score 排序）
2025-11-04 18:17:31,284 | INFO | 🔢 找到 5 个候选公式, 最高候选: 高炉工序能耗实绩报出值 (score=102.3371)
2025-11-04 18:17:31,284 | INFO | 🧠 自动选择高分候选公式: 高炉工序能耗实绩报出值 (score=102.3371)
🟢 登录返回： {'error': None, 'data': {'token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1aWQiOiIxNDMiLCJ0ZW5hbnRpZCI6IjEwNSIsInVuYW1lIjoi566h55CG5ZGYIiwidG5hbWUiOiLlrp3pkqLmuZvmsZ_pkqLpk4HmnInpmZDlhazlj7giLCJ0c2lkZSI6IjEiLCJncm91cGlkIjoiMCIsInNsaWRpbmciOiIwIiwicnNpbmNlIjoiMTc2MjM5NTE1MSIsIm5iZiI6MTc2MjI1MDg1MSwiZXhwIjoxNzYyMzY2NjUxLCJpc3MiOiJzaGJhb25lbmciLCJhdWQiOiJzaGJhb25lbmcifQ.bAPrexznD8ddjf2h1e98qhBDpAzzIsFtdJOXGmdU--Y', 'expiresAt': '2025-11-06 02:16:31', 'tenantId': 105, 'tenancyName': 'zjis', 'userId': 143, 'userName': 'admin'}, 'status': 200, 'msg': '操作成功', 'duration': -1}
🟡 调用接口: http://www.shbaoenergy.com:8081/emscore/api/services/nYMC/calcData/QueryItemValuesAsync
🧩 请求参数: {'expressionList': {'GXNHLT1100.IXRL': 'GXNHLT1100.IXRL'}, 'clock': '2025-11-04', 'timegranId': 'DAY'}
🟢 返回数据: {'error': None, 'data': {'GXNHLT1100.IXRL': None}, 'status': 200, 'msg': '操作成功', 'duration': -1}
2025-11-04 18:17:31,484 | INFO | ✅ platform_api 返回: {'GXNHLT1100.IXRL': None}
2025-11-04 18:17:31,484 | INFO | ✅ pipeline.process_message 执行成功
INFO:     127.0.0.1:56338 - "GET /chat?user_id=shenlan&message=%E4%BB%8A%E5%A4%A9%E7%9A%84%E9%AB%98%E7%82%89%E5%B7%A5%E5%BA%8F%E8%83%BD%E8%80%97%E6%98%AF%E5%A4%9A%E5%B0%91 HTTP/1.1" 200 OK
2025-11-04 18:17:46,819 | INFO | 🟢 [route_intent] user='shenlan' input='那去年的呢'
2025-11-04 18:17:46,819 | INFO | 🔍 [parse_intent] 用户输入: 那去年的呢, 上次指标: None
2025-11-04 18:17:46,880 | INFO | HTTP Request: GET http://192.168.92.13:11434/api/tags "HTTP/1.1 200 OK"
2025-11-04 18:17:47,235 | INFO | HTTP Request: POST http://192.168.92.13:11434/api/chat "HTTP/1.1 200 OK"
2025-11-04 18:17:47,461 | INFO | 📥 轻量意图分类结果: ENERGY_QUERY
2025-11-04 18:17:47,461 | INFO | 🔎 轻量意图分类结果: ENERGY_QUERY (raw: {'intent': 'ENERGY_QUERY'})
2025-11-04 18:17:47,461 | INFO | ⚙️ 检测到 ENERGY_QUERY，进入能源问数流程
2025-11-04 18:17:47,461 | INFO | ♻️ 复用已有 EnergyIntentParser（保留历史与 graph）
2025-11-04 18:17:47,461 | INFO | 🧠 [parse_intent] user=shenlan | input=那去年的呢
2025-11-04 18:17:47,461 | INFO | 📤 发送意图识别 prompt 至 LLM
2025-11-04 18:17:47,525 | INFO | HTTP Request: GET http://192.168.92.13:11434/api/tags "HTTP/1.1 200 OK"
2025-11-04 18:17:47,802 | INFO | HTTP Request: POST http://192.168.92.13:11434/api/chat "HTTP/1.1 200 OK"
2025-11-04 18:17:48,127 | INFO | 📥 LLM 返回意图识别结果: {'intent': 'same_indicator_new_time'}
2025-11-04 18:17:48,189 | INFO | HTTP Request: GET http://192.168.92.13:11434/api/tags "HTTP/1.1 200 OK"
2025-11-04 18:17:49,104 | INFO | HTTP Request: POST http://192.168.92.13:11434/api/chat "HTTP/1.1 200 OK"
2025-11-04 18:17:50,070 | INFO | 📊 指标解析结果: {'indicator': None, 'timeString': '2024', 'timeType': 'YEAR'}
2025-11-04 18:17:50,071 | INFO | 🎯 最终意图确定: same_indicator_new_time
2025-11-04 18:17:50,071 | INFO | 🧾 已追加解析历史记录（共 2 条），注意：这不是“查询成功历史”
2025-11-04 18:17:50,071 | INFO | ✅ parse_intent 完成，返回结果: intent=same_indicator_new_time, indicator=None, time=2024
2025-11-04 18:17:50,071 | INFO | 🧾 EnergyIntentParser.parse_intent 返回: intent=same_indicator_new_time
2025-11-04 18:17:50,071 | INFO | 🟢 [process_message] user='shenlan' input='那去年的呢'
2025-11-04 18:17:50,071 | INFO | 当前 slots (before parsing): {'indicator': '高炉工序能耗实绩报出值', 'formula': 'GXNHLT1100.IXRL', 'formula_candidates': None, 'awaiting_confirmation': False, 'timeString': '2025-11-04', 'timeType': 'DAY', 'last_input': '那去年的呢', 'intent': 'same_indicator_new_time'}
2025-11-04 18:17:50,103 | INFO | HTTP Request: GET http://192.168.92.13:11434/api/tags "HTTP/1.1 200 OK"
2025-11-04 18:17:50,983 | INFO | HTTP Request: POST http://192.168.92.13:11434/api/chat "HTTP/1.1 200 OK"
2025-11-04 18:17:51,954 | INFO | 🔍 LLM 解析结果: {'indicator': None, 'timeString': '2024', 'timeType': 'YEAR'}
2025-11-04 18:17:51,954 | INFO | 🧩 初始化 EnergyIntentParser for user=shenlan
2025-11-04 18:17:51,954 | INFO | 🎯 slots['intent'] 已设置为: same_indicator_new_time
2025-11-04 18:17:51,954 | INFO | 当前 slots (after parsing): {'indicator': '高炉工序能耗实绩报出值', 'formula': 'GXNHLT1100.IXRL', 'formula_candidates': None, 'awaiting_confirmation': False, 'timeString': '2024', 'timeType': 'YEAR', 'last_input': '那去年的呢', 'intent': 'same_indicator_new_time'}
2025-11-04 18:17:51,954 | INFO | 🔎 调用 formula_api.formula_query_dict 查询公式, indicator=高炉工序能耗实绩报出值
2025-11-04 18:17:51,972 | INFO | formula_api 返回摘要: done=True, exact_matches=True, candidates_len=0
2025-11-04 18:17:51,973 | INFO | ✅ 精确匹配公式: 高炉工序能耗实绩报出值 (FORMULAID=GXNHLT1100.IXRL)
🟡 调用接口: http://www.shbaoenergy.com:8081/emscore/api/services/nYMC/calcData/QueryItemValuesAsync
🧩 请求参数: {'expressionList': {'GXNHLT1100.IXRL': 'GXNHLT1100.IXRL'}, 'clock': '2024', 'timegranId': 'YEAR'}
🟢 返回数据: {'error': None, 'data': {'GXNHLT1100.IXRL': '10'}, 'status': 200, 'msg': '操作成功', 'duration': -1}
2025-11-04 18:17:52,125 | INFO | ✅ platform_api 返回: {'GXNHLT1100.IXRL': '10'}
2025-11-04 18:17:52,125 | INFO | ✅ pipeline.process_message 执行成功
INFO:     127.0.0.1:48084 - "GET /chat?user_id=shenlan&message=%E9%82%A3%E5%8E%BB%E5%B9%B4%E7%9A%84%E5%91%A2 HTTP/1.1" 200 OK
2025-11-04 18:18:44,979 | INFO | 🟢 [route_intent] user='shenlan' input='今天是什么日期'
2025-11-04 18:18:44,980 | INFO | 🔍 [parse_intent] 用户输入: 今天是什么日期, 上次指标: None
2025-11-04 18:18:45,017 | INFO | HTTP Request: GET http://192.168.92.13:11434/api/tags "HTTP/1.1 200 OK"
2025-11-04 18:18:45,414 | INFO | HTTP Request: POST http://192.168.92.13:11434/api/chat "HTTP/1.1 200 OK"
2025-11-04 18:18:45,631 | INFO | 📥 轻量意图分类结果: TOOL
2025-11-04 18:18:45,632 | INFO | 🔎 轻量意图分类结果: TOOL (raw: {'intent': 'TOOL'})
2025-11-04 18:18:45,632 | INFO | 🛠️ 检测到 TOOL 意图，进入工具处理
2025-11-04 18:18:45,694 | INFO | HTTP Request: GET http://192.168.92.13:11434/api/tags "HTTP/1.1 200 OK"
2025-11-04 18:18:46,097 | INFO | HTTP Request: POST http://192.168.92.13:11434/api/chat "HTTP/1.1 200 OK"
INFO:     127.0.0.1:46866 - "GET /chat?user_id=shenlan&message=%E4%BB%8A%E5%A4%A9%E6%98%AF%E4%BB%80%E4%B9%88%E6%97%A5%E6%9C%9F HTTP/1.1" 200 OK
2025-11-04 18:19:52,642 | INFO | 🟢 [route_intent] user='shenlan' input='上一个季度呢'
2025-11-04 18:19:52,642 | INFO | 🔍 [parse_intent] 用户输入: 上一个季度呢, 上次指标: None
⚠️ Remote Ollama not reachable: 
🔄 Falling back to local model: qwen2.5:1.5b
2025-11-04 18:20:02,020 | INFO | HTTP Request: POST http://127.0.0.1:11434/api/chat "HTTP/1.1 200 OK"
2025-11-04 18:20:02,649 | INFO | 📥 轻量意图分类结果: ENERGY_QUERY
2025-11-04 18:20:02,649 | INFO | 🔎 轻量意图分类结果: ENERGY_QUERY (raw: {'intent': 'ENERGY_QUERY'})
2025-11-04 18:20:02,649 | INFO | ⚙️ 检测到 ENERGY_QUERY，进入能源问数流程
2025-11-04 18:20:02,649 | INFO | ♻️ 复用已有 EnergyIntentParser（保留历史与 graph）
2025-11-04 18:20:02,649 | INFO | 🧠 [parse_intent] user=shenlan | input=上一个季度呢
2025-11-04 18:20:02,653 | INFO | 📤 发送意图识别 prompt 至 LLM
⚠️ Remote Ollama not reachable: 
🔄 Falling back to local model: qwen2.5:1.5b
2025-11-04 18:20:07,964 | INFO | HTTP Request: POST http://127.0.0.1:11434/api/chat "HTTP/1.1 200 OK"
2025-11-04 18:20:08,340 | INFO | 📥 LLM 返回意图识别结果: {'intent': 'same_indicator_new_time'}
⚠️ Remote Ollama not reachable: 
🔄 Falling back to local model: qwen2.5:1.5b
2025-11-04 18:20:37,803 | INFO | HTTP Request: POST http://127.0.0.1:11434/api/chat "HTTP/1.1 200 OK"
2025-11-04 18:20:39,461 | INFO | 📊 指标解析结果: {'indicator': None, 'timeString': '2024 Q1', 'timeType': 'QUARTER'}
2025-11-04 18:20:39,461 | INFO | 🎯 最终意图确定: same_indicator_new_time
2025-11-04 18:20:39,461 | INFO | 🧾 已追加解析历史记录（共 3 条），注意：这不是“查询成功历史”
2025-11-04 18:20:39,461 | INFO | ✅ parse_intent 完成，返回结果: intent=same_indicator_new_time, indicator=None, time=2024 Q1
2025-11-04 18:20:39,461 | INFO | 🧾 EnergyIntentParser.parse_intent 返回: intent=same_indicator_new_time
2025-11-04 18:20:39,461 | INFO | 🟢 [process_message] user='shenlan' input='上一个季度呢'
2025-11-04 18:20:39,461 | INFO | 当前 slots (before parsing): {'indicator': '高炉工序能耗实绩报出值', 'formula': 'GXNHLT1100.IXRL', 'formula_candidates': None, 'awaiting_confirmation': False, 'timeString': '2024', 'timeType': 'YEAR', 'last_input': '上一个季度呢', 'intent': 'same_indicator_new_time'}
2025-11-04 18:20:39,497 | INFO | HTTP Request: GET http://192.168.92.13:11434/api/tags "HTTP/1.1 200 OK"
2025-11-04 18:20:41,027 | INFO | HTTP Request: POST http://192.168.92.13:11434/api/chat "HTTP/1.1 200 OK"
2025-11-04 18:20:42,273 | INFO | 🔍 LLM 解析结果: {'indicator': None, 'timeString': '2025 Q3', 'timeType': 'QUARTER'}
2025-11-04 18:20:42,274 | INFO | 🧩 初始化 EnergyIntentParser for user=shenlan
2025-11-04 18:20:42,274 | INFO | 🎯 slots['intent'] 已设置为: same_indicator_new_time
2025-11-04 18:20:42,274 | INFO | 当前 slots (after parsing): {'indicator': '高炉工序能耗实绩报出值', 'formula': 'GXNHLT1100.IXRL', 'formula_candidates': None, 'awaiting_confirmation': False, 'timeString': '2025 Q3', 'timeType': 'QUARTER', 'last_input': '上一个季度呢', 'intent': 'same_indicator_new_time'}
2025-11-04 18:20:42,274 | INFO | 🔎 调用 formula_api.formula_query_dict 查询公式, indicator=高炉工序能耗实绩报出值
2025-11-04 18:20:42,314 | INFO | formula_api 返回摘要: done=True, exact_matches=True, candidates_len=0
2025-11-04 18:20:42,315 | INFO | ✅ 精确匹配公式: 高炉工序能耗实绩报出值 (FORMULAID=GXNHLT1100.IXRL)
🟡 调用接口: http://www.shbaoenergy.com:8081/emscore/api/services/nYMC/calcData/QueryItemValuesAsync
🧩 请求参数: {'expressionList': {'GXNHLT1100.IXRL': 'GXNHLT1100.IXRL'}, 'clock': '2025 Q3', 'timegranId': 'QUARTER'}
🟢 返回数据: {'error': None, 'data': {'GXNHLT1100.IXRL': None}, 'status': 200, 'msg': '操作成功', 'duration': -1}
2025-11-04 18:20:42,548 | INFO | ✅ platform_api 返回: {'GXNHLT1100.IXRL': None}
2025-11-04 18:20:42,548 | INFO | ✅ pipeline.process_message 执行成功
INFO:     127.0.0.1:59764 - "GET /chat?user_id=shenlan&message=%E4%B8%8A%E4%B8%80%E4%B8%AA%E5%AD%A3%E5%BA%A6%E5%91%A2 HTTP/1.1" 200 OK
```

返回：

```
{
  "reply": "✅ 高炉工序能耗实绩报出值 在 2025 Q3 (QUARTER) 的值是 None ",
  "intent_info": {
    "intent": "same_indicator_new_time",
    "indicator": "高炉工序能耗实绩报出值",
    "formula": "GXNHLT1100.IXRL",
    "timeString": "2025 Q3",
    "timeType": "QUARTER",
    "history": [
      {
        "user_input": "今天的高炉工序能耗是多少",
        "indicator": "高炉工序能耗实绩报出值",
        "formula": "GXNHLT1100.IXRL",
        "timeString": "2025-11-04",
        "timeType": "DAY",
        "result": "✅ 高炉工序能耗实绩报出值 在 2025-11-04 (DAY) 的值是 None ",
        "intent": "new_query"
      },
      {
        "user_input": "那去年的呢",
        "indicator": "高炉工序能耗实绩报出值",
        "formula": "GXNHLT1100.IXRL",
        "timeString": "2024",
        "timeType": "YEAR",
        "result": "✅ 高炉工序能耗实绩报出值 在 2024 (YEAR) 的值是 10 ",
        "intent": "same_indicator_new_time"
      },
      {
        "user_input": "上一个季度呢",
        "indicator": "高炉工序能耗实绩报出值",
        "formula": "GXNHLT1100.IXRL",
        "timeString": "2025 Q3",
        "timeType": "QUARTER",
        "result": "✅ 高炉工序能耗实绩报出值 在 2025 Q3 (QUARTER) 的值是 None ",
        "intent": "same_indicator_new_time"
      }
    ],
    "graph": {
      "graph": {
        "indicators": [
          "高炉工序能耗实绩报出值"
        ],
        "times": [
          {
            "timeString": "2025-11-04",
            "timeType": "DAY"
          },
          {
            "timeString": "2024",
            "timeType": "YEAR"
          },
          {
            "timeString": "2025 Q3",
            "timeType": "QUARTER"
          }
        ],
        "relations": [],
        "nodes": [
          [
            "高炉工序能耗实绩报出值",
            "2025-11-04",
            "DAY"
          ],
          [
            "高炉工序能耗实绩报出值",
            "2024",
            "YEAR"
          ],
          [
            "高炉工序能耗实绩报出值",
            "2025 Q3",
            "QUARTER"
          ]
        ]
      }
    }
  },
  "graph_state": {
    "graph": {
      "indicators": [
        "高炉工序能耗实绩报出值"
      ],
      "times": [
        {
          "timeString": "2025-11-04",
          "timeType": "DAY"
        },
        {
          "timeString": "2024",
          "timeType": "YEAR"
        },
        {
          "timeString": "2025 Q3",
          "timeType": "QUARTER"
        }
      ],
      "relations": [],
      "nodes": [
        [
          "高炉工序能耗实绩报出值",
          "2025-11-04",
          "DAY"
        ],
        [
          "高炉工序能耗实绩报出值",
          "2024",
          "YEAR"
        ],
        [
          "高炉工序能耗实绩报出值",
          "2025 Q3",
          "QUARTER"
        ]
      ]
    }
  }
}

### 穿插日期
{
  "reply": "今天是2025年11月4日。",
  "intent_info": {
    "intent": "TIME_QUERY",
    "question": "今天是什么日期",
    "answer": "今天是2025年11月4日。",
    "detail": {
      "type": "DAY",
      "start_date": "2025-11-04",
      "end_date": null,
      "extra": null
    }
  }
}
```

现阶段效果图：

![image-20251109172444175](%E8%83%BD%E6%BA%90%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%B9%B3%E5%8F%B0%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF%E5%8F%8A%E5%AE%9E%E7%8E%B0.assets/image-20251109172444175.png)

![image-20251109213128107](%E8%83%BD%E6%BA%90%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%B9%B3%E5%8F%B0%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF%E5%8F%8A%E5%AE%9E%E7%8E%B0.assets/image-20251109213128107.png)

![image-20251109213146747](%E8%83%BD%E6%BA%90%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%B9%B3%E5%8F%B0%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF%E5%8F%8A%E5%AE%9E%E7%8E%B0.assets/image-20251109213146747.png)

![image-20251109213225291](%E8%83%BD%E6%BA%90%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%B9%B3%E5%8F%B0%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF%E5%8F%8A%E5%AE%9E%E7%8E%B0.assets/image-20251109213225291.png)

> 最后报错是因为三步问数对比需要保证干净的历史记录，因为156服务一直没有重启，导致计算报错。这个本来也是准备重构多轮语义分析上下文图谱的。
>
> * agent_state和上下文谱图职责冲突，slots插槽也能够在上下文图谱中管理
> * 当前llm_intent_parser只返回意图，不能够拆解多个指标信息，导致无法实现二步问数对比、一步问数对比和批量查询的功能。llm_energy_intent_parser已经稳定，它只负责单指标单时间的解析。所以需要升级llm_intent_parser用来拆解并返回意图+指标时间列表。

## 6.12 多轮语义分析

非常棒 👏，你现在已经把“对比”问题提到了 **真正的多轮语义分析层面** —— 不再局限于当前轮和上一轮，而是希望让系统**能基于上下文图谱（ContextGraph）自动完成任意多节点之间的对比推理**。

下面我帮你完整设计这个机制，包括：
 1️⃣ 核心思路
 2️⃣ 数据结构演化（graph 如何支撑多轮对比）
 3️⃣ 对比调度机制（多节点选取与分析）
 4️⃣ 结合 LLM 的总结策略
 5️⃣ 可落地的代码骨架

------

## 🧩 一、核心目标

> 无论用户进行了多少次能源查询（不同时间、不同指标），系统都能：
>
> - 理解任意两次（甚至多次）查询之间的“对比”意图；
> - 自动提取对应节点；
> - 执行多次查询；
> - 调用 LLM 自动输出分析结论。

例如：

```
1️⃣ “查询 2020 年高炉能耗”
2️⃣ “查询 2021 年高炉能耗”
3️⃣ “查询 2022 年高炉能耗”
4️⃣ “对比 2020 年和 2022 年的变化”
```

系统自动识别第 4 句的关系为：

```
relations: [("2020年高炉能耗", "2022年高炉能耗", "compare")]
```

------

## 🧠 二、ContextGraph 扩展设计

### 原有结构：

```
{
  "nodes": [
      {"indicator": "高炉能耗", "timeString": "2025-10", "timeType": "MONTH"}
  ],
  "relations": [
      {"type": "compare", "source": "...", "target": "..."}
  ]
}
```

### 改进目标：

让每个节点有唯一 ID，可被后续引用（例如按时间、轮次等）：

```
{
  "nodes": [
      {"id": "n1", "indicator": "高炉能耗", "timeString": "2020", "timeType": "YEAR"},
      {"id": "n2", "indicator": "高炉能耗", "timeString": "2021", "timeType": "YEAR"},
      {"id": "n3", "indicator": "高炉能耗", "timeString": "2022", "timeType": "YEAR"}
  ],
  "relations": [
      {"id": "r1", "type": "compare", "source": "n1", "target": "n3"}
  ]
}
```

### 可操作接口：

```
class ContextGraph:
    def add_node(self, indicator, timeString, timeType) -> str: ...
    def find_node(self, indicator=None, timeString=None, timeType=None) -> Optional[str]: ...
    def add_relation(self, type, source_id, target_id): ...
    def resolve_compare_nodes(self, query_text): ...
```

------

## ⚙️ 三、智能对比调度机制

### 1️⃣ EnergyIntentParser 解析 compare 意图时

新增逻辑：

```
if intent == "compare":
    nodes = self.graph.nodes
    compare_targets = self.graph.resolve_compare_nodes(user_input)
    if compare_targets:
        source_id, target_id = compare_targets
        self.graph.add_relation("compare", source_id, target_id)
```

### 2️⃣ `resolve_compare_nodes` 的实现思路：

- 若用户在输入中显式提到时间（如“对比 2020 和 2022”），直接匹配；
- 若用户仅说“对比上月”，则取最近节点作为 target，推导上月为 source；
- 若未指定，则默认取最近两条记录的节点（history[-2], history[-1]）。

示例：

```
def resolve_compare_nodes(self, user_input: str):
    if "和" in user_input:
        years = re.findall(r"20\d{2}", user_input)
        if len(years) >= 2:
            src = self.find_node(timeString=f"{years[0]}")
            tgt = self.find_node(timeString=f"{years[-1]}")
            return (src, tgt)
    # 默认取最近两条节点
    if len(self.nodes) >= 2:
        return (self.nodes[-2]["id"], self.nodes[-1]["id"])
    return None
```

------

## 🧩 四、统一对比执行逻辑（intent_router 中）

新增 `compare` 处理：

```
if intent_info.get("intent") == "compare":
    logger.info("🔗 检测到 compare 意图，执行多节点对比分析")

    relation_pairs = parser.graph.get_relations("compare")
    if not relation_pairs:
        logger.warning("⚠️ 未找到 compare 关系，使用最近两节点默认对比")
        relation_pairs = [parser.graph.resolve_compare_nodes(user_input)]

    results = []
    for src_id, tgt_id in relation_pairs:
        src_node = parser.graph.get_node(src_id)
        tgt_node = parser.graph.get_node(tgt_id)
        if not src_node or not tgt_node:
            continue

        reply1, _ = await process_message(user_id, f"{src_node['indicator']} {src_node['timeString']}", parser.graph.to_state())
        reply2, _ = await process_message(user_id, f"{tgt_node['indicator']} {tgt_node['timeString']}", parser.graph.to_state())

        # 🔍 交由 LLM 做差异分析
        prompt = f"""
        请对以下两个时间段的 {src_node['indicator']} 数据进行差异分析，简述变化趋势：
        【{src_node['timeString']}】
        {reply1}
        【{tgt_node['timeString']}】
        {reply2}
        """
        summary = await safe_llm_chat(prompt)
        results.append(summary)

    reply = "\n\n".join(results)
    return {"reply": reply, "intent_info": intent_info, "graph_state": parser.graph.to_state()}
```

------

## 📈 五、这套机制的优势

| 能力           | 说明                                                     |
| -------------- | -------------------------------------------------------- |
| ✅ 自动节点追踪 | 每次查询自动生成唯一节点，可多轮累积                     |
| ✅ 任意对比组合 | “对比上次”“对比2020和2023”“对比第一年和第五年”皆可       |
| ✅ 灵活时间识别 | LLM + 正则 + fallback 机制保证多样化输入可解析           |
| ✅ 上下文持久化 | `parser_store` 长期保留 `ContextGraph`，支持持续多轮对话 |
| ✅ LLM 生成结论 | 让模型专注做分析，而不是查数                             |

## 6.13 智能分析

| 基础问数 | 今天的高炉工序能耗是多少                                     | 1. 今天解析正确 2. 高炉工序能耗实绩报出值指标解析正确 3. 数据匹配正确 |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 基础问数 | 高炉今天的工序能耗是多少                                     | 1. 今天解析正确 2. 高炉工序能耗实绩报出值指标解析正确 3. 数据匹配正确 |
| 基础问数 | 本月累计的高炉工序能耗是多少                                 | 1. 本月解析正确 2. 高炉工序能耗实绩累计值指标解析正确 3. 数据匹配正确 |
| 基础问数 | 1号高炉昨天的工序能耗是多少                                  | 1. 昨天解析正确 2. 1号高炉工序能耗实绩报出值指标解析正确 3. 数据匹配正确 |
| 基础问数 | 去年今天的高炉工序能耗是多少                                 | 1. 去年今天解析正确 2. 高炉工序能耗实绩报出值指标解析正确 3. 数据匹配正确 |
| 基础问数 | 2021年10月23日的1高炉工序能耗是多少                          | 1. 2021年10月23日解析正确 2. 1高炉工序能耗实绩报出值指标解析正确 3. 数据匹配正确 |
| 基础问数 | 时间：2021-10-23，1高炉工序能耗是多少                        | 1. 2021-10-23解析正确 2. 1高炉工序能耗实绩报出值指标解析正确 3. 数据匹配正确 |
| 基础问数 | 高炉工序能耗是多少                                           | 1. 高炉工序能耗实绩报出值指标解析正确 2. 提示时间未指定，并默认获取上一日的数据。 |
| 基础问数 | 本月1、2号高炉工序能耗是多少                                 | 1. 本月解析正确 2. 1高炉工序能耗实绩报出值、2高炉工序能耗实绩报出值指标解析正确 3. 两个数据匹配正确 |
| 基础问数 | 高炉工序能耗本月计划是多少                                   | 1. 本月解析正确 2. 高炉工序能耗计划报出值指标解析正确 3. 数据匹配正确 |
| 基础问数 | 本月高炉工序能耗的计划值是多少                               | 1. 本月解析正确 2. 高炉工序能耗计划报出值指标解析正确 3. 数据匹配正确 |
| 高级问数 | 本月的高炉电耗是多少                                         | 1. 本月解析正确 2. 高炉电使用量实绩单耗值指标解析正确 3. 数据匹配正确 |
| 高级问数 | 本月的高炉电使用量是多少                                     | 1. 本月解析正确 2. 高炉电使用量实绩爆出值指标解析正确 3. 数据匹配正确 |
| 高级问数 | 高炉的煤气耗是多少                                           | 1. 提示有多个指标（限定：高炉，高炉煤气，单耗），让用户选择。 2. 选择指标后自动获取数据。 |
| 高级问数 | 轮次1：本月的高炉工序能耗是多少？ 轮次2：对比上月有什么变化  | 1. 本月解析正确；上月解析正确 2. 高炉工序能耗实绩报出值指标解析正确 3. 指标对比获取数据正确，生成基础分析结论。 |
| 高级问数 | 轮次1：本月的1高炉工序能耗是多少？ 轮次2：对比2高炉有什么变化 | 1. 本月解析正确； 2. 1高炉工序能耗实绩报出值、2高炉工序能耗实绩报出值指标解析正确 3. 指标对比获取数据正确，生成基础分析结论。 |
| 基础问数 | 轮次1：10号高炉今天的工序能耗是多少                          | 1. 10号高炉无法匹配，提示相近的指标，并提供用户选择。 2. 选择后获取数据正确。 |
| 高级问数 | 轮次1：本月的高炉工序能耗是多少？ 轮次2：1#，2#，3#高炉分别是多少 | 1. 本月解析正确； 2. 1高炉工序能耗实绩报出值、2高炉工序能耗实绩报出值、3高炉工序能耗实绩报出值指标解析正确 3. 指标对比获取数据正确，生成基础分析结论。 |
| 分析报告 | 本月高炉工序能耗是多少，对比计划偏差多少                     | 1. 本月解析正确 2. 高炉工序能耗实绩报出值、高炉工序能耗计划报出值指标解析正确 3. 2个数据匹配正确，分析结论正确 |
| 分析报告 | 本年度的高炉工序能耗趋势是什么样的                           | 1. 本月解析正确->时间段解析正确[2025-01~2025-09] 2. 高炉工序能耗实绩报出值指标解析正确 3. 数据序列匹配正确，展示数据列表正确 4. 生成趋势图正确。 5. 自动生成一段分析结论。 |
| 分析报告 | 本月1、2号高炉工序能耗偏差情况                               | 1. 本月解析正确 2. 1高炉工序能耗实绩报出值、2高炉工序能耗实绩报出值指标解析正确 3. 2个数据匹配正确，分析结论正确 |

太好了 — 我按你说的思路把设计拆成**逐步可执行的实现与测试步骤**，目标是：

- 保留 `parse_user_input`（单指标单时间）的接口不变，
- 在 `EnergyIntentParser` 层做“解构/重组/标注槽位/多指标展开”的工作（并把结果以统一的列表结构返回给 pipeline），
- pipeline 以最小改动接收该列表并负责补槽 / 批量查询 / 复用历史 / 生成对比/趋势等。

下面是详细的分步设计（每步都包含目的、实现要点、示例/提示、以及测试用例）。你按步做每一步后跑单元测试；我可以随时把代码样板给你用来替换实现。

------

### 总体输出协议（Parser → Pipeline）

先统一一个返回结构（parser 返回给 pipeline 的 `intent_info`）——这是关键契约，pipeline 依据它工作：

```
{
  "reply": null,            // 可选：parser 也可以直接返回一个初步回复草稿（可为空）
  "intent_info": {
    "intent": "list_query", // parser 判定的高层意图
    "indicators": [
      {
        "id": "tmp-1",              // 临时 id（便于 graph/reuse/映射）
        "name": "1号高炉工序能耗",   // 人类可读
        "formula": "GXNHLT1100.IXRL",// 若 parse_user_input 可解析出 formula 则填
        "timeString": "2025-11",    // 可能为空或部分填（"本月"、"2025-11-07"）
        "timeType": "MONTH|DAY|RANGE|YEAR|UNKNOWN",
        "slot_status": {            // 标注哪些槽位已充足 / 需要补齐
          "name": "filled",
          "time": "filled"|"missing"|"ambiguous"
        },
        "value": null,              // pipeline 填充后的实际数值（或 null）
        "note": null                // 解析备注（例如 "匹配到 1# vs 10# 相近，需确认"）
      },
      ...
    ],
    "slot_requirements": {        // 快速索引：是否存在需要补时间或补指标
      "need_time": true,
      "need_indicator": false
    },
    "history": [ ... ],           // parser 层的解析历史（保留，便于 pipeline 决策）
    "graph_state": { ... }        // parser.graph.to_state()（解析参考）
  }
}
```

说明：

- `indicators` 永远是数组（即便只有一项），便于 pipeline 批量处理。
- `slot_status` 表示需要补齐的槽位（time/name），`ambiguous` 表明需要候选供用户选择。
- `value` 由 pipeline 或缓存填充后返回给上层回复（也可以直接由 parser 请求接口，但建议 pipeline 做查询）。

------

### 步骤 1 — 修改 LLM 意图判断：同时请求“意图 + 初步分解”

目的：让 LLM 在判断意图时，也把“初次解析的重组结果”返回（例如把 `本月1、2号高炉工序能耗是多少` 分解为两条单指标单时间的 query 片段），然后再调用 `parse_user_input` 逐条解析。

实现要点：

- intent prompt 要求返回 JSON 包含 `intent` 与 `candidates`。`candidates` 是 LLM 按自然语言拆分/补全后给出的“单元查询短句”数组（例如 `"本月1号高炉工序能耗是多少"`）。
- parser 对 `candidates` 逐条调用 `parse_user_input`（它返回单指标单时间），再把结果合并到 `indicators` 列表中。
- 如果 LLM 没返回 `candidates`，parser 可用简单的分隔符规则（如`、`, `,`, `and`, `和`）进行初次拆分。

示例 LLM prompt（你在代码里会用）：

```
请严格返回 JSON: {"intent":"...", "candidates": ["...","..."] }
说明：
- intent 使用一行词，例如 "single_query","list_query","compare","analysis" 等。
- candidates 为把用户输入拆为若干“单指标单时间”的短句，便于后续逐条解析。
例如：输入 "本月1、2号高炉工序能耗是多少" -> candidates: ["本月1号高炉工序能耗是多少","本月2号高炉工序能耗是多少"]
```

测试用例：

- 输入：`本月1、2号高炉工序能耗是多少` -> intent=`list_query`，candidates=2 条。

------

### 步骤 2 — 在 Parser 层把 candidates 逐条交给 parse_user_input（保持 parse_user_input 不改）

目的：复用你现有的 `parse_user_input`（单指标单时间）来解析每个 candidate，避免改动底层解析。

实现要点：

- 对于 LLM 返回的每个 `candidate` 调用 `await parse_user_input(candidate)`。
- parse_user_input 返回单项：`indicator`, `formula`, `timeString`, `timeType`（或为空）。把这些结果包装成 `indicators` 列表项。
- 对于 parse 失败或 `indicator` 为空，标注 `slot_status.name=missing`，并把原候选短句放到 `note` 中，供后续问询。

示例伪码片段（关键逻辑）：

```
candidates = llm_result.get("candidates") or heuristic_split(user_input)
indicators = []
for cand in candidates:
    parsed = await parse_user_input(cand)
    if parsed and parsed.get("indicator"):
        indicators.append({
            "id": gen_tmp_id(),
            "name": parsed["indicator"],
            "formula": parsed.get("formula"),
            "timeString": parsed.get("timeString"),
            "timeType": parsed.get("timeType"),
            "slot_status": {"name":"filled", "time": "filled" if parsed.get("timeString") else "missing"},
            "value": None,
            "note": None
        })
    else:
        indicators.append({ "id":..., "name": None, "formula": None, "timeString": None, "slot_status": {"name":"missing","time":"missing"}, "note": cand })
```

测试用例：

- 输入：`高炉工序能耗本月计划是多少` -> LLM: candidate=`高炉工序能耗本月计划是多少` -> parse_user_input 应识别为 `indicator=高炉工序能耗计划报出值`, `timeString=本月`.

------

### 步骤 3 — 槽位状态与补槽策略（parser 标注，pipeline 负责交互）

目的：统一表示哪些槽位缺失/模糊，由 pipeline 决定如何与用户补齐（问一句还是给候选供选）。

实现要点：

- `slot_status` 四种： `filled` / `missing` / `ambiguous` / `inferred`。
  - `ambiguous` 用于 parse 到多个可能匹配（例如“煤气耗”匹配到“高炉煤气总量”与“高炉煤气单耗”）—— parser 应把候选列表放在 `note` 里或额外放 `candidates_formulas`。
  - `inferred` 表示 parser 根据上下文推断（例如上一轮时间为“本月”，当前轮无时间，parser 设置 `timeType` 与 `timeString` 为上一轮值并标注为 `inferred`），但 pipeline 在实际查询前应再次确认或允许自动使用。
- pipeline 收到 `intent_info` 后：
  - 若 `slot_requirements.need_time` 或 `need_indicator` 为 true，则触发补槽对话（询问用户）。如果 `ambiguous`，返回候选供用户选择（display choices).
  - 若全部 `filled` 或你允许 `inferred` 自动使用（可由业务配置决定），则批量调用数据查询接口。

重要：你认为 `slot_fill` 不是独立意图，所以不要把它作为高层 intent；而只作为 `slot_status` 的一种状态标注 —— 正是按你说的做法。

测试用例：

- 输入：`高炉工序能耗是多少`（无时间） -> indicators[0].slot_status.time = missing， slot_requirements.need_time = true -> pipeline 问：“要查哪天/本月/去年今天？” 或者默认使用“上一日”并提示。

------

### 步骤 4 — 多轮衔接（将上一轮时间/上下文合理继承或不继承）

目的：实现“轮次1：本月的高炉工序能耗”；“轮次2：1#、2#、3#高炉分别是多少” 的自然衔接。

实现要点：

- parser 历史 `self.history` 保留解析结果（含 indicators 列表与其 timeString/timeType）。当新轮用户输入缺时间时，parser 在 `timeString/timeType` 上可尝试 **自动引用最近一条已充足的时间**，并把 `slot_status.time = "inferred"`。同时在 `intent_info` 中加入 `inference_basis: "from_history_index": N` 供 pipeline 决定是否直接使用或再次确认。
- 但**必须**区分两类情形：
  1. 新轮用户明确要“基于上一轮时间继承” —— e.g. user says “1#，2#分别是多少” immediately after “本月的高炉工序能耗是多少” → parser 应自动把时间推到上轮（inferred）。
  2. 破坏继承（user explicitly says new time） —— parser 使用新 time。
- 要求 LLM 在意图/候选分解里指出是否存在“时间继承意图”，这可以通过 prompt 指定 LLM：若用户没有时间词，是否要尝试使用历史时间。

示例字段（加入到 intent_info）：

```
"inference": {
  "used_history_index": 2,
  "inferred_time": "2025-11",
  "confidence": 0.8
}
```

测试用例：

- R1: `本月的高炉工序能耗是多少` -> parser 返回 time=本月 (filled)
- R2: `1#、2#、3#分别是多少` -> parser returns three indicators with time=inferred (本月) and `inference.used_history_index=last`.

------

### 步骤 5 — Cache / 重用历史查询结果（避免重复请求）

目的：当 pipeline 收到 candidates 列表时先查询 parser.history / graph 看是否已存在同指标同时间的成功结果，若存在直接复用，避免重复请求。

实现要点：

- parser.history 中每条成功查询的记录应保存 `indicator.name`, `formula`, `timeString`, `timeType`, `value`, `result_ts`。
- pipeline 在批量查询前做一个 lookup 函数 `find_cached(indicator, time)`；若找到且数据不过期/仍可用则直接填充 `value`，并在返回给用户时标注 `source: cache`。
- graph 节点也可以保存 value，relations 用于后续趋势/对比计算。

测试用例：

- 如果用户重复问相同“今天的高炉工序能耗”，第二次应返回 `source: cache`（或直接展示），而不是再请求 DB。

------

### 步骤 6 — pipeline 的并发批量查询与对比/趋势逻辑

目的：当 parser 返回多条 candidates（list_query / multi_round / analysis），pipeline 要支持并发查询、差值计算、趋势序列构建与图表准备。

实现要点：

- 提供 `batch_query(indicator_list)`：并发调用数据接口（限制并发数），返回 `[{id, value, status, raw}]`。
- 对于 `compare` intent：按 pairs 组织（若只有两个指标/时间），生成差值与百分比（注意处理 zero/NaN）。
- 对于 `analysis` / `trend`：若 `timeType` 为 `RANGE`（例如 `2025-01~2025-09`），则 pipeline 需要把请求转换为按月/按日序列查询（或调用支持 range 的后端接口），然后返回序列与基础统计（mean/median/trend slope），并可生成图表（pipeline 返回数据，前端绘图）。
- 为保证响应及时，pipeline 在返回给用户的文本中可以先返回表格 summary（前几项）并提示“是否需要完整趋势图/详细表”。

测试用例：

- `本年度的高炉工序能耗趋势是什么样的` -> parser => intent=analysis/list_query with timeRange; 

  pipeline => fetch monthly series 2025-01..2025-09, return series + basic conclusion.

------

### 步骤 7 — Graph/Relation 设计（供分析/追溯）

目的：使 graph 支持多指标、多时间、关系（compare/group/trend）以及结果元数据（来源、时间戳、result summary）。

节点 schema 建议：

```
{
  "id": 123,
  "name": "高炉工序能耗实绩报出值",
  "formula": "GXNHLT1100.IXRL",
  "timeString": "2025-11-07",
  "timeType": "DAY",
  "value": 123.4,
  "source": "db_api",
  "fetched_at": "2025-11-07T09:00:00"
}
```

relation types:

- `compare` (source,target, meta)
- `group` (list of nodes grouped by user query)
- `trend` (node -> node sequence meta)
- meta 中保存 `via`（pipeline.compare/pipeline.trend）、`user_input`、`result_summary`

实现要点：

- parser 在解析时只写参考节点/关系（如 group/compare intent）。pipeline 在成功查询并生成结果时再把真实值写入 graph（如果 graph 是持久的）。
- graph 用于后续缓存与复用。

------

### 步骤 8 — 单元测试套件（把你表里的用例转成自动化测试）

为每一种场景写单元测试，用例包括（示例）：

1. 单指标单时间（single_query）
   - 输入：`今天的高炉工序能耗是多少`
   - 期望：intent=single_query; indicators len=1; time=今天 (DAY) ; slot_status.time=filled
2. 单指标无时间（需要默认/提示）
   - 输入：`高炉工序能耗是多少`
   - 期望：slot_requirements.need_time=true; indicators[0].slot_status.time=missing
3. 多指标同时间（list_query）
   - 输入：`本月1、2号高炉工序能耗是多少`
   - 期望：intent=list_query; indicators len=2; both time=本月（filled）
4. 对比（compare）
   - Inputs: R1 `今天的高炉工序能耗是多少` -> R2 `去年今天的呢`
   - 期望：第二次 intent => same_indicator_new_time or compare (取决 LLM)，graph 有 compare relation; pipeline 计算差值
5. 多轮继承时间
   - R1 `本月的高炉工序能耗是多少` (single_query) -> R2 `1#、2#分别是多少` -> R2 indicators have time=inferred from R1
6. 模糊匹配/候选选择
   - 输入：`高炉的煤气耗是多少`
   - 期望：parser 返回 indicators[0].slot_status.name=ambiguous + candidates list in note
7. 趋势分析（analysis）
   - 输入：`本年度的高炉工序能耗趋势是什么样的`
   - 期望：timeType=RANGE; pipeline 获取序列并生成 summary

测试实现方式：

- 把 `parse_user_input` 做成可 mock 的函数（在测试时用固定返回），以便专注测试 parser 的分解逻辑与 LLM prompt 适配（LLM 部分可以模拟 safe_llm_parse 的返回）。

------

### 步骤 9 — 详细开发/集成清单（按实现顺序）

1. 在 `EnergyIntentParser` 中**实现** LLM prompt 要求返回 `{intent,candidates}` 并处理其容错（若 LLM 不给 candidates，使用 heuristic split）。
2. 在 parser 中实现 `candidates -> parse_user_input -> indicators[]` 的包装逻辑（如上伪码）。
3. 把 `slot_status`、`slot_requirements` 与 `inference` 字段加入返回的 `intent_info`。
4. 增加 parser.history 的结构变更（每条保存 indicators 列表与解析元数据）。
5. pipeline：实现 `consume_intent_info(intent_info)` 的骨架（batch lookup/cache -> batch_query -> 补槽交互/候选选择 -> 返回结果/写 graph）。
6. graph：保持 parser 的参考性写入；在 pipeline 成功获取 value 后真正写入 graph（持久储存/缓存）。
7. 编写单元测试覆盖上面所有测试用例，重点模拟 `parse_user_input` 与 `safe_llm_parse` 返回。
8. 集成测试：把 pipeline 和 parser 联合运行，确保多轮继承、候选选择、缓存复用等流畅。

------

### 额外建议与实现细节（tips）

- LLM 的 `candidates` 不必完美：只需足够把多指标拆成单句，parser 再靠 `parse_user_input` 得到精确字段。
- 对 `ambiguous`，把解析出的多个 candidate formula 放入 `indicators[i].candidates_formulas = [{"name":..., "formula":...}, ...]`，供前端展示选择。
- 对 `inferred` 时间，**在返回给用户的第一句中明确标注**（例如“已使用上一轮时间：2025-11（如需修改请回复）”），减少误解。
- 保持 `parse_user_input` 错误与异常捕获，parser 如果连续 N 次解析失败，应触发“请明确您要查询的指标或举例”这类 fallback prompt。
- 为 trend/analysis 场景，pipeline 需支持把 `time`拆解成时间区间形式调用能源系统后端接口。

## 6.14 V2实现

### 一、程序入口

```python
import os
for key in ["HTTP_PROXY", "HTTPS_PROXY", "ALL_PROXY", "http_proxy", "https_proxy", "all_proxy"]:
    os.environ.pop(key, None)

import asyncio
import time
import logging
from fastapi import FastAPI, Query, Request
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
from core.intent_router import route_intent
from tools import formula_api
from agent_state import get_state, update_state, cleanup_expired_sessions


# ----------------------
# 初始化日志
# ----------------------
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s | %(levelname)s | %(message)s"
)
logger = logging.getLogger(__name__)

app = FastAPI(title="智能能源多意图对话引擎")

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"], allow_credentials=True, allow_methods=["*"], allow_headers=["*"]
)

# ----------------------
# 启动事件
# ----------------------
@app.on_event("startup")
async def startup_event():
    """
    在服务启动时执行：
      - 初始化公式数据（同步加载）；
      - 启动清理任务；
    """
    try:
        start = time.time()
        # 只初始化一次，不会重复加载
        formula_api.initialize()
        logger.info(f"✅ formula_api 初始化完成，用时 {time.time() - start:.2f}s")
    except Exception as e:
        logger.exception("❌ 初始化 formula_api 失败: %s", e)

    asyncio.create_task(cleanup_expired_sessions())
    logger.info("🧹 已启动 session 定期清理任务。")

@app.get("/chat")
async def chat_get(
    user_id: str = Query(..., description="用户唯一标识，例如 test1"),
    message: str = Query(..., description="用户输入内容")
):
    result = await route_intent(user_id, message)
    return result
```

* 还保留着`agent_state`是因为还没有想到上下文图谱周期应该怎么管理，现在都是按照不同的`user_id`累积到内存，重启后清空。后续所有都不涉及`agent_state`,也就是前面所有的插槽控制都交给了`ContextGraph`。
* Post入口需不需要？
* `user_id`在这里也不一定指用户名，可以是一切唯一的业务名。比如openwebui里的`chat_id`。

### 二、意图路由

```python
# core/intent_router.py
import logging
import time
from typing import Dict, Any

from core import llm_intent_parser as lightweight_intent    # 轻量意图分类（只判断 intent）
from core.llm_client import safe_llm_chat
from core.energy_query_runner import run_energy_query

# 日志配置（被导入时确保仅配置一次）
logger = logging.getLogger("intent_router")
if not logger.handlers:
    logging.basicConfig(
        level=logging.INFO,
        format="%(asctime)s | %(levelname)s | %(name)s | %(message)s"
    )

async def route_intent(user_id: str, user_input: str) -> Dict[str, Any]:
    """
    意图路由器（V2）：
    1) 先使用轻量意图分类器判断 intent（避免重复解析）
    2) 若为 ENERGY_QUERY：使用 EnergyIntentParser.parse_intent 完成指标+时间解析并更新上下文
       然后交由 pipeline.process_message 做查询/聚合/格式化（pipeline 依赖 graph）
    3) TOOL / CHAT / ENERGY_KNOWLEDGE_QA 分流到相应处理逻辑
    返回字典包含 reply 与调试信息（intent_info / graph_state / error）
    """
    logger.info(f"🟢 [route_intent] user={user_id!r} input={user_input!r}")

    # ---------- Step A: 轻量意图判断（只返回 intent） ----------
    try:
        lightweight = await lightweight_intent.parse_intent(user_id, user_input)
        intent = (lightweight or {}).get("intent", "CHAT")
        parsed_number = (lightweight or {}).get("parsed_number", None)
        logger.info(f"🔎 轻量意图分类结果: {intent} (raw: {lightweight})")
    except Exception as e:
        logger.exception("❌ 轻量意图分类失败，退回 CHAT：%s", e)
        intent = "CHAT"
        parsed_number = None

    # ---------- Step B: 分流 ----------
    # 1) ENERGY_QUERY: 使用 EnergyIntentParser（含 context graph）
    if intent == "ENERGY_QUERY":
        logger.info("⚙️ 检测到 ENERGY_QUERY，进入能源问数流程")
        return await run_energy_query(user_id, user_input, parsed_number)

    # 2) ENERGY_KNOWLEDGE_QA: 知识问答
    elif intent == "ENERGY_KNOWLEDGE_QA":
        logger.info("📘 检测到 ENERGY_KNOWLEDGE_QA，生成解释型回答")
        t_chat_start = time.perf_counter()
        reply = await safe_llm_chat(
            f"请能源专家身份解释以下能源知识问题：{user_input}"
        )
        t_chat_end = time.perf_counter()
        logger.info(f"🗨️ 生成成功 | ⏱️ LLM cost={1000*(t_chat_end-t_chat_start):.1f}ms")
        return {"reply": reply, "intent_info": {"intent": "ENERGY_KNOWLEDGE_QA"}}
    
    # 3) TOOL: 简单工具（例如当前时间）
    elif intent == "TOOL":
        logger.info("🛠️ 检测到 TOOL 意图，进入工具处理")

        from core.llm_time_parser import parse_time_question
        try:
            res = await parse_time_question(user_input)
            return {"reply": res["answer"], "intent_info": res}
        except Exception as e:
            logger.exception("❌ 时间问答失败: %s", e)
            return {"reply": "当前仅支持时间工具，无法解析该问题。", "error": str(e)}

    # 4) CHAT: 通用聊天由 LLM 直接回复
    else:
        logger.info("💬 检测到 CHAT 意图，转给通用聊天模型")
        try:
            chat_reply = await safe_llm_chat(user_input)
            return {"reply": chat_reply, "intent_info": {"intent": "CHAT"}}
        except Exception as e:
            logger.exception("❌ safe_llm_chat 调用失败: %s", e)
            return {"reply": "聊天服务出错。", "error": str(e)}
            
# core/llm_intent_parser.py
import logging
import asyncio
from core.llm_client import safe_llm_parse
from core.context_graph import ContextGraph, default_indicators
from core.pipeline_context import get_graph, set_graph

logger = logging.getLogger("llm_intent_parser")
if not logger.handlers:
    logging.basicConfig(
        level=logging.INFO,
        format="%(asctime)s | %(levelname)s | %(name)s | %(message)s"
    )


async def parse_intent(user_id: str, user_input: str) -> dict:
    """
    新版轻量意图分类（基于 ContextGraph 状态）
    - graph_state: {
          "graph": {...},
          "meta": {
              "history": [...],
              "current_intent_info": {...}
          }
      }

    返回:
    {
        "intent": "ENERGY_QUERY" | "CHAT" | "TOOL" | "ENERGY_KNOWLEDGE_QA",
        "parsed_number": int 或 None
    }
    """
    # 获取 graph
    graph = get_graph(user_id)
    if not graph:
        graph = ContextGraph()
        set_graph(user_id, graph)
        logger.info("✨ 创建新的 ContextGraph")

    history = graph.get_history()

    # 提取上次指标和候选公式
    current_intent_info = graph.get_intent_info()
    indicators = current_intent_info.get("indicators", [])

    # ---------- 查找当前 active indicator ----------
    current_indicator = None
    for ind in indicators:
        if ind.get("status") == "active":
            current_indicator = ind
            break

    # 如果没有 active 的，就新建一个
    if not current_indicator:
        current_indicator = default_indicators()
        indicators.append(current_indicator)

    last_indicator = current_indicator.get("indicator")
    formula_candidates = current_indicator.get("formula_candidates", [])
    awaiting_confirmation = bool(formula_candidates)

    # 历史摘要
    history_summary = ""
    if history:
        recent = history[-3:]
        history_summary = "\n".join([
            f"- {h.get('ask')} -> {h.get('reply')[:200]}..." for h in recent
        ])

    # 槽位状态摘要
    slot_status = current_indicator.get("slot_status", {})
    slots_summary = "\n".join([
        f"{k}: {v}" for k, v in slot_status.items()
    ]) if slot_status else "(空)"

    # 候选公式概览
    candidates_summary = ""
    if formula_candidates:
        candidates_summary = "\n".join([
            f"{c['number']}) {c['FORMULANAME']} (score {c['score']:.2f})"
            for c in formula_candidates[:5]
        ])

    # 拼接 prompt
    prompt = f"""
你是一个智能意图识别器，根据上下文判断用户意图。
意图类型：
- ENERGY_QUERY: 用户想查询能源指标数据（包括初次查询、补充时间、或正在选择候选公式）
- ENERGY_KNOWLEDGE_QA: 解释能源概念或定义的问题
- CHAT: 普通闲聊或非结构化提问
- TOOL: 工具类问题（时间、日期、天气等）
用户输入: "{user_input}"
当前指标: "{last_indicator}"
最近对话: {history_summary if history_summary else '(无)'}
槽位状态: {slots_summary}
候选公式: {candidates_summary if candidates_summary else '(无)'}

规则优先级：
1. 如果用户正在选择候选公式：
   - 输入为数字或序号指代（如“1”“第二个”） → ENERGY_QUERY。
   - 输入与能源无关 → CHAT。
2. 如果当前处于能源查询流程，
   且用户输入包含时间表达（如“今天”“昨天”“2022年的今天”“上月”），
   则视为 ENERGY_QUERY —— 表示用户在补充查询时间，而不是单纯问时间。
3. 能源概念/定义/结构/用途类问题 → ENERGY_KNOWLEDGE_QA
4. 能源指标/单位/消耗量 → ENERGY_QUERY
5. 日期/时间/天气 → TOOL
6. 其他 → CHAT

⚠️ 强调：
- 问“是什么”“包括哪些”“用途”“定义”“作用”“组成”等能源相关概念性问题，必须返回 ENERGY_KNOWLEDGE_QA
- 问具体数值、消耗量、用量时才返回 ENERGY_QUERY

返回 JSON：
{{
  "intent": "ENERGY_QUERY" 或 "CHAT" 或 "TOOL" 或 "ENERGY_KNOWLEDGE_QA",
  "parsed_number": 若输入为候选编号或“选第一条”等 → 提取数字，否则为 null
}}
"""

    logger.info(f"🔍 [parse_intent] user_input='{user_input}', indicator='{last_indicator}', awaiting={awaiting_confirmation}")

    try:
        print(prompt)
        result = await safe_llm_parse(prompt)
        # 合并 LLM 返回（防止 LLM 也返回）
        intent = result.get("intent", "CHAT")
        parsed_number = result.get("parsed_number")
        logger.info(f"📥 轻量意图分类结果: intent={intent}, parsed_number={parsed_number}")
        return {"intent": intent, "parsed_number": parsed_number}
    except Exception as e:
        logger.exception("❌ LLM parse_intent 调用失败: %s", e)
        return {"intent": "CHAT", "parsed_number": None}
```

* 有了外层轻量意图分类器就可以很容易接入其它功能，比如查时间工具，将来的知识库问答，还有兜底的聊天功能。
* 上下文图谱好像并不太影响意图分类。也就是当前没有上下文，输入“选第一个”，也会自动引导进能源问数流程中去。

### 三、能源意图

```python
# core/energy_query_runner.py
import logging
from core.llm_energy_intent_parser import EnergyIntentParser
from core.pipeline import process_message
from core.pipeline_context import get_graph, set_graph
from core.context_graph import ContextGraph

logger = logging.getLogger("energy_query_runner")
if not logger.handlers:
    logging.basicConfig(
        level=logging.INFO,
        format="%(asctime)s | %(levelname)s | %(name)s | %(message)s"
    )

async def run_energy_query(user_id: str, user_input: str, parsed_number: str | None):
    """
    能源查询主入口：
    - EnergyIntentParser 解析意图（无状态）
    - 将意图信息写入 ContextGraph
    - 调用 pipeline 处理
    """
    logger.info(f"⚙️ [run_energy_query] user={user_id} input={user_input!r}")

    # 获取或创建 graph
    graph = get_graph(user_id)
    if not graph:
        graph = ContextGraph()
        set_graph(user_id, graph)
        logger.info("✨ 创建新的 ContextGraph")
    else:
        logger.info("♻️ 使用已有 ContextGraph")

    # 只有在用户不是通过数字选择候选（parsed_number is None）时，才使用能源意图解析批量的candidates
    if parsed_number is None:
        # 解析意图（无状态）
        try:
            logger.info(f"🧩 传入 EnergyIntentParser.parse_intent 参数: {user_input}")
            parser = EnergyIntentParser()
            current_intent = await parser.parse_intent(user_input)
            logger.info(f"🧾 parse_intent 返回 intent={current_intent.get('intent')}")
        except Exception as e:
            logger.exception("❌ EnergyIntentParser.parse_intent 失败: %s", e)
            return {"reply": "解析能源意图失败，请稍后重试。", "error": "parse_intent_failed"}
    else:
        current_intent = {"intent":"clarify","candidates": None}
    # 不能写入 graph 中，因为可能存在clarify和slot_fill的中间态，需要把当前意图传入后续进行判断
    # graph.set_intent_info(intent_info)

    # 4️⃣ 执行主 pipeline
    try:
        reply, graph_state = await process_message(user_id, user_input, current_intent=current_intent)
        logger.info("✅ pipeline.process_message 执行成功")
        return {
            "reply": reply,
            #"intent_info": ContextGraph.from_state(graph_state).get_intent_info(),
            "graph_state": graph_state
        }

    except Exception as e:
        logger.exception("❌ pipeline 执行失败: %s", e)
        return {"reply": "能源查询流程执行失败。", "error": str(e), "intent": current_intent}
        
# core/llm_energy_intent_parser.py
import json
import asyncio
import logging
from core.llm_client import safe_llm_parse  # 你的安全 LLM 调用封装

logger = logging.getLogger("llm_energy_intent_parser")
if not logger.handlers:
    logging.basicConfig(
        level=logging.INFO,
        format="%(asctime)s | %(levelname)s | %(name)s | %(message)s"
    )


class EnergyIntentParser:
    """
    能源意图解析器：
    - 统一识别用户输入的意图类型（single_query, list_query, compare, analysis, slot_fill, clarify）
    - 生成 candidates（单指标单时间查询短句）
    """

    INTENT_PROMPT = """
你是能源意图识别器，请严格返回 JSON:
{"intent":"...", "candidates":["...","..."]}

说明：
- intent 取值范围: "single_query","list_query","compare","analysis","slot_fill","clarify"。
- candidates: 将输入拆为若干“单时间单指标”短句，即拼接成“时间+指标”(时间在前，指标在后)的形式，用于后续解析指标和时间。
  例如:
  - 输入: "本月1、2号高炉工序能耗是多少"，输出: {"intent":"list_query","candidates":["本月1号高炉工序能耗","本月2号高炉工序能耗"]}。
- 指标中可能包含描述性质的后缀词（如“累计”、“计划”、“目标”、“完成值”、“用量”、“指标”、“成本”、“效率”、“总量”、“单耗”、“强度”等），可以放在每条记录最后面。
  例如:
  - 输入: "本月累计的高炉工序能耗是多少"，输出: {"intent":"single_query","candidates":["本月高炉工序能耗累计"]}。
- 指标不要随意添加和改写。1高炉就是1高炉，1#高炉就是1#高炉，**不要私自**改为1号高炉。
  例如:
  - 输入: "时间：2021-10-23，1高炉工序能耗是多少"，输出: {"intent":"single_query","candidates":["2021年10月23日1高炉工序能耗"]}
  - 输入: "本月的2#高炉工序能耗是多少？"，输出: {"intent":"single_query","candidates":["本月2#高炉工序能耗"]}
  - 输入: "本月1，2，3高炉工序能耗分别是多少"，输出: {'intent': 'list_query', 'candidates': ['本月1高炉工序能耗', '本月2高炉工序能耗', '本月3高炉工序能耗']}
- 如果输入是上下文补充型，但有明确时间或指标信息，请仍返回 single_query。
- 如果输入是纯对比或偏差类问题，如“它们对比呢”“偏差情况”，返回 compare。
- 如果输入中包含多个时间或多个对象，请拆分成多条 candidates。
- 如果输入的明确的肯定语气的时间信息，则表示用户在补全信息，则返回 slot_fill。

示例：

输入: "它们对比呢"
输出: {"intent":"compare","candidates":[]}

输入： "对比上月有什么变化"
输出: {"intent":"compare","candidates":["上月"]}

输入： "对比1号高炉有什么变化"
输出: {"intent":"compare","candidates":["1号高炉"]}

输入: "偏差情况"
输出: {"intent":"compare","candidates":[]}

输入: "去年呢"
输出: {"intent":"single_query","candidates":["去年"]}

输入: "去年"
输出: {"intent":"slot_fill","candidates":["去年"]}

输入: "再看酸轧能耗"
输出: {"intent":"single_query","candidates":["酸轧能耗"]}

输入: "本月高炉工序能耗是多少，对比计划偏差多少"
输出: {"intent":"compare","candidates":["本月高炉工序能耗","本月高炉工序能耗计划"]}

输入: "本年度的高炉工序能耗趋势是什么样的"
输出: {"intent":"analysis","candidates":["本年度高炉工序能耗"]}

输入: "高炉工序今天的能耗是多少"
输出: {"intent":"single_query","candidates":["今天高炉工序能耗"]}

输入: "本月1、2号高炉工序能耗偏差情况"
输出: {"intent":"compare","candidates":["本月1号高炉工序能耗","本月2号高炉工序能耗"]}
"""

    def __init__(self):
        pass

    async def parse_intent(self, user_input: str) -> dict:
        """
        使用 LLM 判断意图 + 初步分解。
        """
        try:
            # 调用 LLM
            data = await safe_llm_parse(self.INTENT_PROMPT + "\n输入: " + user_input)

            # ✅ 确保输出是 dict
            if not isinstance(data, dict):
                logger.warning(f"[parse_intent] LLM 输出非 dict，使用 fallback。输出: {data}")
                data = {}

            intent = data.get("intent")
            candidates = data.get("candidates")

            # fallback 逻辑
            if not intent:
                intent = self._fallback_intent(user_input)
            if not isinstance(candidates, list) or not candidates:
                candidates = self._fallback_candidates(user_input)

            result = {
                "intent": intent,
                "candidates": candidates
            }

            logger.info(f"[parse_intent] user_input={user_input} => {result}")
            return result

        except Exception as e:
            logger.error(f"[parse_intent] ❌ Exception: {e}")
            return {"intent": "unknown", "candidates": []}

    # --------- 内部辅助函数 ---------
    def _fallback_intent(self, user_input: str) -> str:
        """
        基于简单关键词的备选意图猜测，仅在 LLM 无法解析时使用。
        """
        if any(k in user_input for k in ["对比", "相比", "差异", "偏差", "变化"]):
            return "compare"
        if any(k in user_input for k in ["平均", "趋势"]):
            return "analysis"
        if any(k in user_input for k in ["和", "、"]):
            return "list_query"
        if any(k in user_input for k in ["呢", "去年", "今天", "补充"]):
            return "slot_fill"
        return "single_query"

    def _fallback_candidates(self, user_input: str) -> list:
        """
        简单分词分割（逗号、顿号、and、和 等）来拆分多查询。
        """
        separators = ["、", ",", "，", "和", "以及", "and"]
        for sep in separators:
            if sep in user_input:
                parts = [p.strip() for p in user_input.split(sep) if p.strip()]
                if len(parts) > 1:
                    return parts
        return [user_input]


# ========== 测试主函数 ==========
async def main():
    parser = EnergyIntentParser()

    test_inputs = [
        "本月1，2，3高炉工序能耗分别是多少",
        "高炉工序能耗是多少，对比计划偏差多少",
        "本月高炉工序能耗是多少，对比计划偏差多少",
        "今天",
        "高炉今天的工序能耗是多少",
        "本月累计的高炉工序能耗是多少",
        "1号高炉昨天的工序能耗是多少",
        "去年今天的高炉工序能耗是多少",
        "2021年10月23日的1高炉工序能耗是多少",
        "时间：2021-10-23，1高炉工序能耗是多少",
        "高炉工序能耗是多少",
        "本月1、2号高炉工序能耗是多少",
        "高炉工序能耗本月计划是多少",
        "本月高炉工序能耗的计划值是多少",
        "今天的高炉工序能耗是多少",
        "对比上月有什么变化",
        "本月的1高炉工序能耗是多少？",
        "对比2高炉有什么变化",
        "本月的高炉电耗是多少",
        "本月的高炉电使用量是多少",
        "高炉的煤气耗是多少",
        "10号高炉今天的工序能耗是多少",
        "本月的高炉工序能耗是多少？",
        "1#，2#，3#高炉分别是多少",
        "本月高炉工序能耗是多少，对比计划偏差多少",
        "本年度的高炉工序能耗趋势是什么样的",
        "本月1、2号高炉工序能耗偏差情况"
    ]

    for t in test_inputs:
        result = await parser.parse_intent(t)
        print(f"\n🧠 输入: {t}\n➡️ 解析结果: {json.dumps(result, ensure_ascii=False, indent=2)}")


if __name__ == "__main__":
    asyncio.run(main())
```

* 能源意图llm分析是完成多意图多轮次批量操作的关键，通过拆解用户输入，首先分析用户意图，然后直接分析出指标的个数。这是解决上一版本无法实现二步问数对比的钥匙。

* 上下文图谱中的intent_snapshot是让上下文有记忆有延续的原因。

  ```json
  "graph": {
              "nodes": [
              {
                  "id": 1,
                  "indicator_entry": {
                  "status": "completed",
                  "indicator": "1高炉工序能耗实绩报出值",
                  "formula": "GXNHLT1101.IXRL",
                  "timeString": "2022-01-01",
                  "timeType": "DAY",
                  "slot_status": {
                      "formula": "filled",
                      "time": "filled"
                  },
                  "value": "381.65",
                  "note": "✅ 1高炉工序能耗实绩报出值 在 2022-01-01 (DAY) 的值是 381.65 ",
                  "formula_candidates": [
                      {
                      "number": 1,
                      "FORMULAID": "GXNHLT1101.IXPL",
                      "FORMULANAME": "1高炉工序能耗计划报出值",
                      "score": 91.7787,
                      "fuzzy_score": 95.4909,
                      "semantic_score": 81.9644,
                      "match_kind": "hybrid"
                      },
                      {
                      "number": 2,
                      "FORMULAID": "GXNHLT1101.IXPL.SUMVALUE",
                      "FORMULANAME": "1高炉工序能耗计划累计值",
                      "score": 88.6605,
                      "fuzzy_score": 92.6545,
                      "semantic_score": 83.2141,
                      "match_kind": "hybrid"
                      },
                      {
                      "number": 3,
                      "FORMULAID": "PHNHLT1101.IXPL",
                      "FORMULANAME": "1高炉工序平衡能耗计划报出值",
                      "score": 88.4603,
                      "fuzzy_score": 95.4909,
                      "semantic_score": 76.6991,
                      "match_kind": "hybrid"
                      },
                      {
                      "number": 4,
                      "FORMULAID": "GXNHLT1101.IXRL",
                      "FORMULANAME": "1高炉工序能耗实绩报出值",
                      "score": 87.768,
                      "fuzzy_score": 99.1636,
                      "semantic_score": 67.9943,
                      "match_kind": "hybrid"
                      },
                      {
                      "number": 5,
                      "FORMULAID": "GXNHLT1100.IXRL",
                      "FORMULANAME": "高炉工序能耗实绩报出值",
                      "score": 87.2049,
                      "fuzzy_score": 87.264,
                      "semantic_score": 75.0671,
                      "match_kind": "hybrid"
                      }
                  ]
                  },
                  "intent_info_snapshot": {
                  "user_input_list": [
                      "2022年1号高炉工序能耗是多少，对比计划偏差多少",
                      "4"
                  ],
                  "intent_list": [
                      "compare",
                      "clarify"
                  ],
                  "indicators": [
                      {
                      "status": "completed",
                      "indicator": "1高炉工序能耗实绩报出值",
                      "formula": "GXNHLT1101.IXRL",
                      "timeString": "2022-01-01",
                      "timeType": "DAY",
                      "slot_status": {
                          "formula": "filled",
                          "time": "filled"
                      },
                      "value": "381.65",
                      "note": "✅ 1高炉工序能耗实绩报出值 在 2022-01-01 (DAY) 的值是 381.65 ",
                      "formula_candidates": [
                          {
                          "number": 1,
                          "FORMULAID": "GXNHLT1101.IXPL",
                          "FORMULANAME": "1高炉工序能耗计划报出值",
                          "score": 91.7787,
                          "fuzzy_score": 95.4909,
                          "semantic_score": 81.9644,
                          "match_kind": "hybrid"
                          },
                          {
                          "number": 2,
                          "FORMULAID": "GXNHLT1101.IXPL.SUMVALUE",
                          "FORMULANAME": "1高炉工序能耗计划累计值",
                          "score": 88.6605,
                          "fuzzy_score": 92.6545,
                          "semantic_score": 83.2141,
                          "match_kind": "hybrid"
                          },
                          {
                          "number": 3,
                          "FORMULAID": "PHNHLT1101.IXPL",
                          "FORMULANAME": "1高炉工序平衡能耗计划报出值",
                          "score": 88.4603,
                          "fuzzy_score": 95.4909,
                          "semantic_score": 76.6991,
                          "match_kind": "hybrid"
                          },
                          {
                          "number": 4,
                          "FORMULAID": "GXNHLT1101.IXRL",
                          "FORMULANAME": "1高炉工序能耗实绩报出值",
                          "score": 87.768,
                          "fuzzy_score": 99.1636,
                          "semantic_score": 67.9943,
                          "match_kind": "hybrid"
                          },
                          {
                          "number": 5,
                          "FORMULAID": "GXNHLT1100.IXRL",
                          "FORMULANAME": "高炉工序能耗实绩报出值",
                          "score": 87.2049,
                          "fuzzy_score": 87.264,
                          "semantic_score": 75.0671,
                          "match_kind": "hybrid"
                          }
                      ]
                      },
                      {
                      "status": "active",
                      "indicator": "1号高炉工序能耗计划",
                      "formula": None,
                      "timeString": "2022-01",
                      "timeType": "MONTH",
                      "slot_status": {
                          "formula": "missing",
                          "time": "filled"
                      },
                      "value": None,
                      "note": None,
                      "formula_candidates": None
                      }
                  ]
                  }
              }
              ],
              "relations": [],
              "_next_id": 2
          },
          "meta": {
              "history": [
              {
                  "ask": "2022年1号高炉工序能耗是多少，对比计划偏差多少",
                  "reply": "没有完全匹配的[1号高炉工序能耗]指标，请从以下候选选择编号(或者重新输入尽量精确的指标名称：\n1) 1高炉工序能耗计划报出值 (score 91.78)\n2) 1高炉工序能耗计划累计值 (score 88.66)\n3) 1高炉工序平衡能耗计划报出值 (score 88.46)\n4) 1高炉工序能耗实绩报出值 (score 87.77)\n5) 高炉工序能耗实绩报出值 (score 87.20)"
              },
              {
                  "ask": "4 -> system:完成 clarify 并检测到 compare 上下文，继续执行 handle_compare...",
                  "reply": "没有完全匹配的[1号高炉工序能耗计划]指标，请从以下候选选择编号(或者重新输入尽量精确的指标名称：\n1) 1高炉工序能耗计划报出值 (score 93.78)\n2) 高炉工序能耗计划报出值 (score 90.66)\n3) 1高炉工序平衡能耗计划报出值 (score 90.47)\n4) 1高炉工序能耗计划累计值 (score 90.09)\n5) 2高炉工序能耗计划报出值 (score 87.18)"
              }
              ],
              "current_intent_info": {
              "user_input_list": [
                  "2022年1号高炉工序能耗是多少，对比计划偏差多少",
                  "4",
                  "4 -> system:完成 clarify 并检测到 compare 上下文，继续执行 handle_compare..."
              ],
              "intent_list": [
                  "compare",
                  "clarify",
                  "compare"
              ],
              "indicators": [
                  {
                  "status": "completed",
                  "indicator": "1高炉工序能耗实绩报出值",
                  "formula": "GXNHLT1101.IXRL",
                  "timeString": "2022-01-01",
                  "timeType": "DAY",
                  "slot_status": {
                      "formula": "filled",
                      "time": "filled"
                  },
                  "value": "381.65",
                  "note": "✅ 1高炉工序能耗实绩报出值 在 2022-01-01 (DAY) 的值是 381.65 ",
                  "formula_candidates": [
                      {
                      "number": 1,
                      "FORMULAID": "GXNHLT1101.IXPL",
                      "FORMULANAME": "1高炉工序能耗计划报出值",
                      "score": 91.7787,
                      "fuzzy_score": 95.4909,
                      "semantic_score": 81.9644,
                      "match_kind": "hybrid"
                      },
                      {
                      "number": 2,
                      "FORMULAID": "GXNHLT1101.IXPL.SUMVALUE",
                      "FORMULANAME": "1高炉工序能耗计划累计值",
                      "score": 88.6605,
                      "fuzzy_score": 92.6545,
                      "semantic_score": 83.2141,
                      "match_kind": "hybrid"
                      },
                      {
                      "number": 3,
                      "FORMULAID": "PHNHLT1101.IXPL",
                      "FORMULANAME": "1高炉工序平衡能耗计划报出值",
                      "score": 88.4603,
                      "fuzzy_score": 95.4909,
                      "semantic_score": 76.6991,
                      "match_kind": "hybrid"
                      },
                      {
                      "number": 4,
                      "FORMULAID": "GXNHLT1101.IXRL",
                      "FORMULANAME": "1高炉工序能耗实绩报出值",
                      "score": 87.768,
                      "fuzzy_score": 99.1636,
                      "semantic_score": 67.9943,
                      "match_kind": "hybrid"
                      },
                      {
                      "number": 5,
                      "FORMULAID": "GXNHLT1100.IXRL",
                      "FORMULANAME": "高炉工序能耗实绩报出值",
                      "score": 87.2049,
                      "fuzzy_score": 87.264,
                      "semantic_score": 75.0671,
                      "match_kind": "hybrid"
                      }
                  ]
                  },
                  {
                  "status": "active",
                  "indicator": "1号高炉工序能耗计划",
                  "formula": None,
                  "timeString": "2022-01",
                  "timeType": "MONTH",
                  "slot_status": {
                      "formula": "missing",
                      "time": "filled"
                  },
                  "value": None,
                  "note": None,
                  "formula_candidates": [
                      {
                      "number": 1,
                      "FORMULAID": "GXNHLT1101.IXPL",
                      "FORMULANAME": "1高炉工序能耗计划报出值",
                      "score": 93.7797,
                      "fuzzy_score": 97.5371,
                      "semantic_score": 83.7753,
                      "match_kind": "hybrid"
                      },
                      {
                      "number": 2,
                      "FORMULAID": "GXNHLT1100.IXPL",
                      "FORMULANAME": "高炉工序能耗计划报出值",
                      "score": 90.6642,
                      "fuzzy_score": 88.88,
                      "semantic_score": 84.6033,
                      "match_kind": "hybrid"
                      },
                      {
                      "number": 3,
                      "FORMULAID": "PHNHLT1101.IXPL",
                      "FORMULANAME": "1高炉工序平衡能耗计划报出值",
                      "score": 90.4736,
                      "fuzzy_score": 97.5371,
                      "semantic_score": 78.5294,
                      "match_kind": "hybrid"
                      },
                      {
                      "number": 4,
                      "FORMULAID": "GXNHLT1101.IXPL.SUMVALUE",
                      "FORMULANAME": "1高炉工序能耗计划累计值",
                      "score": 90.0906,
                      "fuzzy_score": 94.64,
                      "semantic_score": 84.229,
                      "match_kind": "hybrid"
                      },
                      {
                      "number": 5,
                      "FORMULAID": "GXNHLT1102.IXPL",
                      "FORMULANAME": "2高炉工序能耗计划报出值",
                      "score": 87.1809,
                      "fuzzy_score": 88.88,
                      "semantic_score": 79.0764,
                      "match_kind": "hybrid"
                      }
                  ]
                  }
              ]
              }
          }
      }
  ```

### 四、管道分流

```python
# core/pipeline.py
import logging
from core.context_graph import ContextGraph
from core.pipeline_handlers import (
    handle_single_query, handle_compare, handle_analysis,
    handle_slot_fill, handle_list_query, handle_clarify
)
from core.pipeline_context import get_graph, set_graph

logger = logging.getLogger("pipeline")
if not logger.handlers:
    logging.basicConfig(
        level=logging.INFO,
        format="%(asctime)s | %(levelname)s | %(name)s | %(message)s"
    )

async def process_message(user_id: str, user_input: str, current_intent: dict | None = None):
    """
    主流程入口：
    - 获取用户 ContextGraph
    - 根据 intent 分流到各 pipeline_handler
    """
    user_input = str(user_input or "").strip()
    logger.info(f"🟢 [process_message] user={user_id!r} input={user_input!r}")

    # 获取 graph
    graph = get_graph(user_id)
    if not graph:
        graph = ContextGraph()
        set_graph(user_id, graph)
        logger.info("✨ 创建新的 ContextGraph")

    # 当前意图信息
    last_intent_info = graph.get_intent_info()
    intent = current_intent.get("intent", "single_query")
    logger.info(f"🚦 当前 intent={intent}，系统保留 intent={last_intent_info.get("intent")}")

    # ---------- 根据 intent 调用分支 ----------
    if intent == "compare":
        return await handle_compare(user_id, user_input, graph, current_intent)
    elif intent == "analysis":
        return await handle_analysis(user_id, user_input, graph)
    elif intent == "slot_fill":
        return await handle_slot_fill(user_id, user_input, graph, current_intent)
    elif intent == "list_query":
        return await handle_list_query(user_id, user_input, graph, current_intent)
    elif intent == "clarify":
        return await handle_clarify(user_id, user_input, graph)
    else:
        return await handle_single_query(user_id, user_input, graph)
```

* `slot_fill`和`clarify`只是无法自己发起，都是从当前意图判断是否继续执行`compare`或者是`list_query`。
* `analysis`还未实现，因为还不清楚前端如何显示图表内容，属于问数第三阶段内容。
* `list_query`现在是无状态的，也就是无法继承上一轮指标和时间，不然可能导致实际结果会不停累加。当然还有优化的空间。

### 五、意图实现

```python
# core/pipeline_handlers.py
import json
import asyncio
import logging
import inspect
from core.context_graph import ContextGraph, default_indicators
from core.llm_energy_indicator_parser import parse_user_input
from tools import formula_api, platform_api
from core.pipeline_context import set_graph, get_graph
from core.llm_indicator_compare import call_compare_llm


logger = logging.getLogger("pipeline.handlers")
if not logger.handlers:
    logging.basicConfig(
        level=logging.INFO,
        format="%(asctime)s | %(levelname)s | %(name)s | %(message)s"
    )

TOP_N = 5

# ------------------------- 单指标查询 -------------------------
async def handle_single_query(user_id: str, user_input: str, graph: ContextGraph):
    logger.info("✅ 进入 single query 模式。")
    """
    基础能源查询：
    - 补全指标/时间
    - 调用 formula_api 查询公式
    - 自动选择公式或提示候选
    - 执行平台查询
    - 成功查询节点写入 graph.nodes，保留当时 intent_info
    """
    user_input = str(user_input or "").strip()
    logger.info(f"🔹 handle_single_query user_input={user_input}")
    intent_info = graph.ensure_intent_info() or {}
    intent_info.setdefault("user_input_list", []).append(user_input)
    intent_info.setdefault("intent_list", []).append("single_query")

    indicators = intent_info.setdefault("indicators", [])
    
    # ---------- 查找当前 active indicator ----------
    current_indicator = None
    for ind in indicators:
        if ind.get("status") == "active":
            current_indicator = ind
            break

    # ---------- 若无 active indicator，则尝试从最近节点恢复 ----------
    if not current_indicator:
        last_node = graph.get_last_completed_node()
        if last_node:
            entry = last_node.get("indicator_entry", {})
            if entry and entry.get("indicator"):
                logger.info("🧩 从最近节点恢复 indicator: %s", entry.get("indicator"))
                current_indicator = {
                    "status": "active",
                    "indicator": entry.get("indicator"),
                    "formula": entry.get("formula"),
                    "timeString": entry.get("timeString"),
                    "timeType": entry.get("timeType"),
                    "slot_status": {
                        "formula": "missing",
                        "time": "missing"
                    },
                    "value": None,
                    "note": None,
                    "formula_candidates": entry.get("formula_candidates"),
                }
                indicators.append(current_indicator)
            else:
                logger.info("⚠️ 最近节点无有效 indicator_entry，改用默认新建。")
                current_indicator = default_indicators()
                indicators.append(current_indicator)
        else:
            logger.info("⚠️ 无历史节点可用，创建默认 indicator。")
            current_indicator = default_indicators()
            indicators.append(current_indicator)

    # ---------- LLM 补全 ----------
    try:
        parsed = await parse_user_input(user_input)
        for key in ("indicator", "formula", "timeString", "timeType"):
            if parsed.get(key):
                current_indicator[key] = parsed[key]
    except Exception as e:
        logger.warning("parse_user_input 解析候选失败: %s -> %s", user_input, e)

    current_indicator["slot_status"]["time"] = "filled" if current_indicator.get("timeString") and current_indicator.get("timeType") else "missing"

    # ---------- 缺指标 ----------
    if not current_indicator.get("indicator"):
        reply = "请告诉我您要查询的指标名称。"
        graph.add_history(user_input, reply)
        graph.set_intent_info(intent_info)
        set_graph(user_id, graph)
        return reply, graph.to_state()

    # ---------- 查询公式 ----------
    if not current_indicator["slot_status"]["formula"] == "filled":
        formula_resp = await asyncio.to_thread(formula_api.formula_query_dict, current_indicator["indicator"])
        exact_matches = formula_resp.get("exact_matches") or []
        candidates = formula_resp.get("candidates") or []

        if exact_matches:
            chosen = exact_matches[0]
            current_indicator["formula"] = chosen["FORMULAID"]
            current_indicator["indicator"] = chosen["FORMULANAME"]
            current_indicator["slot_status"]["formula"] = "filled"
            current_indicator["note"] = "精确匹配公式"
        elif candidates and candidates[0].get("score", 0) > 100:
            top = candidates[0]
            current_indicator["formula"] = top["FORMULAID"]
            current_indicator["indicator"] = top["FORMULANAME"]
            current_indicator["slot_status"]["formula"] = "filled"
            current_indicator["note"] = f"高分候选公式 (score {top.get('score')})"
        elif candidates:
            current_indicator["formula_candidates"] = candidates[:TOP_N]
            current_indicator["slot_status"]["formula"] = "missing"
            lines = [f"没有完全匹配的【{current_indicator["indicator"]}】指标，请从以下候选选择编号(或者重新输入尽量精确的指标名称)："]
            for i, c in enumerate(candidates[:TOP_N], 1):
                lines.append(f"{i}) {c['FORMULANAME']} (score {c.get('score',0):.2f})")
            reply = "\n".join(lines) 
            graph.add_history(user_input, reply)
            graph.set_intent_info(intent_info)
            set_graph(user_id, graph)
            return reply, graph.to_state()
        else:
            current_indicator["slot_status"]["formula"] = "missing"
            current_indicator["note"] = "未找到匹配公式"
            reply = f"未找到匹配公式，请重新输入指标名称。" 
            graph.add_history(user_input, reply)
            graph.set_intent_info(intent_info)
            set_graph(user_id, graph)
            return reply, graph.to_state()

    # ---------- 执行查询 ----------
    if current_indicator["slot_status"]["formula"] == "filled" and current_indicator["slot_status"]["time"] == "filled":
        val, reply = await _execute_query(current_indicator)
        current_indicator["value"] = val
        current_indicator["note"] = reply
        current_indicator["status"] = "completed"
        # 必须在addNode前
        graph.set_intent_info(intent_info)
        # 写入 graph.node
        node_id = graph.add_node(current_indicator)

        # 连续判断需要找到当前intent中active的indicator，作为当前current_info传入即可
        main_intent = graph.get_main_intent() or None
        if "compare" == main_intent:
            logger.info("🔄 single query 完成并检测到 compare 上下文，继续执行 handle_compare...")
            current_intents = [
                ind.get("indicator")
                for ind in intent_info.get("indicators")
                if ind.get("status") == "active" and ind.get("indicator")
            ]
            print(f"current_intents:{current_intents}")
            return await handle_compare(user_id, f"{user_input} -> system:完成 single query 并检测到 compare 上下文，继续执行 handle_single_query...", graph, current_intent={"candidates": current_intents})
        
        if "list_query" == main_intent:
            logger.info("🔄 single query 完成并检测到 list_query 上下文，继续执行 handle_list_query...")
            return await handle_list_query(user_id, f"{user_input} -> system:完成 single query 并检测到 list_query 上下文，继续执行 handle_list_query...", graph)
        
        # 成功查询重置意图
        graph.set_intent_info({})
        graph.add_history(user_input, reply)
        set_graph(user_id, graph)
        return reply, graph.to_state()
    reply = f"好的，要查【{current_indicator['indicator']}】，请告诉我时间。"
    graph.add_history(user_input, reply)
    current_indicator["note"] = reply
    graph.set_intent_info(intent_info)
    set_graph(user_id, graph)
    return reply, graph.to_state()

# ------------------------- 辅助函数 -------------------------
async def _execute_query(indicator_entry):
    formula = indicator_entry.get("formula")
    time_str = indicator_entry.get("timeString")
    time_type = indicator_entry.get("timeType")
    indicator = indicator_entry.get("indicator")

    try:
        if inspect.iscoroutinefunction(platform_api.query_platform):
            result = await platform_api.query_platform(formula, time_str, time_type)
        else:
            result = await asyncio.to_thread(platform_api.query_platform, formula, time_str, time_type)
        logger.info(f"⚙️ 平台查询成功: {result}")
    except Exception as e:
        logger.exception("❌ platform_api 查询失败: %s", e)
        return None, f"查询失败: {e}"

    # 提取数值 和 回复
    val = None
    reply = None
    if isinstance(result, dict):
        val = result.get("value") or next(iter(result.values()), None)
        unit = result.get("unit", "")
        reply = f"✅ {indicator} 在 {time_str} ({time_type}) 的值是 {val} {unit}"
    elif isinstance(result, list) and result:
        val = result[0].get("itemValue") or result[0].get("value") or result[0].get("v")
        lines = [f"{r.get('clock') or r.get('time') or r.get("timestamp")}: {r.get('itemValue') or r.get('value') or r.get("v")}" for r in result]
        reply = f"✅ {indicator} 在 {time_str} ({time_type}) 的查询结果:\n" + "\n".join(lines)
    else:
        reply = f"✅ {indicator} 在 {time_str} ({time_type}) 的查询结果: {result}"
    return val, reply
    
# ------------------------- 对比、偏差 -------------------------
async def handle_compare(user_id: str, user_input: str, graph: ContextGraph, current_intent: dict | None = None):
    """
    Compare 统一处理逻辑（一步/两步/三步模式）：

    一步：用户当前输入解析出 >=2 条 candidates
            → 全部解析补全 slot → 查询 → 得到两条 entry.note → LLM 比较

    两步：用户当前输入解析出 ==1 条 candidate
            → 从 graph 取最后一条已完成 entry
            → 复制其 indicator 数据
            → 用 candidate 的解析结果替换（可替换指标/时间/计划 vs 实绩）
            → 查询新 entry → 与旧 entry 比较

    三步：用户当前输入解析出 0 条 candidate
            → 直接从 graph.nodes 回溯最近两个已成功节点
            → 不再查平台数据 → 直接 LLM 比较

    所有步骤:
      - 若过程中缺公式 or 时间 → intent_info.pending 标记 → 返回提示用户补槽
      - 结果写回 graph.nodes 与 intent_info.compare_history
    """
    user_input = str(user_input or "").strip()
    logger.info("🔀 进入 handle_compare，user=%s, input=%s", user_id, user_input)

    # Ensure we have a working intent_info (use snapshot recovery)
    intent_info = graph.ensure_intent_info() or {}
    intent_info.setdefault("user_input_list", []).append(user_input)
    intent_info.setdefault("intent_list", []).append("compare")
    graph.set_main_intent("compare")
    indicators = intent_info.setdefault("indicators", [])

    # Acquire candidates from current_intent if present
    candidates = []
    if current_intent and isinstance(current_intent, dict):
        candidates = current_intent.get("candidates") or []

    # If intent_info already has indicators (e.g. from previous steps), we operate on that list.
    # We'll append/modify indicators list as needed per scenario.

    # ---------- One-step (>=2 candidates supplied) ----------
    if len(candidates) >= 2:
        logger.info("🔎 compare: 使用 candidates 解析: %s", candidates)
        parsed_indicators = []
        for c in candidates:
            # parse each candidate into a default indicator entry
            n = default_indicators()
            try:
                parsed = await parse_user_input(c)
                for key in ("indicator", "formula", "timeString", "timeType"):
                    if parsed.get(key):
                        n[key] = parsed[key]
            except Exception as e:
                logger.warning("parse_user_input 单 candidate 解析失败: %s -> %s", candidates[0], e)
            n["slot_status"]["time"] = "filled" if n.get("timeString") and n.get("timeType") else "missing"
            parsed_indicators.append(n)

        # If more than 2 provided, refuse (per your rule)
        if len(parsed_indicators) > 2:
            reply = "当前只支持两项对比，请只提供两个要对比的目标，或改问趋势/分析。"
            graph.add_history(user_input, reply)
            graph.set_intent_info(intent_info)
            set_graph(user_id, graph)
            logger.warning("⚠️ compare: 用户提供超过两项 candidates")
            return reply, graph.to_state()
        
        # replace intent indicators
        intent_info["indicators"] = parsed_indicators
        indicators = intent_info["indicators"]
        # ensure both items have nodes/values
        node_pairs = []
        for item in indicators:
            # ---------- 缺指标 ----------
            if not item.get("indicator"):
                reply = "请告诉我您要对比的指标名称。"
                graph.add_history(user_input, reply)
                graph.set_intent_info(intent_info)
                set_graph(user_id, graph)
                return reply, graph.to_state()

            # ---------- 查询公式 ----------
            if not item["slot_status"]["formula"] == "filled":
                formula_resp = await asyncio.to_thread(formula_api.formula_query_dict, item["indicator"])
                exact_matches = formula_resp.get("exact_matches") or []
                candidates = formula_resp.get("candidates") or []
                if exact_matches:
                    chosen = exact_matches[0]
                    item["formula"] = chosen["FORMULAID"]
                    item["indicator"] = chosen["FORMULANAME"]
                    item["slot_status"]["formula"] = "filled"
                    item["note"] = "精确匹配公式"
                elif candidates and candidates[0].get("score", 0) > 100:
                    top = candidates[0]
                    item["formula"] = top["FORMULAID"]
                    item["indicator"] = top["FORMULANAME"]
                    item["slot_status"]["formula"] = "filled"
                    item["note"] = f"高分候选公式 (score {top.get('score')})"
                elif candidates:
                    item["formula_candidates"] = candidates[:TOP_N]
                    item["slot_status"]["formula"] = "missing"
                    lines = [f"没有完全匹配的【{item["indicator"]}】指标，请从以下候选选择编号(或者重新输入尽量精确的指标名称："]
                    for i, c in enumerate(candidates[:TOP_N], 1):
                        lines.append(f"{i}) {c['FORMULANAME']} (score {c.get('score',0):.2f})")
                    reply = "\n".join(lines) 
                    graph.add_history(user_input, reply)
                    graph.set_intent_info(intent_info)
                    set_graph(user_id, graph)
                    return reply, graph.to_state()
                else:
                    item["slot_status"]["formula"] = "missing"
                    item["note"] = "未找到匹配公式"
                    reply = f"未找到匹配公式，请重新输入指标名称。" 
                    graph.add_history(user_input, reply)
                    graph.set_intent_info(intent_info)
                    set_graph(user_id, graph)
                    return reply, graph.to_state()
            #  check time 
            if  not item["slot_status"]["time"] == "filled":
                reply = f"好的，要查【{item['indicator']}】，请告诉我时间。"
                graph.add_history(user_input, reply)
                item["note"] = reply
                graph.set_intent_info(intent_info)
                set_graph(user_id, graph)
                return reply, graph.to_state()
                
            # Try find existing node identical
            nid = graph.find_node(item.get("indicator"), item.get("timeString"))
            if nid:
                node = graph.get_node(nid)
                ie = node.get("indicator_entry")
                item["value"] = ie.get("value")
                item["note"] = ie.get("note")
                item["status"] = "completed"
                graph.set_intent_info(intent_info)
                node_pairs.append((nid, ie))
                continue
            # else query platform
            if item["slot_status"]["formula"] == "filled" and item["slot_status"]["time"] == "filled":
                val, reply = await _execute_query(item)
                item["value"] = val
                item["note"] = reply
                item["status"] = "completed"
                # 必须在addNode前
                graph.set_intent_info(intent_info)
                # 写入 graph.node
                node_id = graph.add_node(item)
                other_node = graph.get_node(node_id)
                node_pairs.append((node_id, other_node.get("indicator_entry")))

        # now have two node entries
        left = node_pairs[0][1]
        right = node_pairs[1][1]

        # call LLM with two notes
        analysis = await call_compare_llm(left, right)

        # write relation and history
        sid = node_pairs[0][0]
        tid = node_pairs[1][0]
        graph.add_relation("compare", source_id=sid, target_id=tid, meta={"via": "pipeline.compare", "user_input": intent_info.get("user_input_list"), "result": analysis})
        # 成功查询重置意图
        graph.set_intent_info({})
        graph.clear_main_intent()
        graph.add_history(user_input, analysis)
        set_graph(user_id, graph)
        logger.info("✅ compare(one-step) 完成")
        return analysis, graph.to_state()

    # ---------- Two-step (1 candidate): take last completed indicator as base, then parse candidate to replace fields ----------
    if len(candidates) == 1:
        logger.info("🔎 compare: single candidate 情形 -> two-step flow")
        # find last completed indicator in intent_info or graph
        base_indicator = None
        # prefer from intent_info indicators
        for ind in reversed(indicators):
            if ind.get("status") == "completed":
                base_indicator = ind
                break
        # fallback to graph nodes
        if not base_indicator and graph.nodes:
            base_indicator = graph.nodes[-1]["indicator_entry"]

        if not base_indicator:
            reply = "⚠️ 无可用的参考指标，请先进行至少一次查询以便进行对比。"
            graph.add_history(user_input, reply)
            graph.set_intent_info(intent_info)
            set_graph(user_id, graph)
            logger.warning("⚠️ compare(two-step) 无 base_indicator")
            return reply, graph.to_state()

        # parse the single candidate (it was placed in 'candidates' earlier; here we assume exactly 1)
        current_indicator = None
        for ind in reversed(indicators):
            if ind.get("status") == "active":
                current_indicator = ind
                break
        if not current_indicator:
            current_indicator = {
                "status": "active",
                "indicator": base_indicator.get("indicator"),
                "formula": base_indicator.get("formula"),
                "timeString": base_indicator.get("timeString"),
                "timeType": base_indicator.get("timeType"),
                "slot_status": {
                    "formula": "missing",
                    "time": "missing"
                },
                "value": None,
                "note": None,
                "formula_candidates": base_indicator.get("formula_candidates"),
            }
            indicators.append(current_indicator)
        # if candidate is a time only or indicator only, parse and overwrite corresponding fields
        try:
            parsed = await parse_user_input(candidates[0])
            for key in ("indicator", "formula", "timeString", "timeType"):
                if parsed.get(key):
                    current_indicator[key] = parsed[key]
        except Exception as e:
            logger.warning("parse_user_input 单 candidate 解析失败: %s -> %s", candidates[0], e)

        # 计划特例
        def convert_to_plan_name(last_indicator: str, new_partial_indicator: str) -> str:
            if new_partial_indicator in ["计划", "计划值", "计划报出值"]:
                # 常见“实绩/计划”关键词【你可以扩展】
                mapping = {
                    "实绩": "计划",
                    "实绩值": "计划值",
                    "实绩报出值": "计划报出值",
                }
                for k, v in mapping.items():
                    if k in last_indicator:
                        return last_indicator.replace(k, v)   
            return new_partial_indicator

        current_indicator["indicator"] = convert_to_plan_name(base_indicator.get("indicator"), current_indicator["indicator"])

        current_indicator["slot_status"]["time"] = "filled" if current_indicator.get("timeString") and current_indicator.get("timeType") else "missing"
            
        # ---------- 缺指标 ----------
        if not current_indicator.get("indicator"):
            reply = "请告诉我您要对比的指标名称。"
            graph.add_history(user_input, reply)
            graph.set_intent_info(intent_info)
            set_graph(user_id, graph)
            return reply, graph.to_state()

        # ---------- 查询公式 ----------
        if not current_indicator["slot_status"]["formula"] == "filled":
            print(current_indicator["indicator"])
            formula_resp = await asyncio.to_thread(formula_api.formula_query_dict, current_indicator["indicator"])
            print(formula_resp)
            exact_matches = formula_resp.get("exact_matches") or []
            candidates = formula_resp.get("candidates") or []

            if exact_matches:
                chosen = exact_matches[0]
                current_indicator["formula"] = chosen["FORMULAID"]
                current_indicator["indicator"] = chosen["FORMULANAME"]
                current_indicator["slot_status"]["formula"] = "filled"
                current_indicator["note"] = "精确匹配公式"
            elif candidates and candidates[0].get("score", 0) > 100:
                top = candidates[0]
                current_indicator["formula"] = top["FORMULAID"]
                current_indicator["indicator"] = top["FORMULANAME"]
                current_indicator["slot_status"]["formula"] = "filled"
                current_indicator["note"] = f"高分候选公式 (score {top.get('score')})"
            elif candidates:
                current_indicator["formula_candidates"] = candidates[:TOP_N]
                current_indicator["slot_status"]["formula"] = "missing"
                lines = [f"没有完全匹配的【{current_indicator["indicator"]}】指标，请从以下候选选择编号(或者重新输入尽量精确的指标名称："]
                for i, c in enumerate(candidates[:TOP_N], 1):
                    lines.append(f"{i}) {c['FORMULANAME']} (score {c.get('score',0):.2f})")
                reply = "\n".join(lines) 
                graph.add_history(user_input, reply)
                graph.set_intent_info(intent_info)
                set_graph(user_id, graph)
                return reply, graph.to_state()
            else:
                current_indicator["slot_status"]["formula"] = "missing"
                current_indicator["note"] = "未找到匹配公式"
                reply = f"未找到匹配公式，请重新输入指标名称。" 
                graph.add_history(user_input, reply)
                graph.set_intent_info(intent_info)
                set_graph(user_id, graph)
                return reply, graph.to_state()

        # Now ensure both base (possibly modified copy) and the other recent node have values
        # Prepare the other existing node (the one to compare against): prefer previous completed node different from base copy
        other_node = None
        for node in reversed(graph.nodes):
            ie = node.get("indicator_entry", {})
            # only indicator and timeString is ok
            if ie.get("indicator") == current_indicator.get("indicator") and ie.get("timeString") == current_indicator.get("timeString"):
                other_node = node
                break
            
        if not other_node:
            # ---------- 执行查询 ----------
            if current_indicator["slot_status"]["formula"] == "filled" and current_indicator["slot_status"]["time"] == "filled":
                val, reply = await _execute_query(current_indicator)
                current_indicator["value"] = val
                current_indicator["note"] = reply
                current_indicator["status"] = "completed"
                # 必须在addNode前
                graph.set_intent_info(intent_info)
                # 写入 graph.node
                node_id = graph.add_node(current_indicator)
                other_node = graph.get_node(node_id)

        # Now produce two notes and call LLM

        analysis = await call_compare_llm(base_indicator, current_indicator)
        
        sid = graph.find_node(base_indicator.get("indicator"), base_indicator.get("timeString"))
        # write relation and history
        graph.add_relation("compare", source_id=sid, target_id=other_node.get("id"), meta={"via": "pipeline.compare", "user_input": intent_info.get("user_input_list"), "result": analysis})
        # 成功查询重置意图
        graph.set_intent_info({})
        graph.clear_main_intent()
        graph.add_history(user_input, analysis)
        set_graph(user_id, graph)
        logger.info("✅ compare(two-step) 完成")
        return analysis, graph.to_state()
    
    # ---------- Three-step (no candidates): use last two nodes from graph ----------
    logger.info("🔎 compare: 未提供 candidates，尝试从 graph 回溯最近两个节点")
    recent = graph.nodes[-2:] if len(graph.nodes) >= 2 else []
    if recent and len(recent) >= 2:
        node1 = recent[-2]
        node2 = recent[-1]
        ie1 = node1.get("indicator_entry", {})
        ie2 = node2.get("indicator_entry", {})

        analysis = await call_compare_llm(ie1, ie2)

        # write relation
        sid = node1.get("id")
        tid = node2.get("id")
        graph.add_relation("compare", source_id=sid, target_id=tid, meta={"via": "pipeline.compare", "user_input": intent_info.get("user_input_list"), "result": analysis})
        # 成功查询重置意图
        graph.set_intent_info({})
        graph.clear_main_intent()
        graph.add_history(user_input, analysis)
        set_graph(user_id, graph)
        logger.info("✅ compare(three-step) 完成")
        return analysis, graph.to_state()

# ------------------------- 趋势分析 -------------------------
async def handle_analysis(user_id: str, message: str, graph: ContextGraph):
    logger.info("📈 进入 analysis 模式（趋势扩展查询）")
    return "趋势查询功能正在开发中。", graph.to_state()

# ------------------------- Slot 填充 基本属于时间-------------------------
async def handle_slot_fill(user_id: str, user_input: str, graph: ContextGraph, current_intent: dict | None = None):
    logger.info("🔁 进入 slot_fill 模式。")
    """
    批量时间槽位补全逻辑：
    1. 找出所有 active 的指标
    2. 解析用户输入（时间）
    3. 如果没有或多条时间 → 提示重新输入
    4. 为每个 active 指标补全时间并执行查询
    5. 汇总结果，写入 graph
    """
    user_input = str(user_input or "").strip()
    logger.info(f"🔹 handle_slot_fill user_input={user_input}")
    # 因为查询成功会清空当前intent_info，所以在成功查询一次后，后续问“那昨天的呢？”，会从最近的node中拉取snapshot
    intent_info = graph.ensure_intent_info() or {}
    intent_info.setdefault("user_input_list", []).append(user_input)
    intent_info.setdefault("intent_list", []).append("slot_fill") 
    indicators = intent_info.setdefault("indicators", [])

    # ---------- 找到所有 active 指标 ----------
    active_inds = [ind for ind in indicators if ind.get("status") == "active"]
    if not active_inds:
        active_inds = indicators
    
    # ---------- 解析时间 ----------
    try:
        print(current_intent)
        candidates = current_intent.get("candidates", [])
        if not candidates or len(candidates) != 1:
            reply = "抱歉，我不确定您指的时间，请重新输入（例如：去年、上月、2024年10月）。"
            graph.add_history(user_input, reply)
            graph.set_intent_info(intent_info)
            set_graph(user_id, graph)
            return reply, graph.to_state()
        parsed = await parse_user_input(candidates[0])
        logger.info(f"✅ 解析到时间候选: {parsed}")
    except Exception as e:
        reply = f"解析时间出错: {e}"
        graph.add_history(user_input, reply)
        graph.set_intent_info(intent_info)
        set_graph(user_id, graph)
        return reply, graph.to_state()

    # ---------- 批量更新 ----------
    results = []
    for ind in active_inds:
        for key in ("timeString", "timeType"):
            if parsed.get(key):
                ind[key] = parsed[key]

        ind["slot_status"]["time"] = "filled" if ind.get("timeString") and ind.get("timeType") else "missing"
                
        # ---------- 查询公式 ----------
        if not ind["slot_status"]["formula"] == "filled":
            formula_resp = await asyncio.to_thread(formula_api.formula_query_dict, ind["indicator"])
            exact_matches = formula_resp.get("exact_matches") or []
            candidates = formula_resp.get("candidates") or []

            if exact_matches:
                chosen = exact_matches[0]
                ind["formula"] = chosen["FORMULAID"]
                ind["indicator"] = chosen["FORMULANAME"]
                ind["slot_status"]["formula"] = "filled"
                ind["note"] = "精确匹配公式"
            elif candidates and candidates[0].get("score", 0) > 100:
                top = candidates[0]
                ind["formula"] = top["FORMULAID"]
                ind["indicator"] = top["FORMULANAME"]
                ind["slot_status"]["formula"] = "filled"
                ind["note"] = f"高分候选公式 (score {top.get('score')})"
            elif candidates:
                ind["formula_candidates"] = candidates[:TOP_N]
                ind["slot_status"]["formula"] = "missing"
                lines = [f"没有完全匹配的【{ind["indicator"]}】指标，请从以下候选选择编号(或者重新输入尽量精确的指标名称："]
                for i, c in enumerate(candidates[:TOP_N], 1):
                    lines.append(f"{i}) {c['FORMULANAME']} (score {c.get('score', 0):.2f})")
                reply = "\n".join(lines)
                graph.add_history(user_input, reply)
                graph.set_intent_info(intent_info)
                set_graph(user_id, graph)
                return reply, graph.to_state()
            else:
                ind["slot_status"]["formula"] = "missing"
                ind["note"] = "未找到匹配公式"
                reply = f"未找到匹配公式，请重新输入指标名称。"
                graph.add_history(user_input, reply)
                graph.set_intent_info(intent_info)
                set_graph(user_id, graph)
                return reply, graph.to_state()

        # ---------- 执行查询 ----------
        if ind["slot_status"]["formula"] == "filled":
            val, reply = await _execute_query(ind)
            ind["value"] = val
            ind["note"] = reply
            ind["status"] = "completed"
            graph.add_node(ind)
            results.append(reply)
    
    main_intent = graph.get_main_intent() or None
    if "compare" == main_intent:
        logger.info("🔄 solt_fill 完成并检测到 compare 上下文，继续执行 handle_compare...")
        return await handle_compare(user_id, f"{user_input} -> system:完成 solt_fill 并检测到 compare 上下文，继续执行 handle_compare...", graph)
    
    if "list_query" == main_intent:
            logger.info("🔄 solt_fill 完成并检测到 list_query 上下文，继续执行 handle_list_query...")
            return await handle_list_query(user_id, f"{user_input} -> system:完成 solt_fill 并检测到 list_query 上下文，继续执行 handle_list_query...", graph)
    
    # ---------- 更新 graph ----------
    graph.set_intent_info(intent_info)
    set_graph(user_id, graph)
    # 成功查询重置意图
    graph.set_intent_info({})
    final_reply = "\n".join(results) if results else "没有成功的查询结果。"
    graph.add_history(user_input, final_reply)
    logger.info(f"📊 slot_fill 汇总结果: {final_reply}")
    return final_reply, graph.to_state()

# ------------------------- clarify 选择备选项 -------------------------
async def handle_clarify(user_id: str, user_input: str, graph: ContextGraph):
    logger.info("✅ 进入 clarify 模式。")
    """
    基础能源查询：
    - 选择备选
    - 调用 formula_api 查询公式
    - 自动选择公式或提示候选
    - 执行平台查询
    - 成功查询节点写入 graph.nodes，保留当时 intent_info
    """
    user_input = str(user_input or "").strip()
    logger.info(f"🔹 handle_clarify user_input={user_input}")
    # 实际操作
    intent_info = graph.ensure_intent_info() or {}
    intent_info.setdefault("user_input_list", []).append(user_input)
    intent_info.setdefault("intent_list", []).append("clarify")
    
    indicators = intent_info.setdefault("indicators", [])

    # ---------- 查找当前 active indicator ----------
    current_indicator = None
    for ind in indicators:
        if ind.get("status") == "active" and ind.get("formula_candidates"):
            current_indicator = ind
            break

    # 如果没有 active 的，就新建一个
    if not current_indicator:
        current_indicator = default_indicators()
        indicators.append(current_indicator)

    # ---------- 数字输入选择公式 ----------
    if user_input.isdigit():
        idx = int(user_input) - 1
        candidates = current_indicator["formula_candidates"]
        if not candidates:
            logger.warning("⚠️ 上下文中并不包含任何备选，意图解析出错: %s", user_input)
            reply = f"上下文中并不包含任何备选，意图解析出错: {user_input}。"
            graph.add_history(user_input, reply)
            graph.set_intent_info(intent_info)
            set_graph(user_id, graph)
            return reply, graph.to_state()
        logger.info(f"🔢 检测到候选选择 index={idx}, count={len(candidates)}")
        if 0 <= idx < len(candidates):
            chosen = candidates[idx]
            current_indicator["formula"] = chosen["FORMULAID"]
            current_indicator["indicator"] = chosen["FORMULANAME"]
            current_indicator["slot_status"]["formula"] = "filled"
            logger.info(f"✅ 用户选择公式: {current_indicator['indicator']} (FORMULAID={current_indicator['formula']})")
        else:
            logger.warning("⚠️ 用户输入的候选编号超范围: %s", user_input)
            reply = f"请输入编号 1~{len(candidates)} 选择公式。"
            graph.add_history(user_input, reply)
            graph.set_intent_info(intent_info)
            set_graph(user_id, graph)
            return reply, graph.to_state()
    # ---------- 执行查询 ----------
    if current_indicator["slot_status"]["formula"] == "filled" and current_indicator["slot_status"]["time"] == "filled":
        val, reply = await _execute_query(current_indicator)
        current_indicator["value"] = val
        current_indicator["note"] = reply
        current_indicator["status"] = "completed"
        # 必须在addNode前
        graph.set_intent_info(intent_info)
        # 写入 graph.node
        node_id = graph.add_node(current_indicator)

        # 连续判断需要找到当前intent中active的indicator，作为当前current_info传入即可
        main_intent = graph.get_main_intent() or None
        if "compare" == main_intent:
            logger.info("🔄 clarify 完成并检测到 compare 上下文，继续执行 handle_compare...")
            current_intents = [
                ind.get("indicator")
                for ind in intent_info.get("indicators")
                if ind.get("status") == "active" and ind.get("indicator")
            ]
            print(f"current_intents:{current_intents}")
            return await handle_compare(user_id, f"{user_input} -> system:完成 clarify 并检测到 compare 上下文，继续执行 handle_compare...", graph, current_intent={"candidates": current_intents})

        if "list_query" == main_intent:
            logger.info("🔄 clarify 完成并检测到 list_query 上下文，继续执行 handle_list_query...")
            return await handle_list_query(user_id, f"{user_input} -> system:完成 clarify 并检测到 list_query 上下文，继续执行 handle_list_query...", graph)
        
        # 成功查询重置意图
        graph.set_intent_info({})  
        graph.add_history(user_input, reply)
        set_graph(user_id, graph)
        return reply, graph.to_state()
    reply = f"好的，要查【{current_indicator['indicator']}】，请告诉我时间。"
    graph.add_history(user_input, reply)
    current_indicator["note"] = reply
    graph.set_intent_info(intent_info)
    set_graph(user_id, graph)
    return reply, graph.to_state()

# ------------------------- 批量查询 -------------------------
async def handle_list_query(user_id: str, user_input: str, graph: ContextGraph, current_intent: dict | None = None):
    user_input = str(user_input or "").strip()
    logger.info("📋 进入 list_query，user=%s, input=%s", user_id, user_input)

    # Ensure we have a working intent_info (DONT use snapshot recovery)
    intent_info = graph.get_intent_info() or {}
    intent_info.setdefault("user_input_list", []).append(user_input)
    intent_info.setdefault("intent_list", []).append("list_query")
    graph.set_main_intent("list_query")
    indicators = intent_info.setdefault("indicators", [])

    # Acquire candidates from current_intent if present
    candidates = []
    if current_intent and isinstance(current_intent, dict):
        candidates = current_intent.get("candidates") or []

    parsed_indicators = []
    # 情况1：如果没有 candidates（slot_fill 进入）
    if not candidates:
        logger.info("ℹ️ current_intent 无 candidates，因此不修改现有 indicators（slot_fill 情况）。")
        indicators = intent_info.setdefault("indicators", [])
    else:
        # 情况2：首次 list_query 或二次进入 list_query
        logger.info("🆕 开始解析 candidates，并合并到 indicators（删除旧 active）")

        # 1) 保留 completed 的，删除 active 的
        old_list = intent_info.setdefault("indicators", [])
        kept = [item for item in old_list if item.get("status") != "active"]

        # 2) 解析新的 candidates 为 active
        for c in candidates:
            n = default_indicators()
            try:
                parsed = await parse_user_input(c)
                for key in ("indicator", "formula", "timeString", "timeType"):
                    if parsed.get(key):
                        n[key] = parsed[key]
            except Exception as e:
                logger.warning("parse_user_input 解析失败: %s → %s", c, e)

            # 时间槽检查
            if n.get("timeString") and n.get("timeType"):
                n["slot_status"]["time"] = "filled"

            n["status"] = "active"
            parsed_indicators.append(n)

        # 3) 合并：completed + 新解析的 active
        indicators = kept + parsed_indicators
        intent_info["indicators"] = indicators
    # batch
    results = []
    sids = []
    for item in indicators:
        # ---------- 缺指标 ----------
        if not item.get("indicator"):
            reply = "请告诉我您要对比的指标名称。"
            graph.add_history(user_input, reply)
            graph.set_intent_info(intent_info)
            set_graph(user_id, graph)
            return reply, graph.to_state()
        # ---------- 查询公式 ----------
        if not item["slot_status"]["formula"] == "filled":
            formula_resp = await asyncio.to_thread(formula_api.formula_query_dict, item["indicator"])
            exact_matches = formula_resp.get("exact_matches") or []
            candidates = formula_resp.get("candidates") or []
            if exact_matches:
                chosen = exact_matches[0]
                item["formula"] = chosen["FORMULAID"]
                item["indicator"] = chosen["FORMULANAME"]
                item["slot_status"]["formula"] = "filled"
                item["note"] = "精确匹配公式"
            elif candidates and candidates[0].get("score", 0) > 100:
                top = candidates[0]
                item["formula"] = top["FORMULAID"]
                item["indicator"] = top["FORMULANAME"]
                item["slot_status"]["formula"] = "filled"
                item["note"] = f"高分候选公式 (score {top.get('score')})"
            elif candidates:
                item["formula_candidates"] = candidates[:TOP_N]
                item["slot_status"]["formula"] = "missing"
                lines = [f"没有完全匹配的【{item["indicator"]}】指标，请从以下候选选择编号(或者重新输入尽量精确的指标名称："]
                for i, c in enumerate(candidates[:TOP_N], 1):
                    lines.append(f"{i}) {c['FORMULANAME']} (score {c.get('score',0):.2f})")
                reply = "\n".join(lines) 
                graph.add_history(user_input, reply)
                graph.set_intent_info(intent_info)
                set_graph(user_id, graph)
                return reply, graph.to_state()
            else:
                item["slot_status"]["formula"] = "missing"
                item["note"] = "未找到匹配公式"
                reply = f"未找到匹配公式，请重新输入指标名称。" 
                graph.add_history(user_input, reply)
                graph.set_intent_info(intent_info)
                set_graph(user_id, graph)
                return reply, graph.to_state()
        #  check time 
        if  not item["slot_status"]["time"] == "filled":
            reply = f"好的，要查【{item['indicator']}】，请告诉我时间。"
            graph.add_history(user_input, reply)
            item["note"] = reply
            graph.set_intent_info(intent_info)
            set_graph(user_id, graph)
            return reply, graph.to_state()

        # Try find existing node identical
        nid = graph.find_node(item.get("indicator"), item.get("timeString"))
        if nid:
            sids.append(nid)
            results.append(item["note"])
            node = graph.get_node(nid)
            ie = node.get("indicator_entry")
            item["value"] = ie.get("value")
            item["note"] = ie.get("note")
            item["status"] = "completed"
            graph.set_intent_info(intent_info)
            continue
        # else query platform
        if item["slot_status"]["formula"] == "filled" and item["slot_status"]["time"] == "filled":
            val, reply = await _execute_query(item)
            item["value"] = val
            item["note"] = reply
            item["status"] = "completed"
            # 必须在addNode前
            graph.set_intent_info(intent_info)
            # 写入 graph.node
            node_id = graph.add_node(item)
            sids.append(node_id)
            results.append(item["note"])
    # write relation and history
    graph.add_relation("group", meta={"via": "pipeline.list.query", "user_input": intent_info.get("user_input_list"), "ids": sids, "result": "\n".join(results)})
    # 成功查询重置意图
    graph.set_intent_info({})
    graph.clear_main_intent()
    graph.add_history(user_input, "\n".join(results))
    set_graph(user_id, graph)
    logger.info("✅ list query 完成")
    return "\n".join(results), graph.to_state()

# ------------------------- 测试 main -------------------------
async def main():
    from tools import formula_api
    # 只初始化一次，不会重复加载
    formula_api.initialize()

    user_id = "test_user"
    graph = get_graph(user_id) or ContextGraph()
    set_graph(user_id, graph)

    from core.llm_energy_intent_parser import EnergyIntentParser
    parser = EnergyIntentParser()
    user_input = "本月1、2号高炉工序能耗是多少"
    current_info = await parser.parse_intent(user_input)
    print(current_info)

    # 测试批量查询
    reply, graph_state = await handle_list_query(user_id, user_input, graph, current_info)
    print("Single Query Reply 1:", reply)
    print(json.dumps(graph_state, indent=2, ensure_ascii=False))

    # user_input = "2022年1高炉电外供量实绩报出值、2高炉焦炭使用量实绩报出值分别是多少"
    # current_info = await parser.parse_intent(user_input)
    # # 测试重新精确输入
    # reply, graph_state = await handle_list_query(user_id, user_input, graph, current_info)
    # print("Single Query Reply 1:", reply)
    # print(json.dumps(graph_state, indent=2, ensure_ascii=False))

    # # 测试选择备选
    # reply, graph_state = await handle_clarify(user_id, 2, graph)
    # print("Single Query Reply 3:", reply)
    # print(json.dumps(graph_state, indent=2, ensure_ascii=False))

    # # 测试选择备选
    # reply, graph_state = await handle_clarify(user_id, 3, graph)
    # print("Single Query Reply 4:", reply)
    # print(json.dumps(graph_state, indent=2, ensure_ascii=False))

    # 测试补齐时间
    # reply, graph_state = await handle_slot_fill(user_id, "2022年", graph, {"candidates": ["2022年"]})
    # print("Single Query Reply 2:", reply)
    # print(json.dumps(graph_state, indent=2, ensure_ascii=False))
    
    # 再查询一个指标（可测试对比）
    # msg2 = "昨天高炉工序能耗是多少"
    # reply2, graph_state2 = await handle_single_query(user_id, msg2, graph)
    # print("Single Query Reply 2:", reply2)
    # print(json.dumps(graph_state2, indent=2, ensure_ascii=False))

    # # 对比
    # cmp_reply, _ = await handle_compare(user_id, "对比最新两条数据", graph)
    # print("Compare Reply:", cmp_reply)


if __name__ == "__main__":
    asyncio.run(main())
```

* 趋势分析还未实现。
* 批量查询继承上一轮时间需要实现。
* reply还欠缺用户体验，openwebui前端追问功能还要做适配。
* 代码还未提取和重构。
* 最复杂的是对比逻辑，分为一步、二步、三步问数对比。

### 六、上下文图谱

```python
# core/context_graph.py
from dataclasses import dataclass, field
from typing import List, Dict, Optional, Any
import logging
import copy

logger = logging.getLogger("context_graph")
if not logger.handlers:
    logging.basicConfig(level=logging.INFO, format="%(asctime)s | %(levelname)s | %(name)s | %(message)s")

@dataclass
class ContextGraph:
    """
    上下文语义图谱（轻量实现）：
    - nodes: 每个 node 包含当时查询成功的 indicator 数据与历史信息
    - relations: 关系，如 compare、sequence
    - meta: 临时/扩展信息
    """
    nodes: List[Dict[str, Any]] = field(default_factory=list)
    relations: List[Dict[str, Any]] = field(default_factory=list)
    meta: dict = field(default_factory=dict)
    _next_id: int = field(default=1, init=False, repr=False)

    # ---------------------
    # intent_info 管理（当前操作参考）
    # ---------------------
    def set_intent_info(self, intent_info: dict):
        self.meta["current_intent_info"] = intent_info

    def get_intent_info(self) -> dict:
        return self.meta.get("current_intent_info", {})
    
    def ensure_intent_info(self) -> dict:
        """
        确保 graph.meta.current_intent_info 存在：
        如果为空，则从最近 Node.intent_info_snapshot 中恢复
        """
        intent_info = self.get_intent_info() or {}
        # 如果当前为空，则尝试从最后一个 node 恢复
        if not intent_info:
            nodes = self.nodes
            if nodes:
                last_node = nodes[-1]
                snapshot = last_node.get("intent_info_snapshot")
                if snapshot:
                    intent_info = copy.deepcopy(snapshot)
                    self.set_intent_info(intent_info)
                    print("✅ 已从最近节点恢复 intent_info:", intent_info)
                else:
                    print("⚠️ 最近节点无 intent_info_snapshot")
            else:
                print("⚠️ 无节点可恢复 intent_info")

        return intent_info

    
    # ---------------------
    # history 管理
    # ---------------------
    def add_history(self, user_input: str, reply: str):
        hist = self.meta.setdefault("history", [])
        hist.append({"ask": user_input, "reply": reply})
        logger.info(f"🕘 add_history: {user_input} -> {reply}")

    def get_history(self) -> List[Dict[str, str]]:
        return self.meta.get("history", [])
    
    # ---------------------
    # 总体意图管理
    # ---------------------
    def set_main_intent(self, intent: dict | str):
        self.meta["main_intent"] = intent
        logger.info(f"🎯 set_main_intent: {intent}")

    def get_main_intent(self) -> dict | str | None:
        return self.meta.get("main_intent")

    def clear_main_intent(self):
        if "main_intent" in self.meta:
            del self.meta["main_intent"]
            logger.info("🧹 main_intent cleared.")

    # ---------------------
    # 节点管理
    # ---------------------
    def _alloc_id(self) -> int:
        nid = self._next_id
        self._next_id += 1
        return nid

    def add_node(self, indicator_entry: dict) -> int:
        """
        添加成功查询节点，同时保存当时的 intent_info
        indicator_entry: 包含 id/formula/indicator/time/value/note/slot_status/formula_candidates
        """
        nid = self._alloc_id()
        node = {
            "id": nid,
            "indicator_entry": copy.deepcopy(indicator_entry),  # 保存当时 indicator
            "intent_info_snapshot": copy.deepcopy(self.get_intent_info())
        }
        self.nodes.append(node)
        logger.info("🆕 ContextGraph.add_node -> id=%s, indicator=%s, time=%s",
                    nid,
                    indicator_entry.get("indicator"),
                    indicator_entry.get("timeString"))
        return nid

    def find_node(self, indicator: Optional[str] = None, timeString: Optional[str] = None) -> Optional[int]:
        for n in self.nodes:
            e = n["indicator_entry"]
            if indicator is not None and timeString is not None:
                if e.get("indicator") == indicator and e.get("timeString") == timeString:
                    return n["id"]
            elif indicator is not None and timeString is None:
                if e.get("indicator") == indicator:
                    return n["id"]
        return None

    def get_node(self, node_id: int) -> Optional[Dict[str, Any]]:
        for n in self.nodes:
            if n["id"] == node_id:
                return n
        return None
    
    def get_last_completed_node(self):
        """获取最近一个已完成节点（status=completed）"""
        for node in reversed(self.nodes):
            entry = node.get("indicator_entry", {})
            if entry.get("status") == "completed":
                return node
        return None

    # ---------------------
    # 关系管理
    # ---------------------
    def add_relation(self, rel_type: str, source_id: Optional[int] = None, target_id: Optional[int] = None, meta: Optional[Dict] = None):
        rel = {"type": rel_type, "source": source_id, "target": target_id, "meta": meta or {}}
        if rel not in self.relations:
            self.relations.append(rel)
            logger.info("🔗 ContextGraph.add_relation: %s (source=%s target=%s) meta=%s",
                        rel_type, source_id, target_id, meta or {})
        else:
            logger.debug("🟡 relation already exists: %s", rel)

    def get_relations(self, rel_type: Optional[str] = None) -> List[Dict[str, Any]]:
        if rel_type:
            return [r for r in self.relations if r.get("type") == rel_type]
        return list(self.relations)

    # ---------------------
    # compare 辅助
    # ---------------------
    def resolve_compare_nodes(self) -> Optional[tuple[int, int]]:
        # 1) explicit compare
        for r in reversed(self.relations):
            if r.get("type") == "compare" and r.get("source") and r.get("target"):
                return r.get("source"), r.get("target")
        # 2) fallback to last two nodes
        if len(self.nodes) >= 2:
            return self.nodes[-2]["id"], self.nodes[-1]["id"]
        return None

    # ---------------------
    # 序列化
    # ---------------------
    def to_state(self) -> Dict[str, Any]:
        return {
            "graph": {
                "nodes": self.nodes,
                "relations": self.relations,
                "_next_id": self._next_id
            },
            "meta": self.meta
        }

    @classmethod
    def from_state(cls, state: Dict[str, Any]):
        g = cls()
        graph_data = state.get("graph", {}) if isinstance(state, dict) else {}
        g.nodes = graph_data.get("nodes", []) or []
        g.relations = graph_data.get("relations", []) or []
        g._next_id = graph_data.get("_next_id", max([n["id"] for n in g.nodes], default=0) + 1)
        g.meta = state.get("meta", {}) or {}
        return g


def default_indicators():
    return {
        "status": "active",
        "indicator": None,
        "formula": None,
        "timeString": None,
        "timeType": None,
        "slot_status": {"formula": "missing", "time": "missing"},
        "value": None,
        "note": None,
        "formula_candidates": None
    }
    
# core/pipeline_context.py
"""
统一管理各用户的 ContextGraph 对象。
便于 pipeline 与 pipeline_handlers 共享状态。
"""

from core.context_graph import ContextGraph

# 内存缓存：用户 ID -> ContextGraph
_graph_store: dict[str, ContextGraph] = {}


def get_graph(user_id: str) -> ContextGraph | None:
    """获取用户的 ContextGraph"""
    return _graph_store.get(user_id)


def set_graph(user_id: str, graph: ContextGraph) -> None:
    """设置或更新用户的 ContextGraph"""
    _graph_store[user_id] = graph


def remove_graph(user_id: str) -> None:
    """删除用户对应的 ContextGraph"""
    _graph_store.pop(user_id, None)


def all_graphs() -> dict[str, ContextGraph]:
    """获取所有用户的图谱"""
    return _graph_store
```

* 所有relations操作都是最后完成一步才会执行，这里只作为关系查看，并没有其它用途。
* 上下文管理还没有决定对接redis还是定时清空，还需需要实际使用暴露问题。
* intent_snapshot只是作为方法前置获取上一轮intent的作用，用来补齐指标或者时间的操作。可以实现“那昨天呢？”、“那XXXX指标呢？”这种类型问话。

### 七、openwebui内部信息对接

[如何获取openwebui内部的用户信息，对话信息等](https://docs.openwebui.com/features/plugin/tools/development)

![image-20251120151636968](%E8%83%BD%E6%BA%90%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%B9%B3%E5%8F%B0%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF%E5%8F%8A%E5%AE%9E%E7%8E%B0.assets/image-20251120151636968.png)

在`工作空间`-`工具`新增python 工具：

```
"""
title: EnergyProxy
author: you
version: 0.1.0
description: A strict proxy tool that forwards raw user input to the backend energy API without any modification.
"""

import requests
import urllib.parse


class Tools:
    def __init__(self):
        # 禁用 llm 在 tool 返回内容中的引用标记
        self.citation = False

    def query_energy(self, message: str, __user__=None, __metadata__=None) -> dict:
        """
        严格原样将用户输入转发给能源查询 API，同时打印 __user__ 和 __metadata__ 内容。

        :param message: 用户原始输入文本
        :param __user__: OpenWebUI 自动传入的用户信息字典（可选）
        :param __metadata__: OpenWebUI 自动传入的上下文或元数据字典（可选）
        :return: 后端 reply 字段内容或错误信息
        """
        if not message:
            return "输入为空"

        # 打印 __user__ 和 __metadata__ 内容，查看有哪些字段可用
        print("当前 __user__ 信息:", __user__)
        print("当前 __metadata__ 信息:", __metadata__)

        # 优先使用 __user__ 中的 id，如果没有传入则用默认值
        user_id = None
        # if __user__:
        #     user_id = __user__.get("id")  # 文档示例通常用 id 字段作为唯一标识
        # if not user_id:
        #     user_id = "unknown_user"
        if __metadata__:
            user_id = __metadata__.get("chat_id")  # 文档示例通常用 id 字段作为唯一标识
        if not user_id:
            user_id = "unknown_chat"

        # URL 编码，保留中文符号
        encoded_msg = urllib.parse.quote(message, safe="")

        url = f"http://localhost:9001/chat?user_id={user_id}&message={encoded_msg}"

        try:
            resp = requests.get(url, timeout=300)
            resp.raise_for_status()
            data = resp.json()
            # 对openwebui屏蔽返回细节
            return {"reply": data.get("reply") or "服务繁忙，请稍后再试"}
        except Exception as e:
            return f"服务异常，请联系管理员:{e}"
```

用于提取openwebui内部信息，并且将`chat_id`传入`user_id`，实现按照会话管理上下文图谱。

![image-20251118163900809](%E8%83%BD%E6%BA%90%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%B9%B3%E5%8F%B0%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF%E5%8F%8A%E5%AE%9E%E7%8E%B0.assets/image-20251118163900809.png)

### 八、实际效果

![image-20251116214117725](%E8%83%BD%E6%BA%90%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%B9%B3%E5%8F%B0%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF%E5%8F%8A%E5%AE%9E%E7%8E%B0.assets/image-20251116214117725.png)

## 6.15 升级Reply用户体验

![image-20251121110441120](%E8%83%BD%E6%BA%90%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%B9%B3%E5%8F%B0%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF%E5%8F%8A%E5%AE%9E%E7%8E%B0.assets/image-20251121110441120.png)

![image-20251121104124251](%E8%83%BD%E6%BA%90%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%B9%B3%E5%8F%B0%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF%E5%8F%8A%E5%AE%9E%E7%8E%B0.assets/image-20251121104124251.png)

![image-20251121182554642](%E8%83%BD%E6%BA%90%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%B9%B3%E5%8F%B0%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF%E5%8F%8A%E5%AE%9E%E7%8E%B0.assets/image-20251121182554642.png)

![image-20251121184321703](%E8%83%BD%E6%BA%90%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%B9%B3%E5%8F%B0%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF%E5%8F%8A%E5%AE%9E%E7%8E%B0.assets/image-20251121184321703.png)

![image-20251121184339791](%E8%83%BD%E6%BA%90%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%B9%B3%E5%8F%B0%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF%E5%8F%8A%E5%AE%9E%E7%8E%B0.assets/image-20251121184339791.png)

![image-20251121185120048](%E8%83%BD%E6%BA%90%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%B9%B3%E5%8F%B0%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF%E5%8F%8A%E5%AE%9E%E7%8E%B0.assets/image-20251121185120048.png)

![image-20251124112403212](%E8%83%BD%E6%BA%90%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%B9%B3%E5%8F%B0%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF%E5%8F%8A%E5%AE%9E%E7%8E%B0.assets/image-20251124112403212.png)

## 6.16 趋势分析和图表展现

![image-20251125105559494](%E8%83%BD%E6%BA%90%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%B9%B3%E5%8F%B0%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF%E5%8F%8A%E5%AE%9E%E7%8E%B0.assets/image-20251125105559494.png)

![image-20251125105635522](%E8%83%BD%E6%BA%90%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%B9%B3%E5%8F%B0%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF%E5%8F%8A%E5%AE%9E%E7%8E%B0.assets/image-20251125105635522.png)

![image-20251125171500204](%E8%83%BD%E6%BA%90%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%B9%B3%E5%8F%B0%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF%E5%8F%8A%E5%AE%9E%E7%8E%B0.assets/image-20251125171500204.png)

# 七、流程编排和智能体

## 7.1 Prompt能做流程编排吗？

> openwebui这种在回话里调用Function Calls的机制是怎么样的？我的理解是假如用户一个问题分为几个步骤，而且LLM需要在文中提取中间调研api的准确参数，调用api后得到结果又需要对返回内容做分析，最后得出满意的结果，这些都是prompt规定好的。我有两个疑问：1. prompt就能做流程编排吗？那所有的智能体流程编排有什么区别？2. LLM或者openwebui能在一个对话中就能分步骤进行多项任务在合并的机制是什么样的？步骤中间LLM在等待？

你提的两个问题非常核心，涉及 **LLM 与 Function Call / Agent 的工作机制**，我来详细分析一下，顺便澄清一些常见误区。

------

1️⃣ Prompt 能做流程编排吗？

理论上 **prompt 可以描述流程**，比如：

- “先调用 API A 获取用户信息，再用结果调用 API B 查询库存，最后总结输出。”
- 你可以在 prompt 里把每个步骤和逻辑写清楚，模型会尽力按照这个流程生成“操作指令”。

**局限性**：

1. **可靠性低**
   - LLM 是生成式模型，它并不真正“执行”步骤，只是生成下一步的文本/指令。
   - 如果流程很复杂或条件分支很多，单纯靠 prompt 容易出错。
2. **缺乏状态管理**
   - LLM 本身不维护变量或上下文状态，它只能基于前文生成下一步。
   - 如果需要跨多个步骤引用中间结果，必须要把这些结果以文本形式重新传入 prompt。

所以 **纯 prompt 可以做简单流程，但不能像“真正的 Agent”一样可靠地做复杂编排**。

------

2️⃣ 智能体/Agent 与流程编排的区别

智能体框架（如 **LangChain Agent / OpenWebUI 的 Function Calls**）的核心是：

- **任务拆分 & 步骤调度**：把用户需求分成多个子任务。
- **Function/工具调用**：自动调用外部函数/API，获取结构化结果。
- **结果管理**：把中间结果缓存/合并，供后续步骤使用。
- **决策循环**（可选）：根据上一步的结果决定下一步该做什么。

对比纯 prompt：

| 特性         | 纯 Prompt          | Agent/Function Call            |
| ------------ | ------------------ | ------------------------------ |
| 流程控制     | 靠文字描述         | 靠代码/工具调用 + LLM 输出指令 |
| 中间结果管理 | 全靠 prompt 上下文 | 独立变量存储、可复用           |
| 条件分支     | 依赖模型生成       | 可以程序化判断执行哪步         |
| 多工具组合   | 很难可靠           | 天生支持多工具、多 API         |

所以 **智能体的价值不是让 LLM 更聪明，而是让 LLM 的输出变成可执行、可管理的流程**。

------

3️⃣ OpenWebUI / LLM 在对话中多步骤任务的机制

以 OpenAI Function Call 为例（OpenWebUI 也类似）：

1. **用户输入**

   > “帮我查一下武汉今天的天气，然后帮我分析一下温度变化趋势。”

2. **模型生成 Function Call**

   - 模型识别到需要调用 `getWeather(latitude, longitude)`，于是生成 function call JSON（包括函数名、参数）。

3. **外部系统执行 Function Call**

   - OpenWebUI 或服务端接收到这个 JSON，调用 API，拿到结果。

4. **结果返回给模型**

   - API 的返回值被包装成消息，放入对话上下文。

5. **模型生成下一步分析**

   - 模型基于“API返回 + 上下文 + Prompt 指令”，生成最终输出或下一次函数调用。

6. **循环**

   - 如果任务有多步（分析、决策等），模型可以继续生成新的 function call，直到完成。

> 🔑 核心机制：**模型生成调用指令 → 系统执行 → 结果回传 → 模型生成下一步**。
>  这个循环让“多步骤任务”得以在一个对话中完成。

中间步骤等待机制

- LLM **并不主动等待**，它只是生成指令或分析的“文本/JSON”。
- **等待是由外部系统管理的**：系统收到模型生成的 function call 后去调用 API，然后把返回值重新放回对话上下文，交给 LLM 处理下一步。
- 所以可以理解为 **LLM 是在“暂停生成”状态，直到收到 API 返回的上下文**。

------

🔹 总结

1. **Prompt 可以描述流程，但可靠性有限**，复杂逻辑最好交给 Agent 框架或函数调用机制处理。
2. **Agent/Function Call 的核心是循环执行机制**：
   - LLM 生成调用 → 系统执行 → 结果返回 → LLM 继续生成
   - 这样可以在一个对话里拆解多步任务，并管理中间结果。
3. **等待步骤不是 LLM 自己处理的**，是由框架/系统控制的“外部等待”。
4. **智能体的区别**在于流程的可控性、条件分支和结果缓存，而不只是生成文本。

## 7.2 只靠 WebUI + Prompt 能否实现复杂流程


> 那你的意思是我只要在webui中提示次写得到足够好，不敢流程多么复杂，比如需要重新调用一个接口得到正确的结果后才进行下一步。这些都是能实现的？因为openwebui在我的理解本身应该也是个agent管理器

对，你理解的方向基本对了 👍。不过有几个关键点需要掰开来说：

------

1. **只靠 WebUI + Prompt 能否实现复杂流程？**

- **简单流程**（比如查天气 → 分析 → 输出）确实可以只靠 prompt + Function Call 搞定，因为每一步都能通过 function call 返回再继续。
- **复杂流程**（比如「如果 API 返回的数据缺失，就改参数重新调用，直到满足条件」），靠 **单纯 prompt** 就很脆弱了：
  - 模型可能忘了重试
  - 参数修正不准
  - 出现死循环或者提前结束

换句话说：**Prompt 能写逻辑，但 LLM 不保证严格执行**。

------

2. **OpenWebUI 的定位**

你说的没错：

- **OpenWebUI 本身就是一个轻量的 Agent 管理器**。
- 它的功能就是让 LLM 在对话里可以调用外部函数（API、脚本、插件），并把结果重新丢回给模型。
- 它不强制你用额外的 “流程编排引擎”，但你可以写 prompt 或插件，让 LLM 在多次调用之间“像个 Agent 一样”执行。

可以把它理解为：

- **核心执行器**：负责调用、回传、循环
- **LLM Prompt**：负责思考、决定下一步
- **外部 API/工具**：负责提供数据和动作

------

3. **如果流程需要“重试/判断/多分支”怎么办？**

有两种做法：

✅ 方式 A：靠 LLM + Prompt

在提示词里写清楚策略，比如：

> “如果 API 返回为空，请自动修改参数再次调用，直到结果非空为止；最多重试 3 次。”

这样 LLM 会尽力遵守。
 ⚠️ 风险：有时会忘记次数、死循环，结果不可控。

✅ 方式 B：用 OpenWebUI 插件/外部脚本做逻辑

- LLM 只负责“决策”或“填参数”。
- **外部逻辑控制**重试、分支、循环。
- 这样流程是**可控 + 稳定**的。

很多 Agent 框架（LangChain、LlamaIndex）其实就是做这层“外部逻辑控制”，不再全靠 LLM 自己。

------

4. **多步骤任务合并机制**

- 在 OpenWebUI，一个对话本质就是：
   **LLM 输出 → Function Call → 系统执行 → 结果回传 → LLM 继续 → …**
- 只要你的 prompt 写得清楚，LLM 就会在一个对话里完成多轮调用，直到你满意。
- “等待”是由 **WebUI 系统**来管理的，不是 LLM 自己挂起。

------

✅ 结论：

- 你说的没错，**OpenWebUI 可以当作一个轻量 Agent 管理器**。
- **只靠 prompt，简单流程没问题，复杂流程可能不稳**。
- 如果你要做“必须保证正确、要判断重试”的场景，建议把逻辑交给 **WebUI 插件 / 外部脚本**，LLM 只做“思考和生成参数”。

## 7.3 Agent智能体

> 那agent智能体和openwebui有什么关系，或者说agent智能体到底是什么东西，我能说我在openwebui工具里安装的查询天气的工具，绑定某个模型后就是一个agent智能体吗

这个问题问得非常好 👍，很多人会把 **Agent**、**工具 (tool)**、**WebUI** 混在一起。咱们把层次拆开来看看：

------

1. **Agent 智能体的本质**

在学术和框架里，Agent 通常指：

> **一个能自主感知环境、调用工具、规划步骤、并根据反馈调整行为的系统**。
>  核心要素是：
>
> - **目标驱动**（用户给定的任务/问题）
> - **推理决策**（由 LLM 等模型生成下一步动作）
> - **行动能力**（调用工具、API、执行代码）
> - **反馈循环**（用结果更新状态，继续下一步）

所以，**Agent ≠ 单个 LLM**，它是 **“LLM + 工具 + 外部逻辑”** 的组合。

------

2. **OpenWebUI 的定位**

OpenWebUI 自身是一个 **对话容器 + 工具调用管理器**，主要做：

- 把用户输入送给模型
- 让模型可以发出 function call
- 把 function call 转成外部 API 请求
- 把返回结果再喂给模型

👉 它更像是一个 **轻量 Agent 框架**，但它本身不是“智能体”，而是“智能体的运行环境”。

------

3. **工具 (tool) 与 Agent 的关系**

- 在 OpenWebUI 里，你装的“查询天气工具”只是一个 **功能函数**。
- 当 LLM 知道怎么用它（比如输入参数、解析结果）并能结合结果完成任务时，才形成一个 **最简形式的 Agent**。

所以：

- 工具 = **Agent 的手**
- LLM = **Agent 的脑**
- OpenWebUI = **Agent 的身体（运行环境）**

------

4. **那你能说“在 OpenWebUI 里装个天气工具就有了一个 Agent 吗”？**

要分情况：

- ❌ 如果只是“我装了个天气 API，模型可以直接调一下”，那还不能叫完整的智能体，它更像一个 **工具增强的聊天模型**。
- ✅ 如果你写好 Prompt 或逻辑，让模型能：
  1. 知道什么时候要调用天气 API
  2. 能自己提取参数去调用
  3. 能根据结果继续下一步思考
  4. 最终完成一个完整任务
      👉 那么这个组合（LLM + 工具 + WebUI 管理循环）就可以称作一个 **Agent 智能体**。

------

5. **一句话总结**

- **Agent 智能体不是某个单独的软件，而是一种模式：LLM + 工具 + 推理循环**。
- **OpenWebUI 提供了运行环境**，让你能把模型和工具绑在一起跑成一个 Agent。
- 你在 OpenWebUI 里给模型装了“天气查询工具”，如果模型能自主决定调用、分析结果并回答用户问题，那就是一个最简单的 **Agent 智能体**。

# 八、RAG

##  1. 为什么有了大模型还需要 RAG（检索增强）

大模型（GPT、DeepSeek、Qwen）≠ 万能搜索引擎，它的特点是 **语言理解强**，但 **知识时效性有限**。
 RAG（Retrieval-Augmented Generation）就是用来 **补足模型的短板**。

### 📌 大模型的优点

- 擅长语言理解、推理、生成（比如把查询转 SQL、把结果写成结论）。
- 不需要严格的数据库 Schema 记忆，也能“模糊匹配”用户意图。

### 📌 大模型的缺点

- 只知道它训练截止时的数据，没法实时知道马钢的指标库、报表里的最新数据。
- 如果你直接问模型“马钢 1#高炉昨天的能耗”，它会编造（hallucination）。

### 📌 RAG 的作用

- **把最新的数据喂给模型**（从知识库、数据库、文档检索结果里提取出来）。
- 模型再基于这些上下文来回答 → 保证结果既“聪明”又“真实”。

所以关系是这样的：
 👉 **模型 = 大脑**（会推理、会表达）
 👉 **RAG = 记忆库**（给大脑最新的资料）
 👉 两者配合 = 聪明又靠谱

比如：

1. 用户问：“1#高炉 8 月能耗比 7 月高吗？”
2. RAG 检索：数据库里取出 7 月和 8 月的能耗数值。
3. 模型：拿到数值，生成结论 + 图表 → “8 月能耗比 7 月高 5%，主要因为……”

------

## 🧩 2. NL2SQL 的位置

- NL2SQL = 把自然语言转成 SQL。
- 模型负责理解用户意图，RAG 或 Schema 信息告诉模型“哪些表、哪些字段”，它再写出 SQL 去查询数据库。
- 查询结果再交给模型解读。
   👉 这里模型和 RAG 是配合的：RAG 给 Schema & 样例，模型做理解和生成。

------

## 🧩 3. 如果你要 **训练自己的大模型**

其实大多数项目 **不需要从零训练大模型**，因为：

- 训练 GPT 级别大模型 = 上千张 GPU，几百万美元。
- 你要的主要是企业内部知识 + 数据分析，这些用 **微调 / 增量学习 / RAG** 就够。

### ✅ 实际上你需要做的是：

1. **准备知识库**
   - 把预案文本、工艺规程、指标解释，整理成文档。
   - 存入向量数据库（pgvector、Milvus）。
2. **做 Embedding（向量化）**
   - 用 OpenAI embedding、或者国产 embedding 模型（如 bge）。
   - 把知识库转成向量，方便检索。
3. **做 RAG 流程**
   - 用户问题 → 相似文档检索 → 大模型回答。
4. **微调 / LoRA（可选）**
   - 如果你有大量问答对（例如历史运维对话、指标问答记录），可以对开源模型（如 Qwen2.5、Baichuan2）做轻量微调。
   - 这样模型能更懂你们工厂里的术语。
5. **搭建中间层（Dify/LangChain）**
   - 负责把“RAG 检索、NL2SQL 查询、模型调用”串起来。

------

## 🎯 总结

- **大模型负责聪明回答**，但不知道你们的最新知识。
- **RAG负责补充知识**，让模型回答有根据。
- **NL2SQL负责查数据库**，把实时数据接入。
- **你不需要训练大模型**，只需要：
  - 建知识库 + 向量化
  - 搭建 RAG 流程
  - 必要时做小规模微调

这样就能满足“知识检索 + 智能问数 + 智能诊断”的需求。

# 八、本机部署轻量级大模型

现在大模型感觉像是控制数据出口最后一环，如果我希望自己搭建一套大模型，按照你前面的说法，我是没有能力从零开始重新训练的，那么我应该选择一种大模型就行部署，那你谈到的微调又是指哪方面的微调。我希望尽快在我们8G内存ubuntu系统上部署一套轻量级的大模型，具体有哪些操作步骤

非常清晰 👌，我帮你按“可落地”的角度梳理一下。你现在的条件是：

- **机器条件**：Ubuntu + 8GB 内存（可能是轻量服务器/云主机）。
- **目标**：自己部署一套轻量级大模型，能本地跑，能做知识问答/分析。
- **限制**：不能从零训练，只能选择已有开源模型 + 做轻量化微调。

------

## 🧩 1. 为什么不能从零训练

- 从零训练 GPT/Qwen 级别模型，需要海量数据和 GPU 集群，你的 8GB 内存服务器完全不够。
- 但是：你完全可以 **选一个小模型 → 本地部署 → 做微调/RAG → 满足企业需求**。

------

## 🧩 2. 什么是微调

微调（Fine-tuning）有几种层次：

1. **全量微调（Full fine-tune）**：重训练模型参数 → 需要超大算力 → 你用不了。
2. **轻量微调（LoRA / QLoRA）**：只训练部分参数，用很少显存（甚至 CPU）也能做 → ✅ 适合你。
3. **指令微调（Instruction tuning）**：用企业的问答对、场景指令训练模型，让模型更懂你的业务术语。
4. **Embedding + RAG（非训练）**：不用改模型，只是额外建一个向量知识库，把知识查出来给模型 → ✅ 这是最现实的方式。

👉 你要的是 **轻量微调（LoRA/QLoRA）+ RAG**。

------

## 🧩 3. 在 8GB Ubuntu 上可选的模型

可以部署的轻量开源模型（CPU/GPU 都能跑，但速度不快）：

- **Qwen2.5-1.5B**（阿里出品，中文表现好，小参数）
- **LLaMA 3 8B / 7B（量化版）**（Meta 出品，通用英文强，中文还行）
- **Mistral-7B-instruct**（推理能力好，量化版能在 8GB 内跑）
- **ChatGLM3-6B（INT4 量化版）**（清华出品，适合中文任务）

👉 推荐你选 **Qwen2.5-1.5B** 或 **ChatGLM3-6B-INT4**，更适合中文+工业场景。

------

## 🧩 4. 部署操作步骤（落地版）

### **步骤 1：准备环境**

```
sudo apt update && sudo apt upgrade -y
sudo apt install python3 python3-pip git -y
```

### **步骤 2：安装 Ollama（最简单的本地模型运行器）**

```
curl -fsSL https://ollama.com/install.sh | sh
```

日志：

```
fusionshen@fusionshen-ThinkPad-T14-Gen-1:~$ curl -fsSL https://ollama.com/install.sh | sh
>>> Installing ollama to /usr/local
>>> Downloading Linux amd64 bundle
######################################################################## 100.0%
>>> Creating ollama user...
>>> Adding ollama user to render group...
>>> Adding ollama user to video group...
>>> Adding current user to ollama group...
>>> Creating ollama systemd service...
>>> Enabling and starting ollama service...
Created symlink /etc/systemd/system/default.target.wants/ollama.service → /etc/systemd/system/ollama.service.
>>> Downloading Linux ROCm amd64 bundle
######################################################################## 100.0%
>>> The Ollama API is now available at 127.0.0.1:11434.
>>> Install complete. Run "ollama" from the command line.
>>> AMD GPU ready.
fusionshen@fusionshen-ThinkPad-T14-Gen-1:~$ ollama --version
ollama version is 0.11.10
```

### **步骤 3：拉取模型**

比如用 Qwen2.5-1.5B：

```
ollama pull qwen2.5:1.5b
```

日志：

```
fusionshen@fusionshen-ThinkPad-T14-Gen-1:~$ ollama pull qwen2.5:1.5b
pulling manifest 
pulling 183715c43589: 100% ▕██████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████▏ 986 MB                         
pulling 66b9ea09bd5b: 100% ▕██████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████▏   68 B                         
pulling eb4402837c78: 100% ▕██████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████▏ 1.5 KB                         
pulling 832dd9e00a68: 100% ▕██████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████▏  11 KB                         
pulling 377ac4d7aeef: 100% ▕██████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████▏  487 B                         
verifying sha256 digest 
writing manifest 
success 

```

运行：

```
ollama run qwen2.5:1.5b
```

日志：

```
fusionshen@fusionshen-ThinkPad-T14-Gen-1:~$ ollama run qwen2.5:1.5b
>>> 你好
你好！很高兴为你提供帮助。请问有什么问题我可以帮到你吗？

>>> 你有哪些能力
我有以下一些基本的能力：
1. 对话：能够和用户进行自然对话，理解并回答用户的问题。
2. 语言处理：可以理解和生成符合语法规则的中文文本，包括但不限于文本翻译、摘要提取等任务。
3. 学习：通过大量的语料库学习到特定的知识和技能。
4. 知识获取：我可以通过互联网搜索提供各种类型的信息。
5. 计算能力：能够执行基本的数学运算。
6. 图像处理：可以分析和解释图片中的内容。

这些功能都是基于我所设计的语言模型来实现的。如果你有任何具体的问题或需要帮助的地方，请告诉我，我会尽力提供支持。

>>> 你能分清楚：1#高炉，1高炉，高炉的区分吗
在你描述的情况下，“1#高炉”，“1 高炉”，以及“高炉”是三者分别代表的意思如下：

- "1#高炉"：这是表示“编号为1的高炉”的意思。通常这种形式用于产品分类，或某个设施、设备的编号。
  
- "1 高炉"：这是一种简写方式，用来指代一个具体的“高炉”。这里的“1”可以是生产单位（比如车间）的编号，也可以是生产线上的编号，或者是操作该设备的具体编号。

- “高炉”：这是一个通用名词，没有特定的含义。在不同的上下文中，“高炉”可能会有不同的解释或者用途。

简单来说，"1#高炉"通常指的是某个具体的“高炉”的编号，而"1 高炉"则是一个简化的描述方式来指代一个具体存在的“高炉”。因此，这两个表达在不同的情境中可能有细微的差别。

>>> 那你觉得1#高炉和1高炉指的是同一个吗？
通常情况下，“1#高炉”和“1 高炉”的含义是相同的，它们都是指代某个具体的存在或编号的“高炉”。这种表示方式常见于一些系统或者设备中，用于标识特定的一个对象。

例如，如果有一条生产线，该生产线有多个设备编号分别是1, 2, 和3，并且这条生产线上有一个叫做“一号设备”的具体的设备（比如一个高炉），那么在这个场景下，“1#高炉”和“1 高炉”都是指代这个特
定的、编号为1的高炉。这种表示方式可以避免重复使用同一个数字，增加信息的有效性。

不过，在某些情况下，可能因为上下文的不同而有不同的解释，例如：

- “1#高炉”中的“1”可能是某个具体的编号或者是操作该设备的一般编号。
- 另外，“1 高炉”的描述也有可能是某种特定场景或应用的需要，比如在某项比赛中或比赛中的一部分，有具体编号的设备被指代为“一号”。

不过，在大多数情况下，这两种表示方式是相互对应的。
```

如果要 ChatGLM3：

```
ollama pull chatglm3
ollama run chatglm3
```


### **步骤 4：轻量微调（可选）**

如果你有历史问答数据，可以用 **LoRA 微调**（推荐使用 `PEFT` + Hugging Face）。
 安装：

```
pip install peft transformers datasets accelerate
```

ollama pull qwen2.5:1.5b然后用几百条问答对就能做轻量定制。

------

## 🧩 5. 你的最快落地方案

1. 在 **Ubuntu 上安装 Ollama**。
2. 拉取 **Qwen2.5-1.5B**（占用小，中文强）。
3. 用 **ChromaDB + LangChain** 搭建 RAG。
4. 如果业务需要更懂专业词汇，再考虑用 **LoRA 做小规模微调**。

------

## 🎯 总结

- **不从零训练 → 选开源轻量模型（Qwen2.5-1.5B 或 ChatGLM3-6B-INT4）**。
- **RAG 是第一步落地，LoRA 微调是锦上添花**。
- **Ollama** 让部署超级简单，几行命令就能本地跑。